<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liupzmin.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文主要讲述了我对 I&#x2F;O 的一些理解，剖析了 Go 语言netpoller是如何结合 epoll 和 goroutine 的，文章还简单畅想了 io_uring 可能会带来的改变，并阐述了我对于异步编程的一点浅陋思考，希望能跟大家一起探讨。  作为 Gopher，你想必听过“Go 为我们提供了同步的网络 I&#x2F;O 编程接口”，或者“Go 为我们提供了阻塞的网络 I&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="异步 I&#x2F;O 探秘 —— 为什么说 Go 为我们提供了同步的网络编程接口 ？">
<meta property="og:url" content="http://liupzmin.com/2023/06/28/golang/netpoller/index.html">
<meta property="og:site_name" content="兔子先生">
<meta property="og:description" content="本文主要讲述了我对 I&#x2F;O 的一些理解，剖析了 Go 语言netpoller是如何结合 epoll 和 goroutine 的，文章还简单畅想了 io_uring 可能会带来的改变，并阐述了我对于异步编程的一点浅陋思考，希望能跟大家一起探讨。  作为 Gopher，你想必听过“Go 为我们提供了同步的网络 I&#x2F;O 编程接口”，或者“Go 为我们提供了阻塞的网络 I&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qiniu.liupzmin.com/Comparison%20of%20the%20five%20IO%20models.png">
<meta property="article:published_time" content="2023-06-28T12:08:30.000Z">
<meta property="article:modified_time" content="2025-02-07T01:32:12.639Z">
<meta property="article:author" content="巴流">
<meta property="article:tag" content="golang - network - netpoller - synchronous&#x2F;asynchronous">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qiniu.liupzmin.com/Comparison%20of%20the%20five%20IO%20models.png">


<link rel="canonical" href="http://liupzmin.com/2023/06/28/golang/netpoller/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://liupzmin.com/2023/06/28/golang/netpoller/","path":"2023/06/28/golang/netpoller/","title":"异步 I/O 探秘 —— 为什么说 Go 为我们提供了同步的网络编程接口 ？"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>异步 I/O 探秘 —— 为什么说 Go 为我们提供了同步的网络编程接口 ？ | 兔子先生</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="兔子先生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">兔子先生</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探寻计算机的历史与哲学密码</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">63</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5"><span class="nav-number">1.</span> <span class="nav-text">为什么需要异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">2.</span> <span class="nav-text">同步、异步、阻塞、非阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">I&#x2F;O 多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netpoller"><span class="nav-number">4.</span> <span class="nav-text">netpoller</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.1.</span> <span class="nav-text">epoll 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91-epoll-%E5%AE%9E%E4%BE%8B%E6%B3%A8%E5%86%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">4.2.</span> <span class="nav-text">向 epoll 实例注册描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="nav-number">4.3.</span> <span class="nav-text">事件分发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#goroutine-%E7%9A%84%E5%81%9C%E6%B3%8A%E4%B8%8E-pollDesc"><span class="nav-number">4.4.</span> <span class="nav-text">goroutine 的停泊与 pollDesc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%BC%82%E6%AD%A5-I-O"><span class="nav-number">5.</span> <span class="nav-text">下一代异步 I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E8%AE%BA%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">再论异步编程模型</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="巴流"
      src="/images/gzh.jpg">
  <p class="site-author-name" itemprop="name">巴流</p>
  <div class="site-description" itemprop="description">左手人文 | 右手科技</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liupzmin"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdXB6bWluQGdtYWlsLmNvbQ==" title="E-Mail → mailto:liupzmin@gmail.com"><i class="envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/06/28/golang/netpoller/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="异步 I/O 探秘 —— 为什么说 Go 为我们提供了同步的网络编程接口 ？ | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          异步 I/O 探秘 —— 为什么说 Go 为我们提供了同步的网络编程接口 ？<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2xpdXB6bWluLmdpdGh1Yi5pby9lZGl0L2hleG9fcmVzb3VyY2Uvc291cmNlL19wb3N0cy9nb2xhbmcvbmV0cG9sbGVyLm1k" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-28 20:08:30" itemprop="dateCreated datePublished" datetime="2023-06-28T20:08:30+08:00">2023-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>本文主要讲述了我对 I&#x2F;O 的一些理解，剖析了 Go 语言<code>netpoller</code>是如何结合 epoll 和 goroutine 的，文章还简单畅想了 io_uring 可能会带来的改变，并阐述了我对于异步编程的一点浅陋思考，希望能跟大家一起探讨。</p>
</blockquote>
<p>作为 Gopher，你想必听过<strong>“Go 为我们提供了同步的网络 I&#x2F;O 编程接口”</strong>，或者<strong>“Go 为我们提供了阻塞的网络 I&#x2F;O 编程接口”</strong>这样的表述。</p>
<p>那么，这样的表达有什么问题吗？</p>
<p>答案是：完全没问题！</p>
<p>这两句话所传达的事实是确凿无疑的，但前提是，你需要多思考一步：优异的网络框架不应该是同步的！</p>
<p>如果网络的读写都是同步的，就无法应对高并发、高吞吐的应用场景，二十多年前的计算机前辈们就提出了 <span class="exturl" data-url="aHR0cDovL3d3dy5rZWdlbC5jb20vYzEway5odG1s">C10K<i class="fa fa-external-link-alt"></i></span> 问题，也就是单机如何支持 1 万个并发连接的问题。</p>
<p>在 Linux 上， C10K 问题最终的解决方案是<strong>非阻塞 IO+epoll</strong> 的 <strong>I&#x2F;O 多路复用</strong>技术，且一直沿用至今。</p>
<p>所以，一门优秀的语言必须解决 C10K 问题。事实上，这里的“同步”仅仅是指 Go 提供的“编程接口”，而不是内在的网络模型。</p>
<p>但是，为什么一定要提供同步的编程接口呢？</p>
<p>人类生活在一个充满异步的世界里，许多事物和事件并行发生，而计算机的发展却是从同步开始的，汇编语言以及其它的低级语言为我们塑造了原始的同步编程模型，我们已经越来越习惯它了，这就导致异步编程成为一件复杂且困难的事。</p>
<p>因此，以高效的内在网络模型为内核，向外提供同步的用户编程接口，会成为解救程序员思维，让编程体验极度舒适的善举。</p>
<h2 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步"></a>为什么需要异步</h2><p>对异步的渴求，其实是源自于对高效率的渴望。</p>
<p>一切都因为 CPU 太快，I&#x2F;O 设备太慢，需要运行的任务太多。这是目前计算机所面临的现状。</p>
<p>然而，CPU 和 I&#x2F;O 设备是可以并行工作的。通过异步操作，CPU 可以在等待 I&#x2F;O 操作完成的同时继续执行其他指令，充分利用其计算能力。当 I&#x2F;O 操作完成时，CPU 会收到通知，并处理 I&#x2F;O 返回的结果，唤醒等待者。</p>
<p>可见，这种异步模型能极大地提高系统的吞吐量和响应能力，尤其在需要同时处理大量 I&#x2F;O 操作时，异步的优势相比同步会更加明显。</p>
<p>简单总结一下异步 I&#x2F;O 的优势，有如下两点：</p>
<ol>
<li><strong>能够在等待 I&#x2F;O 操作的同时执行其它任务，充分利用 CPU 的计算能力。</strong>换句话说，正在 CPU 上披荆斩棘的线程不会因为一次 I&#x2F;O 而停下脚步，在提交了 I&#x2F;O 申请之后可以去执行下一个任务，而执行下一个任务的能力是由并发模型决定的。</li>
<li><strong>最大限度地发挥 I&#x2F;O 设备的吞吐能力。</strong>当系统中存在大量并发的 I&#x2F;O 操作，或者有多个独立的任务可以并行处理时，异步 I&#x2F;O 能够提供更好的性能和资源利用率。</li>
</ol>
<p>最常见的文件 I&#x2F;O 和网络 I&#x2F;O 是最需要异步的，文件读写极有可能会遇到所读内容不在高速页缓存中的情况，此时需要等待慢速磁盘将内容读入内存；网络读写也无法永远保证 socket 缓冲区的就绪状态（读&#x2F;写系统调用发生时，缓冲区有内容可读与有空间可写）。等待这两种 I&#x2F;O 完成的代价实在太大，也就很有必要将其异步化——在 I&#x2F;O 设备工作的同时，让 CPU 去完成其它任务。</p>
<p>然而，需要留意的是：异步 I&#x2F;O 的效率提升主要取决于系统中存在的并行任务数量和性质。如果计算机只有少量任务且这些任务必须串行进行，那么异步 I&#x2F;O 可能不会带来明显的性能提升，因为任务之间无法并行执行。</p>
<h2 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h2><p><strong>同步、异步、阻塞、非阻塞</strong>这两对儿概念总是绕不过去的，同时也是无法轻易阐述明白的，本文无意做这种努力。<strong>软件领域并不存在一以贯之的概念，想要在概念上把软件行为掰扯清楚明白将注定徒劳无功。</strong></p>
<p>能够确定的是，在很多场景下，这两对概念可以描述同一件事情，比如，以电商系统中用户下单为例，对支付系统需不需要等待订单处理系统的反馈问题上，可以分为同步、异步或者阻塞、非阻塞两种情况。如果支付系统需要等待订单处理的结果，那么就可以说这个过程是同步的，或者说订单处理流程阻塞了用户下单；如果支付系统在用户支付后就向用户反馈结果，并将新生成的订单以消息事件的方式通知下游订单系统处理，就可以说这个过程是异步的，订单的处理是非阻塞的。</p>
<p>但事情并不总是这样，比如谈到网络 I&#x2F;O 时，这两对儿概念就不能等量齐观了。</p>
<p>每个 socket 连接都有两个缓冲区，一个用于发送，一个用于接收，当接收缓冲区为空，发送缓冲区满的时候，网络的读&#x2F;写就会阻塞，此时意味着线程会失去 CPU，应用发出的读&#x2F;写系统调用在内核代码路径中会触发进&#x2F;线程的调度，在缓冲区就绪之前，线程会被换下 CPU 进入被阻塞的等待状态。因此，当在系统调用、内核态等上下文中提到阻塞的时候，往往意味着进&#x2F;线程的切换，意味着有人失去 CPU，进而失去执行其它任务的机会。</p>
<p>同步就像是函数调用，一旦发出请求，就必须等到执行完成后返回，才能继续往下进行；异步则不然，发出请求后会立马返回，I&#x2F;O 操作会在未来某个时刻完成并通知请求者。这样看来，在网络 I&#x2F;O 这件事上，同步和阻塞的表达看上去没有什么区别，而非阻塞和异步就有些微妙了，这还要从非阻塞的功能意义上说起。</p>
<p><code>fnctl</code>系统调用可以通过<code>O_NONBLOCK</code>标志将文件设置为非阻塞，吊诡的是，这个非阻塞标志只对网络文件描述符起作用，对于普通的磁盘文件描述符是没有任何效果的。</p>
<p>这其实完全可以理解，文件并不像网络有一个缓冲区，文件流永远都是就绪的。那么，当网络文件描述符被设置为非阻塞之后会有什么样的表现呢？我们分别描述一个网络文件描述符在阻塞和非阻塞状态下<code>read</code>系统调用的过程。</p>
<p>假设应用基于这个文件描述符发出<code>read</code>系统调用的时候，socket 接收缓冲区为空（网络消息尚未到达）：</p>
<ol>
<li><strong>阻塞：</strong>当前的应用线程会因此被阻塞，进而被内核调离 CPU，当网络消息到达之后，缓冲区就绪，产生网络中断，内核获得 CPU 使用权，再次将应用线程换上 CPU ，<code>read</code>系统调用继续，CPU 将消息拷贝至用户空间，系统调用完成。</li>
<li><strong>非阻塞：</strong><code>read</code>系统调用会立即返回，并附带一个<code>EWOULDBLOCK</code>或者<code>EAGAIN</code>的错误，从错误含义就可以看出一些端倪，仿佛内核告诉你：“这次调用会造成阻塞，不过没关系，我发现你设置了非阻塞标志，我不会将你挂起，请你过一会儿再试吧！” 此时，应用就可以去做其它的任务，并在需要的时候重新发起<code>read</code>系统调用进行读取，缓冲区一旦就绪，CPU 就会将消息拷贝至用户空间。</li>
</ol>
<p>很明显的一点是，非阻塞调用除了通知应用缓冲区尚未就绪之外，没做其它的事情。应用需要不断地试探，在某一次碰巧赶上缓冲区就绪时，这次<code>read</code>系统调用才宣告成功，因此问题的关键是：<strong>应用在得知缓冲区就绪之前，不知道要发出多少系统调用来试探！</strong></p>
<p>而异步的网络 I&#x2F;O，除了会在系统调用发出后立即返回之外，还会在“后台”完成真正的 I&#x2F;O 操作，在这里就是将 socket 缓冲区中的内容拷贝至用户空间，并以某种方式通知应用，可见非阻塞和异步的区别还是很大的。</p>
<p>那么 Linux 平台提供异步 I&#x2F;O 的支持了吗？</p>
<p>简单说，有，但很难用，很多时候没法用！</p>
<p>POSIX 有对应的 <code>aio_read</code> 、<code>aio_write</code>等异步函数实现，但无奈太拉胯，性能奇差。</p>
<p>Linux 内核也有原生的异步 I&#x2F;O 支持，并冠以<code>AIO</code>之名，但限制很多，如只支持<code>O_DIRECT</code>访问、只支持特定设备、性能表现不佳等等，社区满意度极低，饱受诟病，我甚至找不到异步网络 I&#x2F;O 的例子，因此可以说，当前 Linux 只支持有限的文件异步 I&#x2F;O，不支持网络异步 I&#x2F;O（至少没有应用场景）。</p>
<p>要知道，在异步 I&#x2F;O 的概念出现之前，还有一种中间形态——IO 多路复用。</p>
<p>直到现在，IO 多路复用依然是 Linux 平台高并发网络的主流解决方案，以<code>epoll</code>为支点的事件循环结构铸就了当今互联网绝大多数网络程序的 <code>Reactor</code>模型。</p>
<h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p>我们可以用<strong>非阻塞+单线程或多线程</strong>的网络模型来处理大量网络连接，但是由于需要浪费 CPU 来试探缓冲区是否就绪，所以效率难免会大打折扣。</p>
<p>那么索性就让操作系统来通知我们就绪的网络文件描述符吧！这就是 I&#x2F;O 多路复用：应用只要阻塞在单个系统调用上，就可以监听多个网络文件描述符事件。</p>
<p>Linux 内核对 I&#x2F;O 多路复用支持的变迁史可简单描述为<code>select-&gt;poll-&gt;epoll</code>的改进路线 ，这三种方式原理大致相同，但性能越来越高。</p>
<p>我在读 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVy5fUmljaGFyZF9TdGV2ZW5z">Stevens<i class="fa fa-external-link-alt"></i></span> 先生的<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80MTE4NTc4Lw==">《UNIX网络编程》<i class="fa fa-external-link-alt"></i></span>时，常常奇怪：为什么书中只介绍了<code>select</code>和<code>poll</code>，却对<code>epoll</code>只字未提。后经求证，两部《UNIX网络编程》分别成书于 1990 年和 1999 年，<code>epoll</code>首次出现在 Linux 内核是在 2002 年。令人扼腕的是，Stevens 先生于 1999 年辞世，身后为我们留下了 7 部传世名著，其中就包括大家熟知的《TCP&#x2F;IP详解》三部曲。</p>
<p>让我们沿着伟人的叙述脉络，来看一看 I&#x2F;O 多路复用与其它 I&#x2F;O 模型的比较：</p>
<p><img data-src="https://qiniu.liupzmin.com/Comparison%20of%20the%20five%20IO%20models.png" alt="Comparison of the five IO models"></p>
<p>一次网络 I&#x2F;O 读取操作分成两个阶段：</p>
<p>（1）等待数据就绪 </p>
<p>（2）从内核空间拷贝数据到用户空间</p>
<p>可见，只有 <strong>blocking I&#x2F;O</strong> 和 <strong>asynchronous I&#x2F;O</strong> 能为请求者包揽两个阶段，其余的 I&#x2F;O 模型在第 1 阶段的表现各不相同，却在第 2 阶段表现一致，即均需要请求者主动完成。<strong>noblocking I&#x2F;O</strong> 为了探知数据是否就绪而空耗 CPU，这肯定是无法容忍的，于是内核出马，I&#x2F;O 多路复用诞生。</p>
<p>至于 <strong>blocking I&#x2F;O</strong> ，它是最简便的网络模型，用它来进行网络编程简洁却不高效，因为它会阻塞当前线程，引发线程切换，所以我们才会在寻求高效 I&#x2F;O 模型的道路上孜孜不倦。</p>
<p>图中有三种模型的第二阶段被标注为<code>blocked</code>，对此我有一点不同的看法，	当我们谈及系统调用的时候，阻塞通常意味着线程因工作无法继续而被调离 CPU，我们看上图中的 <strong>noblocking I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>和 <strong>signal-driven I&#x2F;O</strong> 三种模型，它们在第 1 阶段通过不同的方式得知数据已经就绪（<strong>noblocking I&#x2F;O</strong> 不是收到通知，而是通过撞运气），第 2 阶段发出系统调用开始读取数据，窃以为第 2 阶段并不存在阻塞，也并没有绝对的首恶元凶导致线程切换，这一阶段也就不应被称为“blocked”，如果非要用什么概念来描述一下的话，我愿用“同步”来称呼它。</p>
<p>事实上，Stevens 先生在讨论 asynchronous I&#x2F;O 的时候，确实将前面 4 种 I&#x2F;O 模型称为“同步 IO”，我认为这一说法成功把水搅浑了，特别是当 <strong>noblocking I&#x2F;O</strong> 和 <strong>I&#x2F;O 多路复用</strong>尚拥有一点“异步”特质的情况下，这往往让后来者很容易迷失在概念里。</p>
<p>正确的做法是：<strong>把概念丢掉，在内核和指令的维度去体认每一种 I&#x2F;O 模型</strong>。即便真的存在两个可以称之为“同步”、“异步”的明确概念，也大可不必将 noblocking I&#x2F;O、I&#x2F;O 多路复用和 signal-driven I&#x2F;O 套用其中。可以把它们看成一种中间形态，毕竟“同步”、“异步”的定语是修饰整个 I&#x2F;O 过程的，而非其中的某一步。</p>
<p><strong>非阻塞 I&#x2F;O 和 epoll</strong> 的组合或者说就是 I&#x2F;O 多路复用，是目前 Linux 平台主流的高并发网络解决方案，基本上所有的高性能网络框架或者服务器都是由此打造。然而每一项技术都不是独立存在的，也不应当被独立理解，Linux 为我们提供了 I&#x2F;O 多路复用这样一块积木，至于用这块积木能构建成怎样的世界，可能性似乎是无限的，Reactor 网络模型就是其中一例。</p>
<p>Reactor 是利用非阻塞 I&#x2F;O 和 epoll 构建的事件循环模型，是对 epoll 的抽象和封装，使得使用更加便捷，因为对事件分发，使用相应的 handler 来处理事件，非常像核反应堆，所以得名 Reactor。Reactor 的形式有多种多样，本文并不想去详细介绍个中细节，谈及 Reactor 仅仅是想说明：<strong>对于事物的理解，先要从一座森林理解一棵树，然后才能从一棵树理解整座森林。</strong></p>
<p>“<strong>异步编程</strong>”和“<strong>异步</strong>”这两个概念是有所区别的，“<strong>异步</strong>”是一种特性，“<strong>异步编程</strong>”是基于此特性演化出的编程范式。</p>
<p>在编程语言领域，我认为异步编程的终极形态是为上层开发者隐藏异步编程的复杂性，提供同步的编程接口。就像 Go 语言netpoller 那样，底层使用了目前最优秀的非阻塞和 epoll 模型构造的单线程 Reactor，上层为开发者呈现出简洁、直观的同步编程接口。</p>
<h2 id="netpoller"><a href="#netpoller" class="headerlink" title="netpoller"></a>netpoller</h2><p>在进入繁琐的<code>netpoller</code>源码之前，先来切身地体验一下 Go 的网络编程，相信下面的代码对每个 Gopher 来说都不陌生：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := conn.Read(buffer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error reading:&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		data := buffer[:n]</span><br><span class="line">		fmt.Println(<span class="string">&quot;Received data:&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码是使用<code>net</code>包编写的一个简单的网络 Server，其中<code>handleConnection</code>展示了如何读取 socket 中的内容，<code>n, err := conn.Read(buffer)</code>以同步阻塞的方式发出了<code>Read</code>请求，对于开发者来说一个读取操作就这样轻松完成了，简洁到无以复加！内里乾坤甚至是初学者根本不会去想的，这就是 Go 为开发者提供的网络编程接口，复古而优雅。</p>
<p>因为，根本不用担心 goroutine 所在的 M 线程被阻塞！</p>
<p>使用 epoll 进行网络程序的编写，需要三个步骤，分别是 <strong>epoll_create</strong>，<strong>epoll_ctl</strong> 和 <strong>epoll_wait</strong>。这三个 API 基本对应着 epoll 实例创建、增加监听描述符、poll 网络事件这三个动作，接下来我会就这三个动作来剖析一下 netpoller，此处参考 <code>go 1.18</code> 的源代码。</p>
<h3 id="epoll-初始化"><a href="#epoll-初始化" class="headerlink" title="epoll 初始化"></a>epoll 初始化</h3><p>netpoller 创建 epoll 实例的关键代码位于 <code>pollDesc</code> 这个结构体的 <code>init</code> 方法中：</p>
<p><strong>internal&#x2F;poll&#x2F;fd_poll_runtime.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	runtimeCtx <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverInit sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">	serverInit.Do(runtime_pollServerInit)</span><br><span class="line">	ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">	&#125;</span><br><span class="line">	pd.runtimeCtx = ctx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll.pollDesc 是 poll.FD 中的一个字段，poll.FD 表示文件描述符，os 包和 net 包都包含它来组成上层意义的<strong>网络连接</strong>和 <strong>OS 文件</strong>。poll.FD 的 Init 方法会调用 poll.pollDesc.init 来初始化 epoll 实例，初始化函数<code>runtime_pollServerInit</code>是个单例模式，也就是说，epoll 实例会在程序创建第一个文件描述符时被创建。我们看一下<code>runtime_pollServerInit</code>：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	netpollGenericInit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll_runtime_pollServerInit 是一个未导出的方法，此处将其链接成了<code>internal/poll.runtime_pollServerInit</code>，因此可以在 internal&#x2F;poll 包里直接调用。<code>netpollGenericInit</code>调用了<code>netpollinit</code>，<code>netpollinit</code>使用<code>epoll_create</code>来创建 epoll 实例：</p>
<p><strong>runtime&#x2F;netpoll_epoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">	<span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line">		<span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, -epfd)</span><br><span class="line">			throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		closeonexec(epfd)</span><br><span class="line">	&#125;</span><br><span class="line">	r, w, errno := nonblockingPipe()</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;runtime: pipe failed with&quot;</span>, -errno)</span><br><span class="line">		throw(<span class="string">&quot;runtime: pipe failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	ev := epollevent&#123;</span><br><span class="line">		events: _EPOLLIN,</span><br><span class="line">	&#125;</span><br><span class="line">	*(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">	errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, -errno)</span><br><span class="line">		throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	netpollBreakRd = <span class="type">uintptr</span>(r)</span><br><span class="line">	netpollBreakWr = <span class="type">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>epfd</code> 是 epoll 实例的文件描述符，它是一个全局变量，后续会作为 <code>epoll_ctl</code> 和 <code>epoll_wait</code> 系统调用的参数被传入。在创建完 epoll 实例之后，紧接着使用<code>epoll_ctl</code>加入了一个非阻塞的管道描述符，这里主要用于唤醒阻塞在 epoll_wait 上的 poll 线程。</p>
<p>这是可以理解的，毕竟 polling 事件的线程还有其它任务，如果待监听的描述符长时间无事件发生，不可能让线程一直阻塞下去。其实这个线程就是<code>sysmon</code>线程，一个不需要 P 即可运行的操作系统线程，稍后会介绍 <code>sysmon</code> 线程如何 polling 网络事件。</p>
<h3 id="向-epoll-实例注册描述符"><a href="#向-epoll-实例注册描述符" class="headerlink" title="向 epoll 实例注册描述符"></a>向 epoll 实例注册描述符</h3><p>随着 epoll 实例的成功创建，接下来就可以使用<code>epoll_ctl</code>系统调用向其中添加感兴趣的文件描述符了，最终会使用<code>epoll_wait</code>来收取这些网络文件描述符上的网络事件，我们这里主要聚焦于描述符的注册之上。</p>
<p>Go 网络编程中涉及到向 netpoller 注册描述符的行为大致有<code>Listen</code>、<code>Connect</code>、<code>Accept</code>三类，为避免繁琐的代码，此处我以 TCP 为例，仅列出函数调用路径，至 <code>epoll_ctl</code>为止。</p>
<ul>
<li>服务端 Accept 连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.TCPListener</span><br><span class="line">    ---&gt;net.TCPListener.Accept</span><br><span class="line">        ---&gt;net.TCPListener.accept</span><br><span class="line">            ---&gt;net.netFD.accept</span><br><span class="line">                ----&gt;net.netFD.init</span><br><span class="line">                    -----&gt;poll.FD.Init</span><br><span class="line">                        ------&gt;poll.pollDesc.init</span><br><span class="line">                            -------&gt;poll.runtime_pollOpen</span><br><span class="line">                                --------&gt;runtime.netpollopen</span><br><span class="line">                                    ---------&gt;epollctl</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是，net.netFD.accept 调用 poll.FD.Accept， 进而调用 accept4 系统调用，将文件描述符设置为非阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrapper around the accept system call that marks the returned file</span></span><br><span class="line"><span class="comment">// descriptor as nonblocking and close-on-exec.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accept</span><span class="params">(s <span class="type">int</span>)</span></span> (<span class="type">int</span>, syscall.Sockaddr, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	ns, sa, err := Accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, sa, <span class="string">&quot;accept4&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ns, sa, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端监听</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net.ListenTCP</span><br><span class="line">    ---&gt;net.sysListener.listenTCP</span><br><span class="line">        ---&gt;net.internetSocket</span><br><span class="line">            ---&gt;net.socket</span><br><span class="line">                ----&gt;net.netFD.dial</span><br><span class="line">                    -----&gt;net.netFD.init</span><br><span class="line">                        ------&gt;poll.FD.Init</span><br><span class="line">                            -------&gt;poll.pollDesc.init</span><br><span class="line">                                --------&gt;poll.runtime_pollOpen</span><br><span class="line">                                    ---------&gt;runtime.netpollopen</span><br><span class="line">                                        ---------&gt;epollctl</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端拨号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">net.Dial</span><br><span class="line">    ---&gt;net.Dialer.Dial</span><br><span class="line">        ---&gt;net.Dialer.DialContext</span><br><span class="line">            ----&gt;net.sysDialer.dialSerial</span><br><span class="line">                -----&gt;net.sysDialer.dialSingle</span><br><span class="line">                    ------&gt;net.sysDialer.dialTCP</span><br><span class="line">                        -------&gt;net.sysDialer.doDialTCP</span><br><span class="line">                            --------&gt;net.internetSocket</span><br><span class="line">                                ---------&gt;net.socket</span><br><span class="line">                                    ----------&gt;net.netFD.dial</span><br><span class="line">                                        -----------&gt;net.netFD.connect</span><br><span class="line">                                            ------------&gt;poll.FD.Init</span><br><span class="line">                                                -------------&gt;poll.pollDesc.init</span><br><span class="line">                                                    --------------&gt;poll.runtime_pollOpen</span><br><span class="line">                                                        ---------------&gt;runtime.netpollopen</span><br><span class="line">                                                            ----------------&gt;epollctl</span><br></pre></td></tr></table></figure>

<p>三类操作最终都会调用 <code>runtime.netpollopen</code>，此函数会发出<code>epoll_ctl</code>调用，将<code>fd</code>与事件<code>_EPOLLIN、_EPOLLOUT 、_EPOLLRDHUP 、_EPOLLET</code>注册进 epoll 实例，并设置为边缘触发。</p>
<p><strong>runtime&#x2F;netpoll_epoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev epollevent</span><br><span class="line">	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">	<span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9lcG9sbF9jdGwuMi5odG1s">epoll_ctl<i class="fa fa-external-link-alt"></i></span> 有一个参数<code>event</code>，是和文件描述符关联的一个对象，在 go 源码中名为<code>epollevent</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> epollevent <span class="keyword">struct</span> &#123;</span><br><span class="line">	events <span class="type">uint32</span></span><br><span class="line">	data   [<span class="number">8</span>]<span class="type">byte</span> <span class="comment">// unaligned uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>data</code>是用户设置的，kernel 必须保存它并在文件描述符就绪时（通过 epoll_wait 调用）一并返回。此处，<code>ev.data</code>被设置为<code>pollDesc</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br></pre></td></tr></table></figure>

<p>每个网络文件描述符都会对应一个<code>pollDesc</code>，<code>pollDesc</code>是 Network poller descriptor，它控制着文件描述符的状态以及在该文件描述符上产生等待的 goroutine 的地址。</p>
<p>也就是说，当<code>epoll_wait</code>返回时，从就绪的<code>ev.data</code>中可以拿到等待读写的 goroutine 地址，我们接下来将详细剖析这个过程。</p>
<h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p><code>epoll_wait</code>的调用是由函数<code>netpoll</code>发出的，它会检查就绪的文件描述符，并且返回相关的 goroutine 列表，由此可见 netpoller 的事件分发特点：<strong>与 goroutine 紧密结合，将可读写的网络文件描述符转化为可运行的 goroutine，然后注入相关的运行队列，最终由调度器接管并伺机运行。</strong></p>
<p><strong>runtime&#x2F;netpoll_epoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netpoll checks for ready network connections.</span></span><br><span class="line"><span class="comment">// Returns list of goroutines that become runnable.</span></span><br><span class="line"><span class="comment">// delay &lt; 0: blocks indefinitely</span></span><br><span class="line"><span class="comment">// delay == 0: does not block, just polls</span></span><br><span class="line"><span class="comment">// delay &gt; 0: block for up to that many nanoseconds</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> gList &#123;</span><br><span class="line">	<span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">	<span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">		waitms = <span class="number">-1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;</span><br><span class="line">		waitms = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;</span><br><span class="line">		waitms = <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;</span><br><span class="line">		waitms = <span class="type">int32</span>(delay / <span class="number">1e6</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// An arbitrary cap on how long to wait for a timer.</span></span><br><span class="line">		<span class="comment">// 1e9 ms == ~11.5 days.</span></span><br><span class="line">		waitms = <span class="number">1e9</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 准备 epollevent 数组，最多 poll 128个事件</span></span><br><span class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// 发出 epoll_wait 调用</span></span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// toRun 是个 goroutine 链表，表示文件描述符已就绪，可以被调度运行的 goroutine</span></span><br><span class="line">	<span class="keyword">var</span> toRun gList</span><br><span class="line">	<span class="comment">// 遍历本次 epoll_wait 返回的就绪事件</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">		<span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 从 ev.data 中取出 pollDesc</span></span><br><span class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			pd.setEventErr(ev.events == _EPOLLERR)</span><br><span class="line">			<span class="comment">// 获取相关 goroutine 并插入到 toRun 链表</span></span><br><span class="line">			netpollready(&amp;toRun, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netpoll</code> 并不像我们平时看到的 epoll 使用案例那样使用一个死循环来无限地<code>epoll_wait</code>，事实上它只<code>epoll_wait</code>一次，无限循环调用的任务放在了<code>sysmon</code>中，我们稍后会看到，现在将注意力放在如何将事件转化为对应的 goroutine 上。</p>
<p>从代码中可以看出，<code>netpollready</code> 会获取相关 goroutine 并插入到 <strong>toRun</strong> 链表：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netpollready is called by the platform-specific netpoll function.</span></span><br><span class="line"><span class="comment">// It declares that the fd associated with pd is ready for I/O.</span></span><br><span class="line"><span class="comment">// The toRun argument is used to build a list of goroutines to return</span></span><br><span class="line"><span class="comment">// from netpoll. The mode argument is &#x27;r&#x27;, &#x27;w&#x27;, or &#x27;r&#x27;+&#x27;w&#x27; to indicate</span></span><br><span class="line"><span class="comment">// whether the fd is ready for reading or writing or both.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This may run while the world is stopped, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取等待读操作的 g</span></span><br><span class="line">		rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取等待写操作的 g</span></span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 将等待读操作的 g 插入链表</span></span><br><span class="line">		toRun.push(rg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 将等待写操作的 g 插入链表</span></span><br><span class="line">		toRun.push(wg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里交代一下 <strong>pollDesc</strong> 中的 <strong>rg，wg</strong> 字段，这两个字段就是控制描述符状态和相关 goroutine 地址的关键，它的定义如下：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// rg, wg are accessed atomically and hold g pointers.</span></span><br><span class="line">	<span class="comment">// (Using atomic.Uintptr here is similar to using guintptr elsewhere.)</span></span><br><span class="line">	rg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for read or nil</span></span><br><span class="line">	wg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for write or nil</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>rg</strong> 和 <strong>wg</strong> 都是原子类型，里面可能存放的内容为：<strong>pdReady, pdWait, G waiting for read or nil</strong>，<code>G</code> 就是 goroutine 的地址，我们继续沿着调用向下看：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollunblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, ioready <span class="type">bool</span>)</span></span> *g &#123;</span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		old := gpp.Load()</span><br><span class="line">		<span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; !ioready &#123;</span><br><span class="line">			<span class="comment">// Only set pdReady for ioready. runtime_pollWait</span></span><br><span class="line">			<span class="comment">// will check for timeout/cancel before waiting.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> <span class="built_in">new</span> <span class="type">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> ioready &#123;</span><br><span class="line">			<span class="built_in">new</span> = pdReady</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 gpp 设置为 pdReady</span></span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old == pdWait &#123;</span><br><span class="line">				<span class="comment">// 如果设置为0，则 (*g)(unsafe.Pointer(old)) 为 nil</span></span><br><span class="line">				old = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将 old 的值转换为 *g 返回，old 通常就是发生等待的 goroutine 地址</span></span><br><span class="line">			<span class="keyword">return</span> (*g)(unsafe.Pointer(old))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 <code>*g</code> 之后，就可以插入<code>toRun</code>链表了：</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A gList is a list of Gs linked through g.schedlink. A G can only be</span></span><br><span class="line"><span class="comment">// on one gQueue or gList at a time.</span></span><br><span class="line"><span class="keyword">type</span> gList <span class="keyword">struct</span> &#123;</span><br><span class="line">	head guintptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push adds gp to the head of l.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gList)</span></span> push(gp *g) &#123;</span><br><span class="line">	gp.schedlink = l.head</span><br><span class="line">	l.head.set(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toRun</code>是<code>gList</code>类型，<code>gList</code>是一个靠<code>g.schedlink</code>串联起来的单链表。</p>
<p>是时候看看<code>netpoll</code>的调用者如何处理这些 goroutine 链表了，前面说过这个工作是<code>sysmon</code>来完成的，<code>sysmon</code>会在单独的操作系统线程中运行，看一下其创建过程：</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> GOARCH != <span class="string">&quot;wasm&quot;</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sysmon</code>的功能很多，我们这里只看它如何 polling network：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">		lastpoll := <span class="type">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="type">uint64</span>(lastpoll), <span class="type">uint64</span>(now))</span><br><span class="line">			list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">				<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">				<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">				<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">				<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">				<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">				<span class="comment">// and reports deadlock.</span></span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果距离上次 polling 过了 10ms，那么就再次发出 polling，如果结果不为空，则调用 <code>injectglist</code>，而 <code>injectglist</code> 会将结果链表中的 goroutine 的状态修改为<code>runnable</code>后放入本地或全局队列，后面就是调度器接手了，此处不再赘述。</p>
<h3 id="goroutine-的停泊与-pollDesc"><a href="#goroutine-的停泊与-pollDesc" class="headerlink" title="goroutine 的停泊与 pollDesc"></a>goroutine 的停泊与 pollDesc</h3><p>上面介绍了网络事件如何转换为对应的 goroutine ，这个过程依靠的关键是<code>pollDesc</code>中的 rg 和 wg，但是 rg 和 wg 是在何时设置为当前 goroutine 的地址的呢？当 socket 缓冲区未就绪时，一个<code>Read</code>调用将会发生什么呢？</p>
<p>其实，只要稍加思索就会明白，这两个问题极具相关性。Go 中的网络连接是线程安全的，允许多个 goroutine 同时发出读写操作，而 pollDesc 只有一个 rg 和 wg，因此多个 goroutine 读写必定是用锁来串行化的，rg 和 wg 也必然是在读写遭遇阻塞时设置的。事实上，我也正是从这个思路出发，在源码中找到关键所在的。</p>
<p>让我们从一个<code>Read</code>调用开始，看看其内在端倪。</p>
<p>以 TCP 的读取为例，沿着 <code>conn</code> 的 <code>Read</code> 接口调用路径<code>net.netFD.Read---&gt;poll.FD.Read</code>，可以定位到<code>poll.FD.Read</code>:</p>
<p><strong>internal&#x2F;poll&#x2F;fd_unix.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements io.Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := fd.readLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fd.readUnlock()</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fd.IsStream &amp;&amp; <span class="built_in">len</span>(p) &gt; maxRW &#123;</span><br><span class="line">		p = p[:maxRW]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 发出 Read 系统调用</span></span><br><span class="line">		n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			n = <span class="number">0</span></span><br><span class="line">			<span class="comment">// 如果 收到 EAGAIN 错误，且文件描述符是可 poll 的，则进入等待</span></span><br><span class="line">			<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		err = fd.eofError(n, err)</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 socket 缓冲区未就绪，读取一个非阻塞的网络文件描述符时会返回<code>EAGAIN</code>或者<code>EWOULDBLOCK</code>错误，紧接着调用链<code>runtime.pollDesc.waitRead---&gt;runtime.pollDesc.wait---&gt;poll.runtime_pollWait---&gt;runtime.netpollblock</code>会触发调度，将当前 goroutine 换下 CPU，寻找一个新的 goroutine 来运行。</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns true if IO is ready, or false if timedout or closed</span></span><br><span class="line"><span class="comment">// waitio - wait only for completed IO, ignore errors</span></span><br><span class="line"><span class="comment">// Concurrent calls to netpollblock in the same mode are forbidden, as pollDesc</span></span><br><span class="line"><span class="comment">// can hold only a single waiting goroutine for each mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set the gpp semaphore to pdWait</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Consume notification if already ready.</span></span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(pdReady, <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(<span class="number">0</span>, pdWait) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Double check that this isn&#x27;t corrupt; otherwise we&#x27;d loop</span></span><br><span class="line">		<span class="comment">// forever.</span></span><br><span class="line">		<span class="keyword">if</span> v := gpp.Load(); v != pdReady &amp;&amp; v != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;runtime: double wait&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// need to recheck error states after setting gpp to pdWait</span></span><br><span class="line">	<span class="comment">// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl</span></span><br><span class="line">	<span class="comment">// do the opposite: store to closing/rd/wd, publishInfo, load of rg/wg</span></span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError &#123;</span><br><span class="line">		<span class="comment">// 开启 park 流程，休眠当前 goroutine</span></span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// be careful to not lose concurrent pdReady notification</span></span><br><span class="line">	old := gpp.Swap(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: corrupted polldesc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netpollblock</code>会将<code>pollDesc</code>中的 rg 或 wg 设置为<code>pdWait</code>，然后调用<code>gopark</code>将当前 goroutine 休眠，进入<code>schedule</code>流程挑选新的 goroutine 来运行。</p>
<p><code>gopark</code>的调用在一个<code>if</code>判断里，按目前的代码只要<code>netpollcheckerr</code>没有错误发生，就会调用<code>gopark</code>，因此我觉得<code>waitio</code>特别是像为真正的异步 I&#x2F;O 预留的接口，以备向后兼容。</p>
<p>请记住传入<code>gopark</code>的前两个参数：<code>netpollblockcommit</code>和<code>unsafe.Pointer(gpp)</code>，然后再来看<code>gopark</code>中的相关内容：</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Puts the current goroutine into a waiting state and calls unlockf on the</span></span><br><span class="line"><span class="comment">// system stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If unlockf returns false, the goroutine is resumed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// unlockf must not access this G&#x27;s stack, as it may be moved between</span></span><br><span class="line"><span class="comment">// the call to gopark and the call to unlockf.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that because unlockf is called after putting the G into a waiting</span></span><br><span class="line"><span class="comment">// state, the G may have already been readied by the time unlockf is called</span></span><br><span class="line"><span class="comment">// unless there is external synchronization preventing the G from being</span></span><br><span class="line"><span class="comment">// readied. If unlockf returns false, it must guarantee that the G cannot be</span></span><br><span class="line"><span class="comment">// externally readied.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reason explains why the goroutine has been parked. It is displayed in stack</span></span><br><span class="line"><span class="comment">// traces and heap dumps. Reasons should be unique and descriptive. Do not</span></span><br><span class="line"><span class="comment">// re-use reasons, add new ones.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="type">bool</span>, lock unsafe.Pointer, reason waitReason, traceEv <span class="type">byte</span>, traceskip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">		checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时 lock 是 gpp(pollDesc 中的 rg)</span></span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	<span class="comment">// 此时 unlockf 是 netpollblockcommit</span></span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gopark</code>会获取当前所在的<code>m</code>，并将函数<code>netpollblockcommit</code>和<code>unsafe.Pointer(gpp)</code>（<strong>pollDesc</strong> 中的 <strong>rg</strong>）分别赋值给<code>mp.waitlock</code>和<code>mp.waitunlockf</code>，接下来进入<code>mcall(park_m)</code>的调用，<code>mcall</code> 是个汇编函数，它会调用传参中的函数且不再返回，我们看一下<code>mcall</code>的内容，明确一下将要传给函数<code>park_m</code>的参数：</p>
<p><strong>runtime&#x2F;asm_amd64.s</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// func mcall(fn func(*g))</span><br><span class="line">// Switch to m-&gt;g0&#x27;s stack, call fn(g).</span><br><span class="line">// Fn must never return. It should gogo(&amp;g-&gt;sched)</span><br><span class="line">// to keep running g.</span><br><span class="line">TEXT runtime·mcall&lt;ABIInternal&gt;(SB), NOSPLIT, $0-8</span><br><span class="line">	MOVQ	AX, DX	// DX = fn</span><br><span class="line"></span><br><span class="line">	// save state in g-&gt;sched</span><br><span class="line">	// 下面这 5 行指令是保存当前 goroutine 的状态到 g-&gt;sched </span><br><span class="line">	MOVQ	0(SP), BX	// caller&#x27;s PC</span><br><span class="line">	MOVQ	BX, (g_sched+gobuf_pc)(R14)</span><br><span class="line">	LEAQ	fn+0(FP), BX	// caller&#x27;s SP</span><br><span class="line">	MOVQ	BX, (g_sched+gobuf_sp)(R14)</span><br><span class="line">	MOVQ	BP, (g_sched+gobuf_bp)(R14)</span><br><span class="line"></span><br><span class="line">	// switch to m-&gt;g0 &amp; its stack, call fn</span><br><span class="line">	// 准备切换到 g0 及其堆栈</span><br><span class="line">	MOVQ	g_m(R14), BX    // 通过 R14 拿到当前的 m</span><br><span class="line">	MOVQ	m_g0(BX), SI	// SI = g.m.g0 通过 m 拿到 m 的 g0</span><br><span class="line">	CMPQ	SI, R14	// if g == m-&gt;g0 call badmcall</span><br><span class="line">	JNE	goodm</span><br><span class="line">	JMP	runtime·badmcall(SB)</span><br><span class="line">goodm:</span><br><span class="line">	MOVQ	R14, AX		// AX (and arg 0) = g 把当前 goroutine 地址放入 AX</span><br><span class="line">	MOVQ	SI, R14		// g = g.m.g0  SI 是 g.m.g0，这一句将 goroutine 切换到 g0</span><br><span class="line">	get_tls(CX)		// Set G in TLS</span><br><span class="line">	MOVQ	R14, g(CX)  // 设置 g0 到线程本地存储</span><br><span class="line">	MOVQ	(g_sched+gobuf_sp)(R14), SP	// sp = g0.sched.sp 切换到 g0 堆栈</span><br><span class="line">	PUSHQ	AX	// open up space for fn&#x27;s arg spill slot</span><br><span class="line">	MOVQ	0(DX), R12</span><br><span class="line">	CALL	R12		// fn(g)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	JMP	runtime·badmcall2(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p>根据<span class="exturl" data-url="aHR0cHM6Ly9nby5nb29nbGVzb3VyY2UuY29tL2dvLysvcmVmcy9oZWFkcy9kZXYucmVnYWJpL3NyYy9jbWQvY29tcGlsZS9pbnRlcm5hbC1hYmkubWQ=">Go internal ABI specification<i class="fa fa-external-link-alt"></i></span>的描述，<code>amd64</code>平台下整型参数传递依次使用如下寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAX, RBX, RCX, RDI, RSI, R8, R9, R10, R11</span><br></pre></td></tr></table></figure>

<p>这里有一个知识点：<strong>R14 寄存器存放当前 goroutine 的地址</strong>，可以从汇编代码中看到<code>mcall</code>是如何利用 R14 寄存器切换到 g0 的。</p>
<p><code>mcall</code>的主要工作就是保存当前 goroutine 的状态，切换到 g0 堆栈并执行传入的函数<code>fn</code>，这里即将执行<code>park_m</code>。</p>
<p><code>MOVQ	R14, AX		// AX (and arg 0) = g</code>这一句将当前 g 的地址存入 AX 寄存器，并在接下来<code>CALL	R12		// fn(g)</code>的时候，充当第一个参数。</p>
<p>接下来进入<code>park_m</code>:</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// park continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 调用 netpollblockcommit</span></span><br><span class="line">		ok := fn(gp, _g_.m.waitlock)</span><br><span class="line">		_g_.m.waitunlockf = <span class="literal">nil</span></span><br><span class="line">		_g_.m.waitlock = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			execute(gp, <span class="literal">true</span>) <span class="comment">// Schedule it back, never returns.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 进入调度循环，不再返回</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，参数<code>gp</code>是发出<code>Read</code>系统调用的 goroutine 地址，在进入<code>schedule()</code>调度循环之前，我们仅关注<code>ok := fn(gp, _g_.m.waitlock)</code>这一句，<code>gopark</code>函数已经将<code>netpollblockcommit</code>和<code>unsafe.Pointer(gpp)</code>（pollDesc 中的 rg）分别赋给了<code>mp.waitlock</code>和<code>mp.waitunlockf</code>，所以这里的调用实际上是<code>netpollblockcommit(gp, unsafe.Pointer(gpp))</code>。</p>
<p>不知道你有没有好奇，挂起的明明是当前的 goroutine，为什么函数的名字是<code>park_m</code>呢？这里的<code>m</code>显然就是 GMP 中的线程 M 啊，我是这样理解的：M 就像是一列高速运行的汽车，乘客是<code>goroutine</code>，当某个乘客因某些原因不能继续乘坐时，M 需要停下来让乘客下车，然后再开动去寻找下一位乘客，所以这个挂起 goroutine 的过程就像是 M 停泊了一样。</p>
<p>但为了叙述方便，我还是称 goroutine 停泊好了，毕竟比喻并不十分恰当，从指令角度看 M 可是一路狂奔从未停过，只是从代码所有权角度来看， M 确实是换了一位乘客。</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	r := atomic.Casuintptr((*<span class="type">uintptr</span>)(gpp), pdWait, <span class="type">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line">	<span class="keyword">if</span> r &#123;</span><br><span class="line">		<span class="comment">// Bump the count of goroutines waiting for the poller.</span></span><br><span class="line">		<span class="comment">// The scheduler uses this to decide whether to block</span></span><br><span class="line">		<span class="comment">// waiting for the poller if there is nothing else to do.</span></span><br><span class="line">		atomic.Xadd(&amp;netpollWaiters, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>atomic.Casuintptr((*uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))</code>将<code>rg</code>的值更新为<strong>发出<code>Read 调用的 goroutine</code>地址</strong>。</p>
<p>至此，两件重要的事情已经完成：</p>
<ol>
<li>休眠发出<code>Read</code> 调用的 goroutine。</li>
<li>设置与该<code>goroutine</code>感兴趣的文件描述符相关的<code>pollDesc.rg</code>为该 <code>goroutine</code> 的地址，以便后续<code>polling</code>时促成网络事件向<code>goroutine</code>链表的转化。</li>
</ol>
<p>这种模型的好处是非常节省 M，M 在 Go 的 GMP 并发模型中代表操作系统线程，因为网络 I&#x2F;O 非阻塞的特性，M 会从系统调用中立即返回，不会因为数据未就绪而被内核剥离 CPU，M 当然就可以挂起当前 goroutine，转而去寻找其它的 goroutine 来运行。</p>
<p>反观文件 I&#x2F;O 则不然，文件 I&#x2F;O 没有异步和非阻塞特性（不考虑臭名昭著的AIO），当 M 因为系统调用陷入内核时，如果要读取的内容不在页高速缓存中，就会触发缺页处理，内核需要向磁盘发出 I&#x2F;O 请求，因为这个过程不是异步的，内核会将 M 剥离，调度其它线程来运行。可想而知，此时此刻 go runtime 只能新建 M 来匹配 P，新建的 M 需要加入内核运行队列，等待内核调度，经过这样一番折腾，吞吐自然就下来了。</p>
<p>更可怕的是如果有大量 I&#x2F;O 请求，势必会让更多的 M 陷入内核无法自拔，go runtime 除了创建更多的 M 之外别无良策，在这种情况下仍不断地创建 M 无异于扬汤止沸，如果 M 的数量超过 1 万，程序就 panic 了。</p>
<p>所以，<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZVhSQnowbEFIQW9kWFc5TlZsaXlPZw==">go 并不适合文件 io 密集型任务<i class="fa fa-external-link-alt"></i></span>，除非有真正的异步 I&#x2F;O，使得文件也可以享用 Reactor 的好处。</p>
<p>本质上， netpoller 使用非阻塞I&#x2F;O和<code>epoll</code>模型构建的是一个单线程的<code>Reactor</code>，即便如此，也已经可以满足绝大多数的场景需求，可以说这套模型是 Linux 平台的最佳、最高效的解决方案。然而实在是拗不过<strong>非阻塞I&#x2F;O 和 epoll</strong>这对组合有一些不那么“同步”的特性，以讹传讹间，不少不明就里的人就把这种模型称为异步 I&#x2F;O 了。</p>
<p>直到 2019 年 <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmcucGRm">io_uring<i class="fa fa-external-link-alt"></i></span> 横空出世，Linux 异步世界才终于迎来了一丝曙光！</p>
<h2 id="下一代异步-I-O"><a href="#下一代异步-I-O" class="headerlink" title="下一代异步 I&#x2F;O"></a>下一代异步 I&#x2F;O</h2><p>io_uring 由 Jens Axboe 提出和实现，并于 2019 年 5 月随 Linux 5.1 发布。io_uring 是 Linux 内核引入的新型异步 I&#x2F;O 框架，旨在改善 AIO 的性能和可扩展性，社区称<strong>“io_uring can change everything”</strong>。本文不准备对其做过多介绍，感兴趣的朋友可以参考 <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmcucGRm">Efficient IO with io_uring<i class="fa fa-external-link-alt"></i></span> 这篇文章。这里仅从系统调用的角度来谈一谈 io_uring 可能为上层带来的变化。</p>
<ul>
<li><p>网络 I&#x2F;O</p>
<p>以非阻塞 I&#x2F;O 和<code>epoll</code>为蓝本的 Reactor 在收到网络事件之后，仍然需要主动发起一次系统调用去读取 socket 的内容，在 io_uring 下就没有这一步系统调用了，当等待者被唤醒以后，数据就已经在手边了。不过，要适配 io_uring 还需要不少工作要做，比如 go 的 netpoller 就需要对 runtime 做改造适配，当然适配完成后的网络模型就不是 Reactor 了，而是 Proactor，当然了，叫什么并不重要，重要的是它怎么干这件事。</p>
</li>
<li><p>文件 I&#x2F;O</p>
<p>前面讨论过，Reactor 并不能拯救文件 I&#x2F;O，Go 运行时甚至会出现“卡线程”的情况。但是，io_uring 完美解决了这一痛点，不像它的前任 AIO 每次追加请求以及获取结果都要发起一次系统调用，io_uring 实现了用户空间和内核空间的内存无锁共享，很多很多的系统调用被节省了，所有 I&#x2F;O 全都可以交给专门的线程负责，这就是 Proactor。</p>
<p>如果 Go runtime 适配了 io_uring 会怎样？届时意味着“卡线程”成为历史，Go 不仅适合网络密集型I&#x2F;O，也会适合文件密集型I&#x2F;O 。</p>
</li>
</ul>
<p>事实上，Go 社区已经在讨论适配的可能性了（见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMzE5MDg=">#31908<i class="fa fa-external-link-alt"></i></span>），进展算不上快，但未来可期！</p>
<h2 id="再论异步编程模型"><a href="#再论异步编程模型" class="headerlink" title="再论异步编程模型"></a>再论异步编程模型</h2><p>直接进行异步编程是复杂且困难的，你需要设计专门的模块统一处理 I&#x2F;O 请求，并且具备唤醒机制，即便这些问题得到了完美解决，你也会发现你创造了另一个 Reactor 或者 Proactor。但如果不做这些，异步就无法发挥作用。试想一下，一个任务发出异步请求之后，请求立即返回了，那么任务本身该何去何从呢？没有 I&#x2F;O 的结果 任务就无法推进，这个时候就要有将任务 Park 的能力了。</p>
<p>由此可见，异步编程其实是考验并发模型的，也就是分解任务的能力，如果一门编程语言只能以线程来分解任务，那么使用异步的代价就会增加，这个问题的解决方案就是协程，如果编程语言实现了协程，那么任务分解的粒度变为协程，则更能有效的利用异步 I&#x2F;O 带来的优势。</p>
<p>Go 就是这种玩法，非阻塞和异步都可以拿来和协程相配合，思路非常容易理解。Rust 的异步运行时也有协程的概念，走的是状态机路线（<a href="https://liupzmin.com/2023/06/08/network/talk-rust-async-netio-with-chatgpt/">对话 ChatGPT 理解 Rust 异步网络 io</a>），属于另外一种玩法，很难说孰优孰劣。Go 使用有栈协程，调度原理很好理解，编程接口简单直接，缺点是<code>goroutine</code>数量过多会有隐患；Rust 使用无栈协程，利用状态机实现协程切换，好处是节省了不少指令，理论上有性能优势，缺点是接口太过晦涩。</p>
<p>可见，<strong>trade-off</strong> 无处不在！</p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80MTE4NTc4Lw==">UNIX网络编程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">Linux&#x2F;UNIX系统编程手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDMyNzAxP3RhYj1jYXRhbG9n">网络编程实战<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDg0MzAx">Redis 源码剖析与实战<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmcucGRm">Efficient IO with io_uring<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzc3NjcwMy8=">Ringing in a new asynchronous I&#x2F;O API<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzgxMDQxNC8=">The rapid growth of io_uring<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmctd2hhdHNuZXcucGRm">What’s new with io_uring<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLm1hdHRlcm1vc3QuY29tL2Jsb2cvaGFuZHMtb24taW91cmluZy1nby8=">Getting Hands on with io_uring using Go<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMzE5MDg=">#31908<i class="fa fa-external-link-alt"></i></span></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/golang-network-netpoller-synchronous-asynchronous/" rel="tag"># golang - network - netpoller - synchronous/asynchronous</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/08/network/talk-rust-async-netio-with-chatgpt/" rel="prev" title="对话 ChatGPT 理解 Rust 异步网络 io">
                  <i class="fa fa-chevron-left"></i> 对话 ChatGPT 理解 Rust 异步网络 io
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/08/golang/a-little-thought-of-concurrency/" rel="next" title="关于并发的一点思考">
                  关于并发的一点思考 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"liupzmin","repo":"liupzmin.github.io","client_id":"77654195445087c01c56","client_secret":"eda09eecd05b86f0ef995d8067ec751abeb753d9","admin_user":"liupzmin","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","ClientID":"ae0756501dfc5de89d35","ClientSecret":"26befb359f7a466031bb96b4b7e0715c41c63fb8","owner":"liupzmin","adminUser":"['liupzmin']","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","createIssueManually":true,"distractionFreeMode":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d3d341e5788b1c64b8717797568eca52"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
