<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liupzmin.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="左手人文 | 右手科技">
<meta property="og:type" content="website">
<meta property="og:title" content="兔子先生">
<meta property="og:url" content="http://liupzmin.com/index.html">
<meta property="og:site_name" content="兔子先生">
<meta property="og:description" content="左手人文 | 右手科技">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="巴流">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://liupzmin.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>兔子先生 - 探寻计算机的历史与哲学密码</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="兔子先生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">兔子先生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探寻计算机的历史与哲学密码</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">63</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="巴流"
      src="/images/gzh.jpg">
  <p class="site-author-name" itemprop="name">巴流</p>
  <div class="site-description" itemprop="description">左手人文 | 右手科技</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liupzmin"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdXB6bWluQGdtYWlsLmNvbQ==" title="E-Mail → mailto:liupzmin@gmail.com"><i class="envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2024/07/27/essay/rabbit-and-conjuror/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/27/essay/rabbit-and-conjuror/" class="post-title-link" itemprop="url">白兔与魔法师</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-27 10:17:59" itemprop="dateCreated datePublished" datetime="2024-07-27T10:17:59+08:00">2024-07-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li></li>
</ol>
<p>乔斯坦·贾德在他的哲学启蒙著作《苏菲的世界》中有过一个很形象的比喻：<strong>我们的世界就像是魔法师从礼帽中变出的一只白兔，白兔就像是整个宇宙，而我们人类则是寄居在兔子皮毛深处的微生物。而哲学家总是试图沿着兔子的细毛往上爬，想努力看清魔法师的脸。</strong></p>
<p>他说我们与小白兔之间唯一的不同是：小白兔并不明白它本身参与了一场魔术表演，我们则相反。我们觉得自己是某种神秘事物的一部分，我们想了解其中的奥秘。</p>
<p>两千多年前，一位古希腊哲学家认为，哲学之所以产生，是因为人有好奇心的缘故。当一切基本需求都满足之后，仍然还有些东西是每个人都需要的。“我们是谁？” “世界从何而来？” 没有一种文化不关心这样的问题。</p>
<p>书中用发人深省的文字如是写道：</p>
<blockquote>
<p>这世界就像魔术师从他的帽子里拉出的一只白兔。只是这白兔的体积极其庞大，因此这场戏法要数十亿年才变得出来。所有的生物都出生于这只兔子的细毛顶端，他们刚开始对于这场令人不可置信的戏法都感到惊奇。然而当他们年纪愈长，也就愈深入兔子的皮毛，并且待了下来。他们在那儿觉得非常安适，因此不愿意再冒险爬回脆弱的兔毛顶端。唯有哲学家才会踏上此一危险的旅程，迈向语言与存在所能达到的顶峰。其中有些人掉了下来，但也有些人死命攀住兔毛不放，并对那些窝在舒适柔软的兔毛深处、尽情吃喝的人们大声吼叫。</p>
</blockquote>
<p>《苏菲的世界》是写给青少年的哲学入门读物，但在三十多岁的我读来，满满都是自己的心路历程。白兔与魔法师的比喻真可以当作我思想嬗变的注脚，我人生的前三十年几乎可以说是空白的，直到如今才有了些许字迹。</p>
<p>大约是二十八岁的时候，我在思想上产生了不小的变化，这个过程并非一蹴而就，而是一个缓慢发酵的过程。要阐明我变成了怎样的人，就需要先说明我原本是怎样的人。</p>
<p>我是个木讷内向的人，寡言少语，兼具些许社恐。这其实不足为怪，因为很多人都是如此，但我最大的问题在于：太习惯这个世界！我对所经历的种种，没有一丝一毫的批判精神和思考精神，如果某件事第一次进入我的视线，我根本不会有任何怀疑倾向。</p>
<p>我对身边的一切天生具有一种漠然接受的态度，对任何事物都不感到好奇，对任何事物都没有自己的看法，别人如何做，我便如何做，全然不想为什么要这么做，别人告诉我是什么，我就当做什么，全然不思考为什么。像我这样的人，休谟看了肯定会大摇其头的。学生时代，我没想过一些书本之外的事，诸如某一历史人物、历史事件、某个概念等等，根本没有额外的想要去丰富课堂所学的想法，我对书上的知识，坦然受之。如今看一些东西，尤其涉及到旧有的知识点时，我很惊恐地发现，我就像刚刚认识它们一样。甚至亲身经历过的事，我好像也没有特殊的印象，比如香港回归，申奥成功等等，这些按理来说都是我亲历的时代大事件，却没有在我内心留下太多深刻的记忆。</p>
<p>我依然记得，一位挚友在回忆当年中国申奥成功的盛况时，曾这样写道：“当‘北京’两个字在萨马兰奇的口中说出时，我沸腾了，整个班级都沸腾了，我激动地将课本抛向空中，却不料它在落下时砸中了一位女同学的头……”</p>
<p>我很羡慕这种身临其境、历久弥新的回忆，这是我一直不曾有过的。我漠然接受的一切，多年之后，只丢给我一个模糊的背影，有一些甚至连背影都没有。</p>
<p>尤其糟糕的是，这种态度让我在待人接物方面表现得很难堪，有时候近乎冷漠。小的时候尚且可以用年幼无知的理由来搪塞，成年之后，那些儿时的借口便自然而然地失去了合理性，新手庇护期也就这样离我远去了。而我在为人处世方面很难做到有礼有节，在与人交谈中，有时候因思索过慢而错过了讲话的时机，索性也就不回答了；有时想好的话讲出来，却完全不是自己想要的效果；有时候对别人的发问，表现得如同条件反射一般，话一出口就懊悔不跌，仿佛那一瞬间原始的性格冲动占据着大脑，理性反而退居二线。我甚至觉得我与《局外人》的主人公默尔索有些相像，他的特点就是冷漠，对身边的一切漠不关心。这当然只是某种程度上的相似，事实上我只是不善于交际，且不会伪装自己，或者可以说，我是个真诚的人。而这必然会与周遭的环境格格不入，势必又会养成一份敏感的内心，所以我一直有一个附庸风雅、沽名钓誉的爱好：诗词！</p>
<p>我摘引两首我写过的诗词：</p>
<blockquote>
<p>应天长<br>时年细数，万颗红珍，抚叹华年流去。彼时秦门初遇，正盈盈细雨。算而今，载余过，更笑那、岁月无居。此犹记、当年游冶，不胜唏嘘。<br>长慨来日时，云烟飞絮，折煞黄金缕。忘于江湖路远，不忆神伤语。此一句，彼一句。听刘郎、笙歌几曲。且祝君、黄金榜上，杯酌饮去。</p>
<p>春归<br>繁花已尽无长期，绿欺山头几星移。<br>易解梅花寒放日，难忆少年苦读时。<br>道原忘食不得闲，老泉发愤犹未迟。<br>劝君须臾更惜取，莫道流水不能西。</p>
</blockquote>
<p>我那时对自己的大学专业完全提不起兴趣，只爱做这些悲春伤秋、感时伤世的句子，然而现在看来，都不过是贻笑大方而已，也许唬得住一两个人，但在稍具格律常识的人看来，全都是些不学无术之作。如果我那个时候能深入了解一下 100 年前的新文化运动，切身地体会一下当时的知识分子为推广白话的文学革命所做的种种努力，以及他们用现代文明的眼光对中国古代文化重新审视的历史，大概率我会改变崇古的文学趣味。毕竟鲁迅曾咬牙切齿地呐喊：“只要对于白话来加以谋害者，都应该灭亡！”</p>
<p>这大略就是我高中和大学时代兴趣爱好之所在，我实在耻于用“浸淫”这个词，因为当时虽有兴趣，却不曾真的从内心觉悟，并未意识到要为这兴趣做些刻苦的研究与努力，不曾为这兴趣多流些汗水，甚至连几本书也不曾多读。如今回首往事，青春也只是几篇为赋新词强说愁并且狗屁不通的诗词文章罢了！</p>
<ol start="2">
<li></li>
</ol>
<p>性格和兴趣爱好大抵如上所述，但这一切却从我二十八岁开始，渐渐地发生了翻天覆地的变化。其实性格已很难改变，主要是思想观念蜕变了，相应地兴趣爱好也为之一变。简言之，我对很多事物产生了哲学三问，“我是谁？我来自哪里？我将往何处去？” 我重新认识身边的一切，此后看事情便不同了。</p>
<p>这样说很抽象，我试举几个例子，就可见出我的变化了：</p>
<ul>
<li>《红楼梦》在我心目中的位置提高了。在四大名著的排行中，由最末位升到第一位。</li>
<li>我开始爱好哲学了。学生时代我是很讨厌政治和马克思哲学课的。</li>
<li>兴趣爱好从诗词歌赋，渐渐转移到历史、哲学、政治、社会学上去了。</li>
<li>开始喜欢中国近代史。确切一点说，是中国近代思想史，提起近代史，总是和屈辱联系在一起的，所以面对民族创伤，我总是敬而远之。但“西学东渐”引起了千年未有之大变局，中国的高级知识分子开始睁眼看世界，开始以新的标准尺度衡量中国传统文化思想，这是一个中西思想大碰撞的时代，其激烈程度是空前的。</li>
<li>开始对计算机专业产生了发自内心的热爱。</li>
</ul>
<p>二十八岁以前，要对一个涵咏在“骏马秋风冀北”与“杏花春雨江南”中的人说：<strong>哲学会成为你的爱好，政治、历史、社会学会成为你最爱的阅读领域</strong>。我相信他绝对会嗤之以鼻，并表示出绝对的自信与不屑。没错，我之所以说这是思想上的巨变，就是因为以前的我绝对不会承认现在的我。</p>
<p>那么，这种转变究竟何以开始的呢？</p>
<p>起因要追溯到我对“人生意义”的寻求上。这个原因看起来实在平平无奇，要说哪个青年没发出过对“人生的意义”的灵魂叩问，那么他绝对算不上是一个现代青年。上个世纪80年代的中国曾经掀起过一阵“萨特热”，当时的青年普遍关注“我为什么活着”、“人生的意义”这种特别令人迷惘的问题，裹挟着萨特哲学的西方文学也深深影响了80年代中国的文学青年。显然，追寻“人生的意义”并不是一件时髦的事儿，反而听上去有些陈词滥调。但是，这一次我没有停留在普通文青毫无意义的牢骚上，我竟然真的花心思去想了，原因完全是出于对时间和空间的无法释怀上，出于对人生既然相聚又难免分离的唏嘘不已上，这大部分要归因于我多愁善感的性格。</p>
<p>我少小离家，负笈于外地，工作后也远离故乡，天然就会对 “从此故乡只有冬夏，再无春秋” 这样的句子感同身受，也就很容易将思想引向“人生的意义”这种带有哲学意味的问题上去。要解答这个问题说来也容易，我们初中就接触到了其中一种答案，那是奥斯托洛夫斯基在《钢铁是怎样练成的》一书中写就的著名段落：</p>
<blockquote>
<p>人最宝贵的是生命。生命对于每个人只有一次，人的一生应该这样度过：当回忆往事的时候，他不会因为虚度年华而悔恨，也不会因为碌碌无为而羞愧；在临死的时候，他能够说：“我的生命和全部精力都献给了世界上最壮丽的事业——为人类的解放事业而斗争。</p>
</blockquote>
<p>这是一种积极进取的人生态度，给生命赋予了无限的神圣使命，对苦难甘之如饴，我想这应该是每个人都能认同且可以奉为圭臬，拿来当做人生信条的。但答案并不只有这一种，答案可以有很多。如果拿这个问题去问胡适，他会说：“生命本没有意义，你要能给他什么意义，他就有什么意义。与其终日冥想人生有何意义，不如试用此生做点有意义的事。” 如果去问颜回，他会用行为给出君子忧道不忧贫的回答：“一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。”如果去问犬儒哲学家第欧根尼，他会高呼：“像狗一样活着！”</p>
<p>我当时还想不到这么多，脑海里就只有保尔柯察金一个答案，但这个被塞进脑子里的答案是那么单薄，让我觉得这实在是来得太容易了。作为学生，我们都有过对老师和家长的谆谆教诲充耳不闻的经历，而最后真正能成为自己内心的知识，则或多或少都是自己冥思苦想得来的，或者是自己亲身体会到的，所谓“初听不识曲中意，再听已是曲中人”是也。孔子也说过“不愤不启，不悱不发”这样的话。也就是说，真正的智慧都来自内心，而保尔柯察金只是我少年时代被灌输进去的一种知识，让我诧异的是，成年后它居然还奇迹般地停留在我的脑海里。</p>
<p>后来，我看到一本叫做《一片叶子落下来》的儿童绘本，作者以树叶的视角向孩子们讲述生命和死亡的意义，其中最精彩的部分，我摘录在此：</p>
<blockquote>
<p>“我们死了会到哪儿去呢？”<br>“没有人知道，这是个大秘密！”<br>“春天的时候，我们会回来吗？”<br>“我们可能不会再回来了，但是生命会回来。”<br>“那么这一切有什么意思呢？” 弗雷迪继续问。<br>“如果我们反正是要掉落、死亡，那为什么还要来这里呢？”<br>丹尼尔用他那“本来就是这样”的一贯口吻回答，“是为了太阳和月亮，是为了大家一起的快乐时光，是为了树荫、老人和小孩子，是为了秋天的色彩，是为了四季，这些还不够吗？”</p>
</blockquote>
<p>虽然是写给孩子的绘本，但却意外拥有不错的文学性，虽不如保尔的话那样激情澎湃，却恬淡中饱含睿智，读来直指人心，以至于让我玩味了许久。我当时并没有意识到这段话跟《红楼梦》的主旨也有几分贴合，只是觉得它美的像诗。</p>
<p>诗可以遣怀，却无法解忧，我不禁发出了一句龙场的追问：“圣人处此，更有何道？”</p>
<p>我这样讲并不是有意要引出王阳明，事实上我当时还没有意识到圣人是何物，也并未意识到圣人之言会是解决我烦恼的一把钥匙，虽然这个过程中确实有王阳明的影子，但我并不是突然就走进去的。我在冥思苦想无果后，走上了另一条路：<strong>了却遗憾！</strong>我选定的第一件，后来看也是唯一的一件事：<strong>读以前未读完的书！</strong></p>
<p>当时读过的为数不多的书中，有很大一部分是半途而废的，有文学、通俗小说、历史读物等等。于是我暗自较劲，要将这些遗憾一扫而空，这些书单当中就有当年明月的《明朝那些事儿》。</p>
<p>《明朝》是我大学时读的书，但因当时只能借到其中一部分，读完之后也就作罢了。从这件事也看出了我当时得过且过、浑浑噩噩的心态，没有一点儿要找书读书的心思。不过书中写王守仁的部分给当时愚昧的我留下了不可磨灭的印象，这自然要归功于当年明月不遗余力地大肆吹捧。我当时脑中的圣人除了孔孟，几乎想不到别人，对朱熹、二程的地位也没有丝毫认识。所以，当再次读到王守仁经天纬地、震古烁今的事迹之后，我终于按捺不住了：<strong>这样一号大人物，为什么我以前从没听过？</strong></p>
<p>我清楚地记得，我当时没有去搜维基百科或者百度百科（后来看维基百科成为我快速扫盲的方式），而是购入了四部书——《传习录》、《传习录注疏》、《王文成公全集》、《阳明学述要》。然后郑重其事地作了一片名为《从此心向光明之学，做一个王学门人》的文章以彰显心志。不过很惭愧，这四部书我目前也只看完了一部半。</p>
<p>钱穆先生的《阳明学述要》很薄，是优先读完的，简体译注版《传习录》却只读了一半。读过一部分内容之后，我大体有两个感受：一是有相当多的内容读不太懂，二是感觉大部分都是修身养性的哲学。</p>
<p>读不太懂是很正常的，毕竟我是个现代人，缺乏相关的背景知识，这无可厚非。后来辗转了解到，要想看懂书中的讨论和主张，必须清楚王阳明继承的什么，反对的是什么。王阳明的思想属于儒家阵营，反对同属于儒家阵营的朱熹。不难想见，“儒家”这个词在我脑海中一样是一片虚无。我本应像从前一样就此止步、放弃了事的，然而并没有，我在钱穆先生的书中读到了浓浓的人生哲学的味道，这与我思索已久的“人生的意义”有着很奇妙的呼应。于是，我马不停蹄地又看了几本钱穆先生的书，同时粗略读完了《四书》中的《大学》和《中庸》，又一鼓作气读完了冯友兰的《中国哲学简史》。</p>
<p>思想的源流一旦打开，就会变得周流无碍。那一刻，我意识到一件事：<strong>在思想一途，历史上的哲人已经将边界拓展到了足够广袤，只是我们生于其中而不自知。</strong>换句话说，你思考的任何人生问题，极大概率上已经有人思考过了，只等你耐心去发现。于是，我开始沿着兔子的细毛向上攀登了。</p>
<p>思想的接力就如同互联网上的爬虫一样求索无涯，远远没有停止。在此过程中，哲学、历史、社会学、经济学、文学等领域的书籍陆陆续续加入到我的阅读清单中，它们或在我的电子书中，或在我的书架上，林林总总共计四百余部。其中对我影响最大的是熊逸的书，他的书多论而少证，往往不避絮繁，带领你在思想的小径上左冲右突，时常就某一问题援引古今中外的不同观点，使其交火碰撞，或相融，或相斥，勾连万端；他的书没有学者的谆谆习气，不会正襟危坐地施加道德训诫，而是沿着逻辑链条理性地提出各种问题，并试图解答，而答案往往不止一种。可想而知，这正迎合了我彼时的阅读趣味，我正唯恐眼界不够高，阅读不够广，思想不够深，答案不够多呢。不出意外，我渐次读完了他绝大部分的著作，仍感到意犹未尽。在此期间，许多旧有的认知被颠覆，变得支离破碎；新的认知与观念不断形成，有时新认知又会在短时间内变成旧认知，被再次打破。</p>
<p>如果说我之前的探索开启了人生的思想启蒙运动的话，那么思想体系的建立就是在这破与立之间完成的。我从此知“世界何以为世界”，“历史何以为历史”，“我何以为我”，而王阳明似乎已经不再重要了，他已化作我思想坐标系中的一个点，再也不是之前悬浮的状态了。这场由灵魂追问引发的思想震颤铸就了我对世界的好奇心，让我极力地抓住兔子的细毛想要看清魔法师的脸，而震荡的余波到现在依然没有停歇，而且天高海阔，无远弗届，虽穷山距海，不能限也！</p>
<ol start="3">
<li></li>
</ol>
<p>我渐渐形成的好奇心不出意外地影响到了我从事的专业。</p>
<p>我是学计算机出身，但选择计算机专业的原因却很草率，仅仅是觉得电脑游戏好玩，也很自然地被现实打了脸。大学期间，我对计算机枯燥的课程完全提不起兴趣，仍旧徜徉于自己浮浅的精神世界里。</p>
<p>工作以后，我没有停止学习，但也仅仅是以实用为目的浅尝辄止，只为了解决工作中遇到的问题。几年后我迎来了思想蜕变的时刻，我的好奇心让我在计算机领域也产生了哲学三问，对于一种技术：“它是什么？它有着怎么样的历史？它未来会如何发展？”</p>
<p>思想驱动了行为，这个过程中我重温了大学里的计算机课程，同时也明白了大学何以要教这些枯燥的课程，最重要的是，我亲自为自己建立了计算机的世界观，亲手描摹出了计算机的坐标系。</p>
<p>我还有一个意外的感触：我越深入，就越能感受到计算机科学的魅力，我觉得它有时候美的像诗一样。这个世界诗与文章已经很美了，但有一些美需要你更加努力才能发现。这有些违反直觉，在我们刻板印象中计算机和数学一样，需要以强大的理性来对待，而艺术和一切美的东西都是感性的、疯狂的，甚至是幼稚的。但如果我们细心去了解一下的话，直觉往往都会被颠覆。</p>
<p>古希腊的伟大学者毕达哥拉斯不但是西方数学的始祖，同时也是西方音乐的始祖，他正是从竖琴的音色里得出了数学上一个又一个的创见；肖邦，这位以诗人气质著称于世的钢琴家，研究出了作曲的数学公式，他会根据公式而非感情来创作，创作出一串又一串使人浑然不觉生硬的数字，而那些数字就是引发灵魂震颤的乐章；巴赫，复调音乐的宗师巨匠，同样是在以精确的数学指导着精确的旋律对位。在古代西方世界里，艺术家们对数学的迷恋简直近乎迷信。画家也不例外，他们正是出于对几何学的深入研究才发明了独到的透视画法。</p>
<p>可见理性和美并不是完全对立的，计算机也可以产生艺术之美。但计算机的世界烟坡浩渺，横无际涯，是如此的汪洋恣肆，纷繁复杂。作为人类中的一个微不足道的个体，说它“累世不能通其学，当年不能究其礼”一点都不夸张。对于读书学习，苏轼曾经说过：“书富如入海，百货皆有，人之精力，不能兼收并取，但得其所欲求者尔。” 于是，走进计算机图书汪洋中的我，并没有去翻那些烫金的精装本，而是拿起了落满灰尘的线装书，因此我自称为“计算机故纸堆漫游者”，也仅仅是“但得其所欲求者尔”。</p>
<p>从离开校园到对计算机产生由衷的热爱，我花了 5 年的时间，此后又花了多年才让自己变成毕业时该有的样子。我曾经这样勉励自己：“<strong>我希望我35岁时能比肩25岁优秀的人，40岁时能比肩35岁优秀的人，45岁时能追上那些优秀的人。</strong>”我写这篇文章时已36岁，现在看来这样的期望还是过于乐观了，而我的心境，需借用安德鲁·马维尔的诗句：“但我总是听到，背后隆隆逼近的时间的战车……”</p>
<p>无论如何，我对计算机产生了从单纯求知到由衷热爱的转变。当我还诧异于思想蜕变附带来的特殊人生体验时，我竟然从苏轼一篇名为《中庸论》的文章中读到了相似的感悟，只不过苏轼比我会总结，看问题比我更深刻，他在文中用“诚”和“明”两个概念阐述了求知和热爱的关系。这是我所说“你思考或者体验的任何问题，极大可能前人已经思考过了”的一个佐证。</p>
<blockquote>
<p>《记》曰：“自诚明谓之性，自明诚谓之教。 诚则明矣，明则诚矣。 ”夫诚者，何也？乐之之谓也。 乐之则自信，故曰诚。 夫明者，何也？知之之谓也。 知之则达，故曰明。 夫惟圣人，知之者未至，而乐之者先入，先入者为主，而待其余，则是乐之者为主也。 若夫贤人，乐之者未至，而知之者先入，先入者为主，而待其余，则是知之者为主也。 乐之者为主，是故有所不知，知之未尝不行。 知之者为主，是故虽无所不知，而有所不能行。 子曰：“知之者，不如好之者，好之者，不如乐之者。” 知之者与乐之者，是贤人、圣人之辨也。 好之者，是贤人之所由以求诚者也。</p>
</blockquote>
<p>苏轼先抛出了《中庸》的一段名言：“自诚明谓之性，自明诚谓之教。 诚则明矣，明则诚矣。”</p>
<p>这句话很玄妙，没有人能准确解释，即便古人也是连蒙带猜地去理解。大体上说，这句话在说“诚”和“明”的关系，先天禀赋和后天教养的关系。</p>
<p>但到底什么是“诚〞，什么又是“明”呢？ 苏轼援引孔子的一句名言：“知之者不如好之者，好之者不如乐之者。“然后解释说 ：“诚”就是“乐之”，明”就是“知之”。</p>
<p>简单讲，如果你对某事某物天生就有浓厚的兴趣，并乐此不疲，这就是“诚”。比如，你看到美女或者帅哥，自然就会产生怜爱之心，这不需要刻意学习，因为你天性如此，所以孔子会说“吾未见好德如好色者也”。</p>
<p>如果你在离开校园后，依然能够坚持学习各种专业知识，但究其原因，这份坚持很可能不是源自对知识的热爱，而仅仅是出于工作需要。你只是在求知的意义上获取到了知识，而不是天然热爱你的工作领域，这种情况就属于“明”。</p>
<p>“诚”是人与生俱来的特质，从“诚”的状态很容易到达“明”；而从“明”到“诚”却并不简单，你需要具备孜孜不倦的精神，持之以恒的努力，这就是“好之”，是到达“诚”的一种途径。苏轼用圣人和贤人在修养上的区别来阐发“诚”和“明”：圣人往往未知而先行，贤人能做到无所不知，但未必能行。简单说，圣人热爱，所以知之容易，贤人学而知之，但不一定能做到热爱，要抵达热爱的程度，还需要“好之”。</p>
<p>也就是说，如果你对某一领域有一份发自内心的热爱，那么很自然地，你会出于这份热爱，去认真学习相关的知识 ，从热爱到求知的这个过程，就是从“诚”到“明”的过程，也就是《中庸》所谓”自诚明”。这个过程是天性使然，所以”自诚明谓之性”。</p>
<p>相反，如果你并没有这份发自内心的热爱，只是在求知的意义上明白了知识是怎么一回事，那么你的认知就难免流于表面，失之肤浅。如果你并没有因此放弃，而是不断提升自己，不断加深理解的话，那么终有一天你学到的知识会内化成你的一部分，让你产生了发自内心的热爱。从求知到热爱的这个过程，就是从“明“到“诚”的过程，也就是《中庸》所谓“自明诚”。这个过程是教养使然，所以”自明诚谓之教”。</p>
<p>天性总是水到渠成，但教养在大多数情况下却是违逆人性的，然而真正的智慧都来自内心，所以“诚”很值得去追求。孔子的弟子一直跟随在孔子身边，很大程度上并不是因为还有未学到的儒家知识，而仅仅是想再多受一点孔子的熏陶，让所学的知识真正内化为自己的一部分。我之所以能“好之”以求“诚”，完全是思想蜕变作了第一推动力。</p>
<ol start="4">
<li></li>
</ol>
<p>熙宁二年，三十四岁的苏轼任满还朝，途径长安，寄住在好友石苍舒家中。石苍舒收藏字画的地方叫“醉墨堂”，他邀请苏轼为“醉墨堂”作诗，苏轼写了一首《石苍舒醉墨堂》，开头两句便是“人生识字忧患始，姓名粗记可以休”，这话听起来很没道理，为什么人生的忧患会从认字开始呢？</p>
<p>其实，苏轼的本意应该是规劝好友，不要为物所累，对字画倾注过多的热情，以免玩物丧志。这种思想在他后来写给驸马王诜的《宝绘堂记》中表达的更加清晰。不过我们也不妨跟随字面的意思来理解，当一个人识文断字之后，对周围的事物产生了深刻的认识和理解，这份认知的增进往往伴随着无尽的焦虑与忧患。因此，思想变化所带来的影响并不都是积极的。</p>
<p>二十八岁以前的我，可以说是快乐的，无甚忧虑的，我像一只蚕蛹，本应在生活的茧房里优游卒岁，不料“心事浩渺连广宇，于无声处听惊雷”，这只蚕蛹偶然间破茧而出，竟有了探索世界的能力，在游历过一番之后，才蓦然发现自己在食物链中的位置，原本多姿多彩的世界一时间蒙上了灰色的影子。</p>
<p>但这并不是最令人沮丧的，思想重塑带来了“今是而昨非”的觉悟，大有“朝闻道，夕死可以”的气势。但转念之间，又不禁生出了“后之视今亦由今之视昔”的担忧。试想，未来的我很可能会视今日之坚持为谬误，我此刻的努力，是否还能保持其意义与价值？</p>
<p>这是一个很严峻的问题！</p>
<p>庄子的《逍遥游》似乎可以给出一种态度，《逍遥游》讲了一个“人如何才能逍遥”的道理，文章用很大的篇幅对比大鹏和两只小鸟，来说明“小知不及大知”，而且写的奇伟瑰丽，以至于文学性掩盖了哲学性，让人以为庄子是在为大鹏摇旗呐喊，同时贬低小鸟。那么，在这个故事中，庄子除了做事实陈述之外，有没有下价值判断呢？也就是说，除了小鸟和大鹏的客观不同之外，庄子有没有认为小鸟不如大鹏呢？</p>
<blockquote>
<p>故夫知效一官，行比一乡，德合一君，而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世誉之而不加劝，举世非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。</p>
</blockquote>
<p>庄子说，有些人论才智可以做官，论行为符合一乡的道德标准，论德行能投合一个君王的心意的，论能力能够取得全国信任，但这些人跟小鸟是一个档次的，所以宋荣子才会嗤笑他们。显然宋荣子的境界更高，但列子比宋荣子还要高，列子出行需要靠风，所以还有所依恃，这叫“有所待”。有所待就不够逍遥，真正的逍遥是“无所待”，是要“乘天地之正，而御六气之辩，以游无穷”。</p>
<p>可见，庄子的意思很明显：小不如大，有待不如无待。所以仅就“逍遥游”的精神追求而言，在大鹏与小鸟之间，你应该努力学大鹏，在“知效一官”者流与宋荣子之间，你应该努力学宋荣子。总之，即便你穷尽一生都无法达到最高境界，你也应该努力靠近它。</p>
<p>有人曾对人类的科学抱有十分悲观的论调，说人类的科技进步在上帝看来，只不过是地球上两个相差不过一寸的小人，高一寸还是矮一寸，根本毫无区别。胡适反驳这种观点，说人类文明的进步所争的就是这一寸的长短，进一寸自然有这一寸的欢愉。胡适是一个极度乐观主义者，字里行间常常洋溢着乐观和自信，他在《科学的人生观》中慷慨激昂地说道：“朝夕地去求真理，不一定要成功，因为真理无穷，宇宙无穷：我们去寻求，是尽一点责任，希望在总分上，加上万万分之一。胜固是可喜，败也不足忧 …… 庄子虽有 ‘吾生也有涯，而知也无涯，以有涯逐无涯，殆已’的话头，但是我们还要向上做去，得一分就是一分、一寸就是一寸 …… 因为真理无穷，趣味无穷，进步快活也无穷尽。”</p>
<p>没错，胜固然欣，败亦可喜，怕什么真理无穷，进一寸有一寸的欢喜。</p>
<ol start="5">
<li></li>
</ol>
<p>回到最初的问题，人生的意义是什么？</p>
<p>其实，这个问题并没有标准答案，是一个应然问题，是价值判断，是高度主观的，任何答案都对，任何答案都不对。</p>
<p>我现阶段的认知是：人生根本没有任何意义，人生只不过是一场生物学的事实罢了！</p>
<p>如果你退而求其次，问我要做一个怎样的人？我已列举了几种人生态度，我当然推荐保尔柯察金的方案，但是，如果你行有余力，我的建议是：你不必成为其中某一种人，你可以成为他们所有人，择其善者而从之。毕竟，如果每个问题都有定论，那世界将是多么无趣啊！</p>
<p>最后，让我用《列子·杨朱》中的一个故事结束整篇文章：</p>
<blockquote>
<p>昔者宋国有田夫，常衣缊黂（乱麻为絮的衣服），仅以过冬。暨春冬作，自曝于日，不知天下之有广厦隩室，绵纩（新丝棉）狐貉。顾谓其妻曰：‘负日之暄，人莫知者，以献吾君，将有重赏。</p>
</blockquote>
<p>这个故事里，有一个宋国农夫，常常披着破麻絮布勉强熬过冬天。等到了春天，在田里干活，他独自晒太阳，觉得很暖和。他压根儿不知道世上还有高楼大厦，深宅大院，丝绵衣服狐皮袍子。他回家对妻子说：“人们还不知道背晒太阳就会暖和。把用太阳取暖的方法献给国君，一定会得重赏。”</p>
<p>这则故事为我们留下了“负暄献御”这个并不常用的成语。</p>
<p>而我，就是那个献御的宋国农夫。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2024/03/21/golang/for-range-copy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/21/golang/for-range-copy/" class="post-title-link" itemprop="url">Go 语法糖 for range 中的 copy 问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-21 22:17:31" itemprop="dateCreated datePublished" datetime="2024-03-21T22:17:31+08:00">2024-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go 的赋值、参数传递都是值传递，也就是说你得到的是一份 copy，对于如下的 for range 循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someslice = []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> someslice &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>短变量<code>v</code>是<code>someslice</code>中的元素的 copy，在 Go 1.22 以前<code>v</code>只会创建一次，每次循环会复用这一变量，从 1.22 起每次循环会创建新的变量。</p>
<p>现在的问题是： range 后的<code>someslice</code>还是原来的<code>someslice</code>吗？会不会也是一个 copy 呢？</p>
<p>你能猜出下面一段代码的打印结果吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fib := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, f1 := <span class="keyword">range</span> fib &#123;</span><br><span class="line">  f2 := fib[i+<span class="number">1</span>]</span><br><span class="line">  fib = <span class="built_in">append</span>(fib, f1+f2)</span><br><span class="line">  <span class="keyword">if</span> f1+f2 &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fib)</span><br></pre></td></tr></table></figure>

<p>结果是：<code>[0 1 1 2]</code>，是不是不像推想的那样<code>fib</code>中的元素会超过 100？但如果分别在 for 循环的前、中、后打印一下<code>fib</code>的地址，你会发现地址没有变（在这个例子中底层数组是会变得，你可以使用<code>fmt.Printf(&quot;fib1:%p\n&quot;, fib)</code>来验证，对切片使用<code>%p</code>打印会打印第0个元素的地址）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fib := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;fib outer:%p\n&quot;</span>, &amp;fib)</span><br><span class="line"><span class="keyword">for</span> i, f1 := <span class="keyword">range</span> fib &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;fib inner:%p, f1:%p\n&quot;</span>, &amp;fib, &amp;f1)</span><br><span class="line">	f1, f2 := fib[i], fib[i+<span class="number">1</span>]</span><br><span class="line">	fib = <span class="built_in">append</span>(fib, f1+f2)</span><br><span class="line">	<span class="keyword">if</span> f1+f2 &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;fib outer:%p\n&quot;</span>, &amp;fib)</span><br><span class="line">fmt.Println(fib)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">fib outer:<span class="number">0xc00011c000</span></span><br><span class="line">fib inner:<span class="number">0xc00011c000</span>, f1:<span class="number">0xc000110030</span></span><br><span class="line">fib inner:<span class="number">0xc00011c000</span>, f1:<span class="number">0xc000110038</span></span><br><span class="line">fib outer:<span class="number">0xc00011c000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>这是不是说明 range 就是在遍历原<code>fib</code>本身呢？如果是遍历原<code>fib</code>，又为什么这里只循环了 2 次呢？</p>
<p>让我们看看<span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvcmVmL3NwZWMjRm9yX3N0YXRlbWVudHM=">spec<i class="fa fa-external-link-alt"></i></span>中的说明：</p>
<blockquote>
<p>The range expression x is evaluated once before beginning the loop, with one exception: if at most one iteration variable is present and len(x) is constant, the range expression is not evaluated.</p>
</blockquote>
<p>这里的意思是：<strong>在进入循环之前，range 表达式只会计算一次！</strong>但这个<code>evaluate</code>具体指何意，spec 没有解答，看来只能在编译器源码中寻找答案了，我是没有大海捞针的精力了，不过已经有人替我们做了，美中不足的是参考的 gcc 的代码，不过想来都遵循语言规约的话，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL2VhMDIwZmYzZGU5NDgyNzI2Y2U3MDE5YWM0M2MxZDMwMWNlNWUzZGUvc3JjL2NtZC9jb21waWxlL2ludGVybmFsL2djL3JhbmdlLmdvI0wxNjk=">行为方式总是大差不差的<i class="fa fa-external-link-alt"></i></span>，来看看 gcc 的 Go 编译器源码中 range 子句的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Arrange to do a loop appropriate for the type.  We will produce</span><br><span class="line">//   for INIT ; COND ; POST &#123;</span><br><span class="line">//           ITER_INIT</span><br><span class="line">//           INDEX = INDEX_TEMP</span><br><span class="line">//           VALUE = VALUE_TEMP // If there is a value</span><br><span class="line">//           original statements</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure>

<p>可见 range 循环仅仅是 C-style 循环的语法糖，所以当你 range 一个 array 时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The loop we generate:</span><br><span class="line">//   len_temp := len(range)</span><br><span class="line">//   range_temp := range</span><br><span class="line">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span><br><span class="line">//           value_temp = range_temp[index_temp]</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure>

<p>range slice 时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//   for_temp := range</span><br><span class="line">//   len_temp := len(for_temp)</span><br><span class="line">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span><br><span class="line">//           value_temp = for_temp[index_temp]</span><br><span class="line">//           index = index_temp</span><br><span class="line">//           value = value_temp</span><br><span class="line">//           original body</span><br><span class="line">//   &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以从中得到至少4点启示：</p>
<ol>
<li>循环最终都是 C-style 的。</li>
<li>循环遍历的对象都会被赋值给一个临时变量。</li>
<li>由第 2 点可知，range 一个数组的成本要大于 range 切片。</li>
<li>for range 居然涉及到 2 次 copy，一次是 copy 迭代的对象，一次是集合中的元素 copy 到临时变量。</li>
</ol>
<p>我们还原一下开篇提到的代码，大致是如下的样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fib := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 <span class="type">int</span></span><br><span class="line"><span class="comment">// copy 迭代对象</span></span><br><span class="line">temp := fib</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(temp); i++ &#123;</span><br><span class="line">  <span class="comment">// copy 元素</span></span><br><span class="line">  f1 = temp[i]</span><br><span class="line">  f2 := fib[i+<span class="number">1</span>]</span><br><span class="line">  fib = <span class="built_in">append</span>(fib, f1+f2)</span><br><span class="line">  <span class="keyword">if</span> f1+f2 &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fib)</span><br></pre></td></tr></table></figure>

<p>这就解释了代码为何只迭代两次，<code>fib</code>在循环开始前被复制，循环次数就被固定为 2 了。</p>
<p>因此，如果我们迭代一个切片，并且想修改里面的东西，除了在切片中存储指针以外，使用传统的 C-style 风格的循环也是个不错的选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>如果我遍历的是个 map 呢？众所周知，map 是一个指针，range 计算就算 copy 也是 copy 得指针，遍历的时候仍然是同一个 map，事实上 spec 上也说明了这种情况：</p>
<blockquote>
<p>If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced. If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped. </p>
</blockquote>
<p>概括来说，你可以在 range 循环中对 map 进行增删，删掉的元素不会在接下来被遍历到，增加的元素则不一定，也许会被遍历，也许不会，这是由 map 底层使用哈希表实现以及随机遍历机制决定的。</p>
<p><strong>参考文献：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvcmVmL3NwZWMjRm9yX3N0YXRlbWVudHM=">The Go Programming Language Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nYXJiYWdlY29sbGVjdGVkLm9yZy8yMDE3LzAyLzIyL2dvLXJhbmdlLWxvb3AtaW50ZXJuYWxzLw==">Go Range Loop Internals<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2FsaG91bi5pby9kb2VzLXJhbmdlLWNvcHktdGhlLXNsaWNlLWluLWdvLw==">Does Go&#39;s range Copy a Slice Before Iterating Over It?<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2024/01/03/golang/impression-of-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/03/golang/impression-of-go/" class="post-title-link" itemprop="url">谈 Go 的使用感受</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-03 20:17:31" itemprop="dateCreated datePublished" datetime="2024-01-03T20:17:31+08:00">2024-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>假设让你在三种不同的条件下完成一副画，要求笔尖接触纸面到离开纸面即算一笔，三种条件分别是：只能落笔 1、100、10000 次。你觉得对于画家来讲，哪一种方式更困难？</p>
<p>显然，在只能落笔一次的情况下你需要高超的技巧才能一笔画完，而多次落笔会让你驾驭地轻松一点，更多的落笔机会就允许你从容地完成画作。</p>
<p>画是一种空间和色彩交织的复杂整体，其创作过程就是表现这个复杂整体的过程，当你用线性的笔法来创作这个浑然的整体时，难度就凸显出来了，即便天才画家也未必能玩转这种技巧，但当你手中可用的线条足够多时，你就可以轻易地组合成复杂的整体了，不单单是画的创作，在文章以及小说的创作上也类似。</p>
<p>叶圣陶先生在他的文章创作文集中对写作有过如下一段高屋建瓴的论述：<strong>“我们还期望能够组成调顺的‘语句’，调顺的‘篇章’。怎样叫作调顺呢？内面的意思情感是浑凝的，有如球，在同一瞬间可以感知整个的含蕴；而语言文字是连续的，有如线，须一贯而下，方能表达全体的内容。作文同说话一样，是将线表球的工夫，能够经营到通体妥帖，让别人看了便感知我们内面的意思情感，这就叫作调顺。”</strong></p>
<p>因此，才有人说：“<strong>写作，是一场孤独的旅程。</strong>”</p>
<p>叶圣陶先生将写作喻为<strong>“线表球”</strong>的功夫，这是很高明的见识，第一流的见解。我们再来看编程本身，就是将你一团浑凝的、整体的思绪，用指令的方式一丝一缕叙述出来，你要小心地安排事件的进展，巧妙地处理那些同时发生的事情，这跟写作的思路是暗合的，所以我常说：“每个人都能识文断字，但文学家总是凤毛麟角，编程就像作文，计算机语言的语法不难掌握，但天才的程序员却不可多得。” 道理其实一样，难点在于如何用有限的线条去勾勒复杂的整体。</p>
<p>我们这里不谈艺术不谈性能，仅仅从创作者与写作者的心智负担轻重角度讨论。对于写作，你当然无法同时去写几件事情，我在读金庸先生的作品时曾留意过他的叙事手法：<strong>剧情先是沿着主线流淌，因为某些事件的发生，几个人物分离，主线会择其中一人继续流淌，在未来的某个时间点会再次汇集，此时金庸先生会采用中断的方式，倒回去叙述另一人物的剧情，一直到交叉点为止。</strong>当然有些作者会采用多线叙事法，几处剧情同时进行，读者要在这几处剧情中几进几出，最后在某处汇集，但在作者的角度就是类似于一个单核 CPU 进行并发。</p>
<p>显然金庸老爷子的写作方式难度更高，更考验情节的安排与事件的把握，换句话说，小说是一个浑圆的整体，金庸先生将其用一条行进的流来表现复杂的整体；而多线叙事法则相对简单些，只要分开叙事，在关键点集中叙事即可。所以我们不难推想一下，把这种叙事推向极端：支线之间没有重合！作者只要分别写几则叙事短篇即告完成，当然这种书是没有意义的，我们只是来说明这种方式是用多个行进的流来表现复杂的整体，谁都不会否认一笔写完一个字和一镜到底的艺术难度！不过如果人的大脑可以并行工作，我想肯定多线叙事的小说会更受欢迎，只要作者调整一下文字结构，使这些线只在剧情汇集点交叉，不要为了照顾串行的大脑而做形式上的交叉。</p>
<p>现实世界是时间和空间的复杂结合，而最初的计算机程序是单进程，只能线性地表达复杂事物，也就是你要在单个进程流里做所有的事，这种一镜到底的功夫是需要一些艺术规划的；而多进程和多线程让这种表达轻松了许多，你可以几十镜、几百镜一起运用，通过剪辑来表现那个浑凝的整体，但是对于普通人来讲依然困难，因为管理进线程有一套复杂的接口，关键是你要有所节制，要小心地控制进线程的数量，不能屁大点事都要弄个线程去做，你仍然需要在几条或者几十条，几百条线程流中为它找一个位置，因为房子不够多，该挤的还是要挤挤。</p>
<p>Go 语言的协程极大地拓展了这个上限，使得表达复杂事物变得简单了。大部分的场景你都可以给每一个小事安排一个房子，你不用再为了给它寻找位置而煞费苦心，你可以用大量的线条去勾勒一个复杂的整体，该添一笔的地方千万不要吝啬。<strong>毫无疑问，这降低了你的创作难度，你可以肆无忌惮地去表达你心中那个浑凝的整体，用一种近似浑凝的方式！</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/12/17/theory/terminal-buffer-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/17/theory/terminal-buffer-io/" class="post-title-link" itemprop="url">终端闲思录（2）- 终端与缓冲的关系</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-17 10:34:44" itemprop="dateCreated datePublished" datetime="2023-12-17T10:34:44+08:00">2023-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/terminal/" itemprop="url" rel="index"><span itemprop="name">terminal</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/terminal/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/terminal/computer-theory/buffer-io/" itemprop="url" rel="index"><span itemprop="name">buffer io</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们已经知道标准三剑客（标准输入、标准输出、标准错误）的本质是文件描述符，其连接的目的地可以是任意类型的文件，终端只是常用的目的地之一。那么，当目的地类型不同，IO 的行为是否也有所不同呢？那位架构师所说<strong>“控制台是同步的”</strong>是否过于危言耸听了呢？</p>
<p>让我们看回作为“Linux 一切皆文件”的通用 I&#x2F;O 接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>;</span><br><span class="line">	Returns number of bytes read, <span class="number">0</span> on EOF, or –<span class="number">1</span> on error</span><br><span class="line">        </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>;</span><br><span class="line">	Returns number of bytes written, or –<span class="number">1</span> on error</span><br></pre></td></tr></table></figure>

<p>这是 glibc 对系统调用<code>read</code>、<code>write</code>的封装，大部分应用的 IO 都是对这两个封装函数的调用，即便是不使用 C 库的语言，其标准库也提供对系统调用<code>read</code>、<code>write</code>的封装，比如 Go 语言，其标准库底层直接对接的系统调用，与 glibc 处于同一层级。</p>
<p>从接口定义可知，读与写都需要传入一个存储读写内容的缓冲区指针<strong>buffer</strong>以及存储内容大小的<strong>count</strong>，显而易见的是：在所需传输内容大小一定的情况下，<strong>buffer</strong>越小，对<code>read</code>、<code>write</code>的调用次数越多，反之则调用次数越少，我们来看一个不同 buffer 大小对传输时间影响的例子：</p>
<p><img data-src="https://qiniu.liupzmin.com/copy-100m.png" alt="图 1-1 复制 100MB 大小的文件所需时间"></p>
<p>读和写大体涉及三块时间：<strong>系统调用的时间</strong>、<strong>内核与用户空间数据复制的时间</strong>、<strong>内核和磁盘交互的时间</strong>。可见系统调用的成本还是比较可观的，当 <code>BUF_SIZE</code> 增长到 4096 的时候，总耗时趋于稳定，<code>BUF_SIZE</code> 的增加对性能的提升不再显著，这是因为与其它两个时间耗时相比，系统调用的时间成本已经微不足道了。</p>
<p>上面的例子混合了读与写，初次操作不可不免的需要从磁盘传输数据到页高速缓存中，让我们再看一个只有写的例子：</p>
<p><img data-src="https://qiniu.liupzmin.com/write-100m.png" alt="图 1-2 写一个 100MB 大小的文件所需的时间"></p>
<p>在 Linux 中，写是异步的，内容会先进入页高速缓存，之后<code>write</code>系统调用返回，真正落盘的操作由内核异步完成，因此只要内存充足，<code>write</code>的性能总是可以得到保证的。</p>
<blockquote>
<p>注：图中两例引用自<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">Linux&#x2F;UNIX系统编程手册<i class="fa fa-external-link-alt"></i></span>，用于说明系统调用的昂贵，我偷懒没有自己写例子运行。</p>
</blockquote>
<p>总之，如果有大量内容需要使用 I&#x2F;O 接口传输，或者需要长时间不定时调用 I&#x2F;O 接口，通过采用合理的大块空间来缓冲数据，以减少系统调用的次数，可以极大地提高 I&#x2F;O 的性能，此 glibc 中 stdio 之所为也！</p>
<p>C 库（Linux 中为 glibc）将文件读写抽象成了一个名为<code>FILE*</code>的流（stream，标准三剑客会被抽象为 stdin、stdout、stderr），其中就包含我们上面提到的缓冲处理，这避免了程序员自行处理数据缓冲。C 库有三种缓冲类型：</p>
<ul>
<li><strong>_IOFBF（全缓冲）</strong>。单次读写数据的大小与缓冲区大小相同，指代磁盘文件的流默认采用此模式。</li>
<li><strong>_IOLBF（行缓冲）</strong>。对于写入，在遇到换行符时才执行（除非缓冲区已填满）；对于读取，每次读取一行数据。当连接终端时默认采取行缓冲。</li>
<li><strong>_IONBF（无缓冲）</strong>。不对 I&#x2F;O 进行缓冲，每个 stdio 库函数将立即调用<code>read</code>、<code>write</code>，连接到终端的标准错误即是这种类型。</li>
</ul>
<p>用一个简单的程序来测试终端对 C 库缓冲的影响：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _isatty();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        _isatty();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _isatty()&#123;</span><br><span class="line">    <span class="keyword">if</span> (isatty(fileno(<span class="built_in">stdout</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;stdout is connected to a terminal (line buffered)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;an error painted to stderr\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;stdout is not connected to a terminal (fully buffered)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;an error painted to stderr, but redirected\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请分别<strong>在终端中直接运行</strong>（.&#x2F;isatty）和<strong>重定向到文件运行</strong>（.&#x2F;isatty &gt; isatty.log 2&gt;&amp;1 &amp;），观察终端和 isatty.log 文件的输出，会发现如下现象：</p>
<ol>
<li>重定向（不再指向终端）会让标准输出变为全缓冲。</li>
<li>重定向对 stderr 无影响，默认情况下依然是无缓冲。</li>
</ol>
<p>由此可知，<strong>当向标准输出写日志时，其缓冲行为与是否连接到终端有关，当作为后台服务运行时，即便将日志打到标准输出，写日志的行为也是有缓冲的。至于标准错误，如果对错误信息没有即时要求，也是可以调整其缓冲模式的，不必依赖默认设置。</strong></p>
<p>当然，这是 C 库的做法，换一种不依赖 C 库的语言，行为可能就会不同，我们来看一下 Go 语言的表现（我总是举 Go 语言的例子，熟悉是一方面，更重要的是，Go 与 C 库脱离的很彻底）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log/slog&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/term&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	w := bufio.NewWriter(os.Stdout)</span><br><span class="line">	h := slog.NewJSONHandler(w, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	logger := slog.New(h)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查标准输出是否连接到终端</span></span><br><span class="line">	a := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> term.IsTerminal(<span class="type">int</span>(os.Stdout.Fd())) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;标准输出连接到终端--from fmt\n&quot;</span>)</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">&quot;标准错误连接到终端--from fmt\n&quot;</span>)</span><br><span class="line">			slog.Info(<span class="string">&quot;标准输出连接到终端--from slog&quot;</span>)</span><br><span class="line">			logger.Info(<span class="string">&quot;标准输出连接到终端--from slog json logger&quot;</span>)</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;标准输出未连接到终端--from fmt\n&quot;</span>)</span><br><span class="line">			fmt.Fprintf(os.Stderr, <span class="string">&quot;标准错误未连接到终端--from fmt\n&quot;</span>)</span><br><span class="line">			slog.Info(<span class="string">&quot;标准输出未连接到终端--from slog&quot;</span>)</span><br><span class="line">			logger.Info(<span class="string">&quot;标准输出未连接到终端--from slog json logger&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		a()</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请再次分别<strong>在终端中直接运行</strong>（.&#x2F;isatty）和<strong>重定向到文件运行</strong>（.&#x2F;isatty &gt; isatty.log 2&gt;&amp;1 &amp;），观察终端和 isatty.log 文件的输出，会发现如下现象：</p>
<ol>
<li><p>无论是否连接到终端，对标准输出和标准错误的输出行为不会发生任何变化</p>
</li>
<li><p>想要异步写入，需要自行构建带缓冲的 logger，如此例中的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w := bufio.NewWriter(os.Stdout)</span><br><span class="line">h := slog.NewJSONHandler(w, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">logger := slog.New(h)</span><br></pre></td></tr></table></figure>

<p>而 slog 默认的 logger 是写入 stderr 的，不信你可以运行<code>./isatty &gt; isatty.log &amp;</code>仅仅重定向标准输出试试。</p>
</li>
</ol>
<p>产生这种现象的原因是 Go 标准库并没有像 C 库那样对标准库的 I&#x2F;O 大包大揽，文件流<code>*os.File</code>是无缓冲的，Go 标准库函数的 I&#x2F;O 基本都是基于接口，且提供有实现了缓冲 I&#x2F;O 以及 I&#x2F;O 接口的<code>bufio</code>包。</p>
<p>上面例子中的 json logger 就是使用<code>bufio</code>基于标准输出创建了一个带缓冲的<code>writer</code>，而 slog 包中创建 Handler 仅需传入实现<code>writer</code>接口的对象即可，因此我们得到一个带有缓冲的 logger。</p>
<p><img data-src="https://qiniu.liupzmin.com/c-io-summary.png" alt="图 1-3 I/O 缓冲"></p>
<p>不论标准库使用如何方式提供缓冲，其目的始终是减少系统调用，图 1-3 以 C 库为例展示了这种 I&#x2F;O 模型，<strong>使用标准库函数将日志写入标准输出，是可以设置合理的缓冲区的，并不存在“同步、性能低下”的担忧。</strong>因此，我们可以确定如下几点：</p>
<ol>
<li>标准三剑客是文件描述符，任何基于文件的读写库函数都可以向标准输出和标准错误写入。</li>
<li>向标准输出和标准错误写入不影响日志框架的使用。</li>
<li>即便日志框架不提供缓冲区，也是可以提供一个实现了缓冲的 writer 以实现异步写入。</li>
</ol>
<p>那么，是否就可以由此断定在容器中将日志写入标准输出与标准错误跟写入文件相比就没有差别了呢？当然不是的，这要取决于标准输出与标准错误出重定向之目的地的写入能力，我们不妨拿<code>logback</code>来做个测试，<code>logback</code>是 java 领域应用广泛的日志框架，其往标准输出写入和文件写入分别是由<code>console</code>和<code>file</code>两个 appender 实现的，所以，我们首先在写入目的地的写入能力相同的情况下测试两个 appender 的能力是否有所差异，方法就是在<code>console</code>输出时重定向到文件，这样实际的 I&#x2F;O 就都是普通文件 I&#x2F;O 了。</p>
<table>
<thead>
<tr>
<th>写入条数</th>
<th>console</th>
<th>file</th>
<th>写入大小</th>
</tr>
</thead>
<tbody><tr>
<td>1000000</td>
<td>1729ms</td>
<td>1771ms</td>
<td>85m</td>
</tr>
<tr>
<td>5000000</td>
<td>7414ms</td>
<td>7708ms</td>
<td>480m</td>
</tr>
<tr>
<td>10000000</td>
<td>14545ms</td>
<td>15854ms</td>
<td>800m</td>
</tr>
<tr>
<td>20000000</td>
<td>32030ms</td>
<td>31754ms</td>
<td>1.7g</td>
</tr>
<tr>
<td>40000000</td>
<td>59479ms</td>
<td>59339ms</td>
<td>3.4g</td>
</tr>
</tbody></table>
<p>简单粗暴地将类似的内容以不同的条数写入，观察总的执行时间。由上述表格可知，这两个<code>appender</code>的自身能力可以说基本相同。在此基础上可以放在 k8s 上运行了，我这里仅对<code>40000000</code>的情况做一下测试，注意不要和上面表格对比，上面是 nvme 硬盘的响应时间，接下来的测试是普通企业 sas 盘的响应时间：</p>
<table>
<thead>
<tr>
<th>写入条数</th>
<th>console</th>
<th>file</th>
<th>写入大小</th>
</tr>
</thead>
<tbody><tr>
<td>40000000</td>
<td>111778ms</td>
<td>82679ms</td>
<td>3.4g</td>
</tr>
<tr>
<td>40000000</td>
<td>100143ms</td>
<td>87610ms</td>
<td>3.4g</td>
</tr>
<tr>
<td>40000000</td>
<td>98589ms</td>
<td>91603ms</td>
<td>3.4g</td>
</tr>
<tr>
<td>40000000</td>
<td>97093ms</td>
<td>91193ms</td>
<td>3.4g</td>
</tr>
<tr>
<td>40000000</td>
<td>98536ms</td>
<td>86348ms</td>
<td>3.4g</td>
</tr>
</tbody></table>
<p>仅就这单一的测试场景而论，使用<code>console appender</code>的性能会略逊一筹，大约有 10% 左右的性能损失，产生这种结果的原因是由容器中标准输出的目的地不同于文件造成的。</p>
<p>k8s 中的容器，除了使用<code>exec</code>附加到容器 namespace 启动的进程有控制终端之外，大部分以后台进程运行的程序是没有控制终端的，不妨进入容器的 namespace 看看服务进程的标准三剑客指向哪里：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ # ps aux</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:06 /usr/local/bin/isatty</span><br><span class="line">    7 root      0:00 sh</span><br><span class="line">   13 root      0:00 ps aux</span><br><span class="line">/ # cd /proc/1/fd</span><br><span class="line">/proc/1/fd # ls -l</span><br><span class="line">total 0</span><br><span class="line">lrwx------    1 root     root            64 Dec 12 02:25 0 -&gt; /dev/null</span><br><span class="line">l-wx------    1 root     root            64 Dec 12 02:25 1 -&gt; pipe:[54791]</span><br><span class="line">l-wx------    1 root     root            64 Dec 12 02:25 2 -&gt; pipe:[54792]</span><br></pre></td></tr></table></figure>

<p>1 号进程是我们的测试进程，可见其标准输入指向<code>/dev/null</code>，标准输出和标准错误分别指向不同的管道，不知你是否好奇这是如何做到的呢？容器的日志又是如何写到<code>/var/log/containers</code>中的呢？</p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTkwMDQwMy8=">UNIX环境高级编程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">Linux&#x2F;UNIX系统编程手册<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/11/22/theory/terminal-fun-fact/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/22/theory/terminal-fun-fact/" class="post-title-link" itemprop="url">终端闲思录（1）- 世界是我的表象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-22 20:23:00" itemprop="dateCreated datePublished" datetime="2023-11-22T20:23:00+08:00">2023-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/terminal/" itemprop="url" rel="index"><span itemprop="name">terminal</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/terminal/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>终端</strong>是我们习焉不察，日用而不知的一种工具，如果去问一个 Linux 爱好者：“Linux 中最神秘的东西是什么？” 我相信回答<strong>“终端”</strong>的人一定不在少数。<strong>黑洞洞的窗口，像音符一样跳动的命令与输出，适时闪烁的光标，无一不弥漫着古老而又神秘的气息！</strong></p>
<p><img data-src="https://qiniu.liupzmin.com/ssh.jpg" alt="黑客帝国中的终端"></p>
<h2 id="1-日志联想"><a href="#1-日志联想" class="headerlink" title="1 日志联想"></a>1 日志联想</h2><p>促使我 dig 终端的原因是我所在的公司要上线一个新项目，要求采用 k8s 作为运行平台。那么，日志处理方面就需要一个合理的方案。</p>
<p>我注意到 k8s 官方给出了几个<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY2x1c3Rlci1hZG1pbmlzdHJhdGlvbi9sb2dnaW5nLw==">可行方案<i class="fa fa-external-link-alt"></i></span>：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY2x1c3Rlci1hZG1pbmlzdHJhdGlvbi9sb2dnaW5nLyN1c2luZy1hLW5vZGUtbG9nZ2luZy1hZ2VudA==">使用节点级日志代理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY2x1c3Rlci1hZG1pbmlzdHJhdGlvbi9sb2dnaW5nLyNzaWRlY2FyLWNvbnRhaW5lci13aXRoLWxvZ2dpbmctYWdlbnQ=">使用边车容器运行日志代理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY2x1c3Rlci1hZG1pbmlzdHJhdGlvbi9sb2dnaW5nLyMlRTUlODUlQjclRTYlOUMlODklRTYlOTclQTUlRTUlQkYlOTclRTQlQkIlQTMlRTclOTAlODYlRTUlOEElOUYlRTglODMlQkQlRTclOUElODQlRTglQkUlQjklRTglQkQlQTYlRTUlQUUlQjklRTUlOTklQTg=">具有日志代理功能的边车容器<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY2x1c3Rlci1hZG1pbmlzdHJhdGlvbi9sb2dnaW5nLyNleHBvc2luZy1sb2dzLWRpcmVjdGx5LWZyb20tdGhlLWFwcGxpY2F0aW9u">从应用中直接暴露日志目录<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>其中，前两个方案都要求应用或者边车将日志写入标准输出和标准错误，相应的容器运行时负责将其转储为文件，最后由节点级的日志代理统一收集整理。后面两个方案其资源成本和开发成本都比较可观，并且将无法使用<code>kubectl logs</code>访问日志。</p>
<p>很明显可以看出，k8s 是偏向于应用将日志写入标准输出和标准错误的，这让我想起一位架构师朋友曾经说：<strong>“我不想把日志打到控制台，因为控制台是同步的，这会影响性能。”</strong></p>
<p>这段话即便不是错误的，至少也是不准确的。鉴于长久以来都对<strong>终端、控制台、标准输入与标准输出以及标准错误</strong>（Unix 世界竟然没有一个简单的概念来统称这三个文件描述符，为了方便称呼，后续我将在这三者同时出现的地方以<strong>标准三剑客</strong>来代替）等概念笼统对待，为破除这一刻板印象，并理顺 k8s 中处理日志的思路，搞清楚打印到标准输出与标准错误是否合理，我做了一些研究工作，清理了如下三个障碍：</p>
<ol>
<li>终端与标准三剑客的关系</li>
<li>标准三剑客与缓冲</li>
<li>k8s 是如何重定向标准三剑客的 ？</li>
</ol>
<p>这些问题真的那么重要吗？不妨假想一下：</p>
<blockquote>
<p>k8s 建议你将日志打印到标准输出和标准错误，而你是一个略微有点计算机文化积淀的人，你知道在 C 标准库里标准三剑客的 I&#x2F;O 缓冲各不相同，缓冲最大的也就是个行缓冲，你会狐疑着说：&quot;我都不确定我所用语言的缓冲设计，我能放心地往标准输出和标准错误写吗？你把那些优秀的高吞吐日志框架至于何地？&quot;</p>
<p>这时，一位大腹便便的中年人慢悠悠踱到你面前，语重心长地说道：“少侠，稍安勿躁，谁说往标准输出和标准错误写就一定写往终端 ？就一定是行缓冲 ？就一定要用<strong>‘printf’</strong>、<strong>‘fmt.Print’</strong>、<strong>‘system.out.println’</strong> ？”</p>
<p>一连串的反问让你内心掠过一丝不快，但望着他稀疏的额头和有些混浊却不失坚毅的眼睛，你最终只是微微张了张嘴，没能说出一个字。</p>
<p>他肥胖的身躯坐了下来，用手捋着下巴上一撮小胡须，施施然道：“闻道有先后，不知道并不可怕，一知半解才可怕，我看你方才只是‘狐疑’着发问，并未理直气壮、斩钉截铁、目空一切，而且也不曾顶撞老夫，说明孺子可教，我就拣重点与你说说吧！”</p>
<p>说罢，便开始了涛涛雄辩。</p>
</blockquote>
<p>言归正传，我将用三篇文章来把这三个问题讲清楚，这是系列第一篇，先让我们进入终端的神秘世界吧!</p>
<h2 id="2-终端迷雾"><a href="#2-终端迷雾" class="headerlink" title="2 终端迷雾"></a>2 终端迷雾</h2><p>终端（terminal），源自拉丁语 <em>terminalis</em>，意为“与边界或结尾有关，最终的”，&quot;与计算机通信的设备&quot;之意首次记录于1954年，时间上距今不足百年，而计算机日新月异的发展速度使得很多事物快速出现又快速消亡，变成随时间层层累积的沉积岩，搞清楚其源流嬗变殊为不易，以至于后来的我们很难看清事情的原貌。我实在很想拥有钩沉索微的能力，去近距离感受每处痕迹背后的波澜壮阔，而不是如今只能通过抚摸巨岩的横截面，来想象那个时代的风云际会。</p>
<p>终端是一种和计算机交互的硬件设备（早期是硬件，如今已是软件），用于处理输入和输出。最早的硬件终端是电传打印机（<strong>teleprinter</strong>、<strong>teletypewriter</strong>、<strong>teletype</strong>、<strong>TTY</strong> 指的都是电传打印机），显示内容需要打印到纸上，这也是为什么我们在编程中向终端打印使用 <strong>print</strong> 而不是 <strong>display</strong> 的原因，使用屏幕显示内容还要等到 CRT（阴极射线管）设备的出现。</p>
<p><img data-src="https://qiniu.liupzmin.com/teletype.jpg" alt="图 2-1 二战时期的电传打印机"></p>
<p>这些硬件终端与计算机通过串口直连，或者通过调制解调器远程连接，不过这种连接方式的距离和终端数量都很有限。如果把计算机比作一条章鱼，那么终端就是触手的顶端，从拉丁词源 <em>terminalis</em> “与边界或结尾有关，最终的”之意中，我们多少还能窥见这一层含义。</p>
<p><img data-src="https://qiniu.liupzmin.com/DEC_VT100_mid.jpg" alt="图 2-2 图形终端 VT100"></p>
<p>图 2-2 是 DEC 公司生产的图形终端 <strong>VT-100</strong> ，广泛流行的终端模拟器和 SSH 客户端软件 SecureCRT 中，可以设置模拟的终端类型，其中就有 VT-100 系列。从 SecureCRT 各种终端类型中，依然可以看出当年终端设备市场是怎样一个山头林立的状态，这些设备没有统一的标准，各自有各自的字符转义序列。所谓的字符转义序列是指向终端发送的特殊控制字符，终端会将这些特殊字符解释为相应的功能，比如调整终端的显示，vi 类软件特别需要标准化，再比如<code>Ctrl+C</code>是向会话中的前台进程发送<code>SIGINT</code>信号（终端如何得知哪一个是前台进程请参考 Unix&#x2F;Linux 手册进程组部分的内容），<code>Ctrl+D</code>会使得从终端读取输入的进程读取到一个<code>end-of-file</code>。</p>
<p>现代意义上的终端已经几乎全部虚拟化、软件化了，Unix&#x2F;Linux 系统可以通过<code>Ctrl+Alt+Fn</code> 组合键切换虚拟终端，现代 Linux 系统通常在其中一个终端启动图形界面，我的 Manjaro 桌面就启动在 <code>F2</code> 上。Unix&#x2F;Linux 在功能键上启动的这些终端即是虚拟终端<code>/dev/ttyn</code>。</p>
<p>另一个与终端有关的概念是 Console —— 控制台，控制台其实是一种终端，大多时候和计算机长在一起，不一定要有屏幕，摇杆、按钮也可称为控制台，只要是能控制计算机的都属于控制台。</p>
<p>现代个人计算机已经没有控制台了，终端和控制台已经虚拟化，且大多时候混用这两概念也没有问题。但寻其本意依然都有处理计算机输入与输出的意思，又因终端和控制台经常和标准三剑客关联，有些软件不免就会混淆其中，例如 java 著名的日志框架 logback 有一个输出目的地 <strong>ConsoleAppender</strong> ，其实是用<em>System.out</em> 、 <em>System.err</em> 将内容写往标准输出和标准错误的，而标准输出和标准错误并不一定连接终端或控制台，标准三剑客的相关内容我会在后面详述，现在我们有必要看一下传统的终端登录过程，看看终端是如何被打开的。</p>
<p><img data-src="https://qiniu.liupzmin.com/bsd-terminal-login.png" alt="图 2-3 终端登录"><img data-src="https://qiniu.liupzmin.com/terminal-login-shell.png" alt="图 2-4 终端与shell关联"></p>
<p>SysV 系统中，init 进程是系统启动后用户空间拉起的第一个进程，也叫 1 号进程，现代 Linux 如果采用 Systemd 系统启动，其 1 号进程是 Systemd 进程。传统 Unix 在启动时 init 进程会扫描<code>/etc/ttys</code>中的内容，<code>/etc/ttys</code>中配置有连接到该计算机上的终端设备列表，init 进程会遍历每个设备，针对每个设备都 fork 一个进程来处理，图 2-3 展示了这个过程。</p>
<p>fork 之后子进程会执行<code>getty</code>程序，getty 会打开终端，如果终端是通过调制解调器连接的，getty 会等待对方拨号，一旦设备打开成功，文件描述符<code>0，1，2</code>就被设置到终端上了，而<code>0，1，2</code>就是标准三剑客，如果不出意外（文件描述符未被重定向），后续对<code>0，1，2</code>的读写都是对终端的读写，在内核中由<strong>终端驱动</strong>提供服务。不难想见，终端驱动会吸收键盘的输入，会将输出打印到设备屏幕。</p>
<p>getty 的最后一项使命是向终端打印<strong>“login:”</strong>，等待我们输入用户名，一旦我们输入用户名回车，getty 便功成身退，它会以类似如下方式调用<code>login</code>程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execle(<span class="string">&quot;/bin/login&quot;</span>, <span class="string">&quot;login&quot;</span>, <span class="string">&quot;-p&quot;</span>, username, (<span class="type">char</span> *)<span class="number">0</span>, envp);</span><br></pre></td></tr></table></figure>

<p>login 程序会向终端打印<strong>“Password:”</strong>来提示用户输入密码，当然终端的回显功能会被关掉。接下来 login 会做一系列的工作，比如鉴权、设置环境变量、设置 HOME 目录、开启会话、设置进程组等等，最后会调用 shell 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-sh&quot;</span>, (<span class="type">char</span> *)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>如图 2-4 所示，execl 后进程变为 shell，但<code>0，1，2</code>文件描述符得以保留，毋庸置疑的是，此时三剑客指向终端，shell 进程的读写都依赖终端驱动程序处理。我们现在将终端驱动部分放大，看看其内部对输入输出的处理过程，如图 2-5 所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/terminal-io.png" alt="图 2-5 终端设备的输入输出序列"></p>
<p>进程对于终端设备的读写由终端驱动处理，终端驱动维护着两个队列：<strong>输入队列和输出队列</strong>，键盘的输入会进入输入队列，最后被进程读取；进程的输出会进入输出队列，由终端显示。如果该终端设备的回显功能被打开，进入输入队列的内容会同时发送到输出队列，由终端设备显示在屏幕上，这就是你敲击键盘后终端中显示内容的原因，前文的 login 程序在收集密码时就会将回显功能关闭。</p>
<p>我之所以讲“你敲击键盘后终端中显示内容”而不是“shell 中显示内容”，是为了强调一个事实：<strong>你能看到的所有内容都是你的输入和shell 的输出</strong>。你永远不会在 shell 里面，你只能给它提供输入，观察它的输出，当然是在终端上。</p>
<p>而此刻，shell 向终端输出了<code>root@hostname:~ #</code>的提示符，终端驱动程序将其打印到可见终端，当然，这个终端有可能是<code>Ctrl+Alt+Fn</code> 组合键下显示器呈现的虚拟终端，也有可能是视窗界面下的终端模拟器，但基本不可能是最初的终端设备了。</p>
<p>这当然是因为那些设备现在已经消失了，物理设备一经消亡，原本显示的重任就交给显卡来处理了，终端驱动想必会因此生出黍离一样的悲痛。而我们当然不会在乎终端驱动是否悲痛，我们只是对这种割裂感有所不适。</p>
<p><code>Ctrl+Alt+Fn</code> 组合键大概是对早期硬件终端连接场景的模拟，毕竟在 PC 个人化以及 shell 作业控制广泛应用的今天，实在看不出它还有什么其它的意义。因为在这种场景下进入终端，我们只能看到显示设备（不能称之为终端，如显示器）以及 shell 的输出，终端一词就像无源之水、无根之木一样没了着落。</p>
<p>请允许我用夸张的舞台腔背诵加缪《西西弗神话》中的段落：&quot;在一个突然被剥夺了幻觉和光明的宇宙中，人就感到自己是个局外人。这种放逐无可救药，因为人被剥夺了对故乡的回忆和对乐土的希望。这种人和生活的分离，演员和布景的分离，正是荒诞感。&quot;</p>
<p>终端和 shell 的概念纠缠正是出于这种荒诞感！</p>
<p>讲到这里，似乎不再需要刻意去辨析终端和 shell 的区别了，现象已经很明朗：连接到终端的最终程序是 shell，shell 以及由此 shell 启动的任何程序其三剑客都指向终端，它们的输出也会打印到终端。作为计算机行业的新新人类，失去了物理真实的触摸，极目所望，尽是 shell 及其子孙的输出，终端的概念早已淹没其中，混淆也就在所难免了。</p>
<p>视窗界面下的终端模拟器似乎将这种荒诞缓和了一些，但也仅仅是一些，在一个单薄的窗口中，shell 的输出占据了绝大多数的领地，只有边框和工具栏在隐隐的提示人们：我是有形的！</p>
<p>无论如何，由电传打印机沿袭下来的 <code>tty</code> 一词却在 Unix 中留下了深深的印记，tty 子系统、tty 驱动、虚拟终端 &#x2F;dev&#x2F;ttyn、伪终端 pty 等都有着<code>teletype</code>的影子。</p>
<h2 id="3-大行其道的伪终端"><a href="#3-大行其道的伪终端" class="headerlink" title="3 大行其道的伪终端"></a>3 大行其道的伪终端</h2><p>第 2 节介绍的终端登录场景，进程打开的设备是<code>/dev/ttyn</code>，通常被称为虚拟终端，基本只有在<code>Ctrl+Alt+Fn</code> 组合键和虚拟机管理界面的控制台进入的终端属于此类。大多数场景用的都是伪终端，比如终端模拟器和网络 SSH 登录，本节我们就梳理一下这两种常见的终端场景。</p>
<p>伪终端其实是 IPC（进程间通信）的一种，它有一对主从设备， 也叫伪终端对，分别连接着两个进程：</p>
<p><img data-src="https://qiniu.liupzmin.com/pseudo.png" alt="图 3-1 使用伪终端的相关进程的典型结构"></p>
<p>图 3-1 是使用伪终端相关进程的典型结构，伪终端主设备和从设备组成了一个双向管道，连接了两个进程。通常连接从设备的进程是 shell，所以，对 shell 来讲伪终端从设备表现的就像原来的终端设备，终端驱动也是和从设备相连，进程对终端的读写都发往从设备。</p>
<p>与以往不同的是，进程眼中的终端设备在这里不以显示为直接目的，而是将输出发往另一个进程，输入也要从另一个进程读取，而这正是为终端模拟器和网络 SSH 登录设计的，我们先看一看终端模拟器的情况：</p>
<p><img data-src="https://qiniu.liupzmin.com/terminal-emulator.png" alt="图 3-2 使用伪终端的终端模拟器"></p>
<p>图 3-2 展示了一个打开了两个窗口的终端模拟器，终端模拟器是一个图形化的视窗程序，针对每一个窗口创建一个伪终端对，并 fork 出 shell 进程，将 shell 进程的标准三剑客连接到伪终端从设备，如此一来，shell 便从终端模拟器程序读取输入，输出发往终端模拟器，最后被渲染到窗口界面。这是连接本地终端的情况，下面再看一下 SSH 登录：</p>
<p><img data-src="https://qiniu.liupzmin.com/ssh-pseudo.png" alt="图 3-3 使用伪终端的 SSH"></p>
<p>SSH 是使用伪终端的另一个例子，它允许本地用户安全地通过网络连接到远程机器上登录 shell，图 3-3 展示了这种情况，ssh server 为每个登录请求创建伪终端对，并 fork 出 shell 进程连接到伪终端从设备。客户端的输入通过网络抵达 ssh server，ssh server 发往伪终端主设备，最终变为 shell 进程的标准输入；同样，由 shell 产生的输出经过伪终端主设备抵达 ssh server，再经 ssh server 发送到网络，最终被 ssh client 接收。现在请你思考一下：ssh client 会如何处理接收到的 shell 输出呢？</p>
<p>从图中不难看出，ssh client 要将 shell 的输出送往终端显示，问题是你能猜出图中的<code>terminal</code>是什么设备吗？</p>
<p>其实我们已经讲过了，此处的<code>terminal</code>可以看作图 3-2 的缩影，ssh client 连接的是本地伪终端对中的从设备，用户使用的可能是终端模拟器，模拟器 fork 的进程就是 ssh client，shell 的提示符<code>root@localhost:~ # </code>历经千山万水，终于呈现在你本地的终端模拟器上了。</p>
<h2 id="4-标准三剑客的本质"><a href="#4-标准三剑客的本质" class="headerlink" title="4 标准三剑客的本质"></a>4 标准三剑客的本质</h2><p>Linux 会为打开的文件分配一个非负整数来表示该文件，文件的 I&#x2F;O 调用都要通过文件描述符来发起，文件描述符用来表示所有类型的已打开的文件，这包括管道（pipe）、FIFO、socket、普通文件和终端设备等。Linux 为这些类型的文件提供了统一的通用 I&#x2F;O 模型，即 open、close、read、write 等系统调用接口，因此，所谓的<strong>“Linux 一切皆文件”</strong>应该更多地从通用文件 I&#x2F;O 接口的角度来理解。</p>
<p>我们所讨论的终端即是其中一种文件类型，标准三剑客表示的<strong>“0，1，2”</strong>三个文件描述符，背后的文件类型通常是终端设备，例外情况等我讲到复制文件描述符的时候再详细讨论，我们先明确一下文件描述符和文件的对应关系。</p>
<p>打开文件，获得文件的描述符，似乎文件和文件描述符的一对一关系是不言而喻的，但是，<strong>多个文件描述符可以指向同一打开的文件，这些文件描述符可以在相同或不同的进程打开。</strong>如图 4-1 所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/file-fd-releationship.png" alt="图 4-1 文件描述符，打开的文件描述，文件inode之间的关系"></p>
<p>上图展示了进程的文件描述符（file descriptor）、内核维护的系统所有打开的文件描述（open file description）以及文件 inode 之间的关系。简单介绍一下，左侧表格代表进程的文件描述符；中间表格称为 open file description table，是内核为所有打开的文件维护的一个系统级描述表；右侧表格代表 inode，可简单理解为硬盘上的文件。</p>
<p>从中我们可以得到以下几点信息：</p>
<ol>
<li>在进程 A 中，<strong>文件描述符</strong> 1 和 20 都指向同一个<strong>打开文件描述</strong>，这可能是通过复制文件描述符形成的。</li>
<li>进程 A 的文件描述符 2 和 进程 B 的文件描述符 2 都指向同一个<strong>打开文件描述</strong>，这种情形可能是进程 A 进行 fork 调用形成的，子进程会继承父进程所有打开的文件描述符。</li>
<li>进程 A 的文件描述符 0 和进程 B 的文件描述符 3 分别指向不同的<strong>打开文件描述</strong>，但这些描述均指向相同的 inode，这是因为每个进程各自对同一文件发起了 open 调用，同一进程两次打开同一文件也会出现这种情况。</li>
</ol>
<p>关于第一点复制文件描述符稍后另行展开，我们先看第二点，父进程 fork 出子进程，子进程会继承父进程所有打开的文件描述符，如果子进程稍后调用 exec 执行了其它的程序，那些没有设置<code>O_CLOEXEC</code>的文件描述符都会在子进程中得到保留。</p>
<p>shell 进程已经打开了<strong>“0，1，2”</strong>三个文件描述符，在此shell中执行的所有进程都会继承这三个文件描述符，如果没有特殊的变动，它们会和 shell 一样将<strong>“0，1，2”</strong>连接到终端。你是否有过这样的经历：在 shell 中执行了程序，程序进入了后台，回车后可见 shell 的提示符，说明你依然可以操作，但是进入后台的程序却时不时的输出一点内容到你的终端，如果你没遇到过，可以用下面的命令试一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for  ((;;)) do sleep 1; echo &quot;hello&quot;; done &amp;</span><br></pre></td></tr></table></figure>

<p>如果你需要终止它，输入<code>fg</code>将进程拉到前台，<code>Ctrl+C</code>结束它，不要害怕<code>f</code>和<code>g</code>之间被<code>hello</code>充塞，世界只是你的表象，表象虽然乱了，但内在的输入队列和输出队列依然有序运行。</p>
<p>之所以产生这种现象是因为没有为放到后台的进程处理标准输出和标准错误， shell fork 子进程出来解释该命令，子进程继承了 <strong>“0，1，2”</strong>文件描述符，<code>&amp;</code>标志将进程送往后台，但是并没有对标准三剑客进行调整，其对应的<strong>“0，1，2”</strong>描述符依然和终端相关联，所以当<code>echo &quot;hello&quot;</code>向标准输出打印的时候，内容依然会显示在终端上。不过不用担心后台进程会干扰标准输入，shell 会确保只有前台进程才能从终端进行读取（参考进程组的内容）。</p>
<p>程序并不经常产生这种行为，大多数情况下我们需要在 shell 中通过重定向语法<strong>“&gt;”</strong>来处理标准三剑客。有些支持 daemon 的程序会提供诸如<code>-d</code>或<code>--detach</code>的选项在处理好标准三剑客之后启动到后台，一种典型的处理是将标准三剑客指向<strong>“&#x2F;dev&#x2F;null”</strong>，因为 daemon 程序通常并不需要使用终端；而 systemd 管理下的 service 通常会将标准输出和标准错误重定向到 Unix 域套接字，这些输出内容作为日志受到 journald 进程的管理。</p>
<p>完成这种重定向的就是 dup 家族的 <strong>dup</strong>、<strong>dup2</strong>、<strong>dup3</strong> 三个系统调用。使用最多的是 dup2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">//Returns (new) file descriptor on success, or –1 on error</span></span><br></pre></td></tr></table></figure>

<p>dup2() 系统调用会为 oldfd 参数指定的文件描述符创建副本，副本的编号由 newfd 参数指定，所以<code>dup(1, 20)</code>就会产生图 4-1 中所示进程 A 的情况。shell 的重定向语法和管道就是使用 dup 实现的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./myscript &gt; results.log 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>

<p>上面这条重定向命令被广泛使用，Bourne shell 的重定向语法<strong>“2&gt;&amp;1”</strong>，意在通知 shell 把标准错误重定向到标准输出，这条语法的效果大致使用如下方式实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;results.log&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (dup2(fd, STDOUT_FILENO) != STDOUT_FILENO)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (dup2(STDOUT_FILENO, STDERR_FILENO) != STDERR_FILENO)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 文件描述符复制完毕，fd 可以关闭</span></span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>这一刻，<strong>STDOUT_FILENO</strong> 和 <strong>STDERR_FILENO</strong> ，也就是文件描述符<strong>“1，2”</strong>与终端脱离关系，写往标准输出和标准错误的内容全部进入 results.log 文件，不会再显示在终端上。</p>
<blockquote>
<p>所以，<strong>标准三剑客的本质仅仅是文件描述符</strong>，各种语言中那些能打印到终端的 I&#x2F;O 函数（如<strong>‘printf’</strong>、<strong>‘fmt.Print’</strong>、<strong>‘system.out.println’</strong>），其底层使用的就是<strong>“0，1，2”</strong>三个文件描述符，函数最终输出到哪里要看<strong>“0，1，2”</strong>指向哪里。</p>
</blockquote>
<p>还记得<strong>“Linux 一切皆文件”</strong>指得是通用文件 I&#x2F;O 接口吗？文件描述符可以指向任意类型的文件，我们再来看一个管道的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | wc -l</span><br></pre></td></tr></table></figure>

<p>要执行这条命令，shell 将 fork-exec 两个进程出来，并且创建管道，将 ls 的标准输出重定向到管道的写入端，将 wc 标准输入重定向到管道的读取端，如下图所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/pipe.png" alt="图 4-2 使用管道连接两个进程"></p>
<p>ls 和 wc 两个进程根本不知道管道的存在，它们一如既往地从标准输入读取，写入标准输出，这其中的工作是由 shell 来完成的，大概类似如下这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">pipe(pfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第一个进程中复制文件描述符，重定向标准输出到管道写端</span></span><br><span class="line"><span class="keyword">if</span> (dup2(pfd[<span class="number">1</span>], STDOUT_FILENO) == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第二个进程中复制文件描述符，重定向标准输入到管道读端</span></span><br><span class="line"><span class="keyword">if</span> (dup2(pfd[<span class="number">0</span>], STDIN_FILENO) == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>大多数处理文件描述符的工作都会放在 fork 之后，exec 之前。exec 之前都属于 shell 的代码范围，exec 之后就是另一个程序了。</p>
<p>现在可以解答开篇的第一个问题了——终端与标准三剑客的关系。<strong>标准三剑客的本质仅仅是文件描述符，描述符的指向可以是任意类型的文件</strong>，标准三剑客与终端只是在交互场景下的特定结合，并不存在必然的联系，万不能混为一谈。</p>
<h2 id="5-标准三剑客从哪里来？"><a href="#5-标准三剑客从哪里来？" class="headerlink" title="5 标准三剑客从哪里来？"></a>5 标准三剑客从哪里来？</h2><p>接下来，我们很容易产生新的疑问：我编写的程序应该如何处理标准三剑客呢？或者说该不该关注标准三剑客呢？如果要关注，什么情况下需要关注呢？</p>
<p>要讲清楚这个新问题需要先概括一下程序的类型，Linux 大概有两种类型的程序：</p>
<ol>
<li>普通程序</li>
<li>daemon 程序</li>
</ol>
<p>daemon 程序人所共知，是运行在后台的程序，反之运行在后台的程序不一定是 daemon，在 Linux 上想成为 daemon 可是有一套繁琐流程的，你要关闭除标准三剑客之外的其它文件描述符、将信号重置到默认状态、开启新的会话、调用两次  fork 以脱离控制终端、将标准三剑客重定向到<code>/dev/null</code>等等，<span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3NvZnR3YXJlL3N5c3RlbWQvbWFuL2xhdGVzdC9kYWVtb24uaHRtbCM=">SysV Daemons<i class="fa fa-external-link-alt"></i></span> 描述了传统 SysV daemon 的制作过程。</p>
<p>不是 daemon 的程序都属于普通程序（启动的二进制程序是主程序，即不会退出），我猜测除了系统级的程序员以外很少人会去写 daemon 了，好在世界不断变化，Systemd 简化了这些工作，大多数工作都被 Systemd 处理了，你的普通程序也能 daemon 化，但是要配合好 Systemd 你还是有些额外工作要完成，这不是本文重点，此处略去不谈。</p>
<p>SysV daemon 将标准三剑客重定向到<code>/dev/null</code>，此举意味着一个自觉的 daemon 应该考虑自己的标准输出（既然是 daemon，标准输入自然是不需要的）。如果有日志输出，应该将内容写到文件，你要非往标准输出打，就将标准输出重定向到文件或者其它地方，这些工作需要你自己完成。</p>
<p>Systemd 会主动将标准输入重定向到<code>/dev/null</code>，标准输出和标准错误重定向到<code>systemd-journald.service</code>，你的普通程序也可以被 Systemd 管理而不用担心标准三剑客的问题。</p>
<p>不过复杂有复杂的好处，简单有简单的取舍，SysV Daemons 除了在 SysV 下管理之外，你还可以在交互式 shell 下直接运行使程序进入后台，而普通程序想进入后台，除了使用 SysVinit 和 Systemd 管理之外，只能用<code>nohup</code>、<code>setsid</code>、<code>disown</code>这些命令来达到长期后台运行的目。</p>
<p>经过第 4 节的论述，我们会得出这样的结论：<strong>程序自身以及 fork 该程序的父进程都有机会去修改标准三剑客的指向</strong>。所以，我们还想捋清楚一点：如果什么都不做，在各种常见情况下启动的程序其标准三剑客的默认继承是怎样的。</p>
<p>SysVinit 和 Systemd 的 1 号进程无控制终端，其标准三剑客连接到<code>/dev/null</code>；交互式 shell 有控制终端，其标准三剑客连接到 shell 所在终端。明确这两点是因为各种服务管理系统的 init 进程和 shell 是我们运行程序的父进程，不做任何处理的话，子进程会继承父进程的标准三剑客。根据程序类型、运行方式、服务管理系统的不同，大致可分成以下 6 种情况：</p>
<ol>
<li><p>SysVinit + 普通程序</p>
<p>普通进程如果被 SysVinit 管理，将继承 init 进程的设置，即标准三剑客连接到<code>/dev/null</code>，这种情况下如果你打印东西到标准输出，所有内容都会被丢进黑洞。拯救方法就是使用 shell 提供的重定向功能将标准输出和标准错误重定向到文件，因为 init 是 fork 一个 shell 来执行 init.d 中的脚本的。</p>
<p>顺带一提，init 是为每个 init.d 的脚本都 fork 一个 shell 进程来解释执行的，脚本中的命令又要被 shell fork 执行，其性能上的负担可见一斑，这就是其被 Systemd 取代的原因。</p>
</li>
<li><p>SysVinit + SysV daemon</p>
<p>这种情况前文已述，继承的肯定是标准三剑客连接到<code>/dev/null</code>，但 SysV daemon 通常都会自行设置。</p>
</li>
<li><p>shell + SysV daemon</p>
<p>交互式 shell 下执行 daemon 程序，不会继承 shell 的设置，daemon 的目的就是丢弃控制终端，重建会话。</p>
</li>
<li><p>shell + 普通程序</p>
<p>交互式 shell 下执行普通程序，会继承 shell 的设置，标准三剑客连接到 shell 所在的控制终端。</p>
</li>
<li><p>Systemd + 普通程序</p>
<p>这种情况前文已述，Systemd 会主动将标准输入重定向到<code>/dev/null</code>，标准输出和标准错误重定向到<code>systemd-journald.service</code>，相当于systemd.service 中设置 type&#x3D;simple 或者 type&#x3D;exec，需要启动的程序本身是主进程。</p>
<p>值得一提的是，Systemd 管理下的一些传统支持 daemon 的程序都要加上特定的参数，使程序启动到前台，比如 sshd：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/sshd -D</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-D      When this option is specified, sshd will not detach and does not become a daemon.</p>
</blockquote>
</li>
<li><p>Systemd + SysV daemon</p>
<p>这是新瓶装旧酒，用 Systemd 来管理传统的 daemon，在 service 文件里需要配置为：<code>type=forking</code>，但 Systemd 明确表示不鼓励这样使用，也就是说在程序设计上务必向 Systemd 的规则靠拢。</p>
<p>标准三剑客就自不待言了，我的地盘我做主。</p>
</li>
</ol>
<p><strong>后台运行的本质是脱离控制终端，运行在新的会话下，从而忽略终端的<code>SIGHUP</code>信号，以此获得永生！</strong>所以你会发现，标准三剑客是程序后台化的一个绊脚石，系统的不同部分在不同层次上给出了各自的解决方案。</p>
<h2 id="6-关于终端的哲学呓语"><a href="#6-关于终端的哲学呓语" class="headerlink" title="6 关于终端的哲学呓语"></a>6 关于终端的哲学呓语</h2><p>最后终于要谈到文章那个唬人的副标题了——<strong>世界是我的表象</strong>。这句话出自叔本华的哲学名著《作为意志和表象的世界》，没错，我要用我肤浅的不能再肤浅的哲学知识做一些哲学上的附会，如果你对哲学没有兴趣，阅读至此就可以离开了，你并不会因此错过什么。</p>
<p>我们的认知能力是一副天然的有色眼镜，我们看到的世界都是有色眼镜呈现给我们的，在叔本华哲学里有个很重要的概念：摩耶之幕。简单讲，就是一张超级巨大的，囊括天地的，但普通人察觉不到的帷幕。这个概念来自古印度的宗教经典，讲出了一个耸人听闻的真理：你以为山河大地、日月星辰都是真实存在的吗？那你就错了，你被骗了！其实我们看到的全部宇宙都只是婆楼那神施展出来的幻术，全是假的，一旦婆楼那神收回神通，宇宙就消失了。</p>
<p>其背后的真实世界是我们靠理性永远认识不到的。真实的世界，或者说物体在真实世界中的样子，康德谓之物自体，叔本华谓之意志，柏拉图会说那是理念。</p>
<p>为了把问题简化，你可以想象一下自己的所有感官都不存在，只剩下一双眼睛，只存在视觉能力，然后你一辈子都戴着一副红色的眼镜，镜片是半球形的凸面镜，所以你看到的万事万物不但都是红色的，还都是变形的。变形当然是有规律的，在怎样的角度，怎样的距离，会发生怎样的变形，你逐渐都能研究清楚，形成一套科学认知体系。当我站在你面前，如果你采取的是平视的角度，会看到一个红色的枣核形胖子，俯视的话，看到的是红色的墩子形胖子，仰视的话，看到的是一个红色的梨形胖子。我真的长成这样吗？真的会变形吗？当然不是，但你永远看不到我真实的样子，更重要的是，你永远都不该妄想能看到我真实的样子。你戴的眼镜决定了你的视觉模式，这是改变不了的。在你眼里，我永远都是一个红色的、会变形的胖子。</p>
<p>真实的我，还包括真实的其他东西，康德称之为“物自体”，属于本体世界，而你看到的我，包括你看到的其他东西，都是物自体通过你的有色眼镜呈现给你的视觉图像，康德称之为“现象”，也可以叫“表象”。</p>
<p>如果将计算机比作一个世界，终端呈现的就是世界的表象。如果终端中的字符有生命，他们能感官的一切都是表象，就连普通人对计算机的认知也是通过终端或者显示器的呈现，也同样是计算机世界的表象，而内行当然知道这些丰富表象的本质仅仅是高低电平的错落。</p>
<p>现实世界只是现象世界，叔本华认为我们被“意志”支配，欲无止境，人生充满痛苦，所以聪明人都应该舍现象而求本体，舍刹那而求永恒。而完美且永恒的世界就是本体世界，就是理念的世界。</p>
<p>康德认为时间和空间都是我们的主管感受，当你戴着时间和空间的眼镜，你看到的万事万物都会表现为时间上的相继和空间上的相距，这是认知能力带给我们的关系和限制，我们无法摆脱，也就是无法进入理念的世界。</p>
<p>但叔本华认为，我们可以短暂的进入到理念的世界，那是一种短暂的迷狂状态，霎那间仿佛时间和空间都消失了，你忘记了一切，现实生活里的各种柴米油盐都不复存在了，等回过神来的时候，突然会涌起一种深深的失落，叔本华称之为“审美直观”和“自失”。</p>
<p>这是美学里的概念，是的，叔本华认为人是可以通过审美进入自失状态的，这种迷狂的，自失的状态就是理念世界。</p>
<p>任何人只要在现实生活里窥见了理念世界，都只想留在那里，再也不愿意回来。遗憾的是我们只能短暂的进入理念世界，而通过对文学艺术的审美，就可以使人进入这种状态。你可能会问：我为什么要进入这种状态？朴实的回答是你由此获得了审美享受，叔本华会说你摆脱了现实的世界的悲剧，进入了理念世界，获得了自由！</p>
<p>那么，文学艺术作品为何能产生审美直观呢?</p>
<p>所谓的理念，也叫理型、理想、理想型（此处并不是我们日常语言中的“理想”），简单讲就是抽象的、一般性的概念，在哲学术语里通常称为“共相”。比如我们在现实世界里看到这朵花和那朵花，看到成千上万朵花，每一朵花都是具体的、特殊的，这叫“殊相”。但我们会从无数具体的殊相的花里抽取共同特征，形成一个“花”的概念，这就是共相。我们用“花”这个共相来整合这朵花和那朵花的殊相。诗人在迷狂状态下可以写出好诗，画家在迷狂状态下可以画出好画，因为他们创作出来的作品是直接对理念的写照，写出了抽象，写出了共性。那么，在我们欣赏这些艺术杰作的时候，同样能进入迷狂状态，直接看到理念。</p>
<p>没错，那个既完美又永恒的世界是一个精神世界！</p>
<p>我早年一直想弄明白文学艺术的意义，为什么提到文明，我们总会首先联想到文学艺术，为什么不能是科学技术呢？你看它不像科学来帮助我们发现真理，改善生活，乃至改变人类进程；也不像社会学和政治学关心我们真正的生活秩序问题；更不像哲学在思想上指导人类前行。那文学艺术的意义到底是什么呢？就连《三体》中地球被降维打击时，为了让文明可以展现在二维花卷上，主人公也是将一些诸如《诗经》、《清明上河图》、《蒙娜丽莎》、《星空》等文学艺术作品呈现出来，为什么就不能展现半导体电路板、火箭设计图纸呢？</p>
<p>前面的长篇大论就是我在哲学上找到的答案，也是我最想分享给你的。我确实有过叔本华所谓的自失状态，我早年读《草样年华》，近些年读《三体》都曾浓烈的感受到茫然的自失，后来我的兴趣逐渐转向了历史和哲学，这种体会也只有在研究计算机技术的时候才能多少体会到一点了，而这才是我真正想要讲的内容。</p>
<p>康德说我们永远无法搞清楚物自体的世界，所以只应研究表象世界，不要研究物自体世界；叔本华认为我们虽然无法搞清物自体，但可以认识到，推测它的一些特征，也就是所谓的意志。文学艺术需要写出物自体的特征，也就是理念，才能将人带入审美直观，但计算机的世界不同于文学艺术，它不需要通过艺术手段抽象世界的共性以达到理念的世界，它就是世界，一个将表象和实质都呈现给你的世界，但你需要付出一点理性才能将表象和实质联系起来。</p>
<p>我们处在现实世界之中，只能通过文学艺术达到审美直观，而我们在计算机的世界之外，“我们”创造了这个世界，可以认为计算机世界是对真实世界的拙劣模仿，设计者扮演了类似上帝的角色。在这个拙劣的世界里，我们既能看到表象，又能认识到物自体，我们完全可以把自己想象成计算机世界的表象，然后在现实世界运用理性认识到表象背后的物自体，就像是在看一幕戏剧，从开始到结尾，你既看得出角色的悲欢，又能体会到上帝创造万物时的理念，你无形中靠近了上帝，在遐想中脱离了计算机世界的时空束缚，达到了一种自失状态。</p>
<p>这无关荣耀，只关乎自由！</p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTkwMDQwMy8=">UNIX环境高级编程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">Linux&#x2F;UNIX系统编程手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcHV0ZXJfdGVybWluYWw=">Computer terminal<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly8wcG9pbnRlci5kZS9ibG9nL3Byb2plY3RzL3NlcmlhbC1jb25zb2xlLmh0bWw=">systemd for Administrators<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80MTI2L3doYXQtaXMtdGhlLWV4YWN0LWRpZmZlcmVuY2UtYmV0d2Vlbi1hLXRlcm1pbmFsLWEtc2hlbGwtYS10dHktYW5kLWEtY29uLzQxMzIjNDEzMg==">what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGVsZXByaW50ZXI=">Teleprinter<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3NvZnR3YXJlL3N5c3RlbWQvbWFuL2xhdGVzdC9kYWVtb24uaHRtbCM=">Daemons<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3NvZnR3YXJlL3N5c3RlbWQvbWFuL2xhdGVzdC9zeXN0ZW1kLnNlcnZpY2UuaHRtbCM=">systemd.service<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zNDk0MTUxMi8=">《人间词话》的哲学基础<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/10/14/golang/debug-containerd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/14/golang/debug-containerd/" class="post-title-link" itemprop="url">我想 Debug 容器运行时</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-14 10:08:00" itemprop="dateCreated datePublished" datetime="2023-10-14T10:08:00+08:00">2023-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>出于好奇，我想弄明白  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbnRhaW5lcmQvY29udGFpbmVyZA==">Containerd<i class="fa fa-external-link-alt"></i></span> 是如何处理容器 stdio 的，因为我在 k8s 环境中使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbnRhaW5lcmQvY29udGFpbmVyZA==">Containerd<i class="fa fa-external-link-alt"></i></span> 作为容器运行时，且观察到容器中的标准 io 为如下形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/proc/1/fd # ls -l</span><br><span class="line">total 0</span><br><span class="line">lrwx------    1 root     root            64 Oct 10 02:25 0 -&gt; /dev/null</span><br><span class="line">l-wx------    1 root     root            64 Oct 10 02:25 1 -&gt; pipe:[45731]</span><br><span class="line">l-wx------    1 root     root            64 Oct 10 02:25 2 -&gt; pipe:[45732]</span><br></pre></td></tr></table></figure>

<p>这是个非常简单的容器，只是往标准输出打印一些内容。从容器进程打开的文件描述符中，我们看到其标准输入被丢弃（通过重定向到 <strong>&#x2F;dev&#x2F;null</strong> ），而标准输出和标准错误都被重定向到 <strong>Linux 管道</strong>。</p>
<p>是的，我对 Containerd 如何做到这一点有着浓厚的兴趣，这驱使我产生了 Debug 容器运行时的念头。</p>
<p>这篇短文仅仅介绍我如何达到 Debug 的目的，并不会介绍 Containerd 如何设置标准 io，这部分内容我会放在接下来想写的《终端闲思录》里面。</p>
<h2 id="Containerd-的生态链位置"><a href="#Containerd-的生态链位置" class="headerlink" title="Containerd 的生态链位置"></a>Containerd 的生态链位置</h2><p>首先应该明确一下 Containerd 在整个容器调用链里的位置，我借用一幅容器技术架构图来说明：</p>
<p><img data-src="https://qiniu.liupzmin.com/container.png" alt="图 1-1 容器技术架构"></p>
<p>从图中可知，Containerd 通过 CRI 接口上承 k8s，通过 OCI 接口下接 runc，真正创建容器和启动容器的是底层的 runc，所有的 CRI 容器运行时均依赖于 runc 。</p>
<p>你可能已经被 OCI 和 CRI 绕晕了，简言之，这是容器圈里的两大标准：</p>
<ul>
<li><strong>Open Container Initiative (OCI):</strong> a set of standards for containers, describing the image format, runtime, and distribution.</li>
<li><strong>Container Runtime Interface (CRI) in Kubernetes:</strong> An API that allows you to use different container runtimes in Kubernetes.</li>
</ul>
<p>只要记住 OCI 是容器标准，包扩容器创建，镜像格式等等，而 CRI 是属于 k8s 的接口，每个对接 k8s 的容器运行时都要实现这一套接口才能被 kubelet 调用。</p>
<h2 id="Debug-前的准备"><a href="#Debug-前的准备" class="headerlink" title="Debug 前的准备"></a>Debug 前的准备</h2><p>我 Debug 的对象就是实现了 CRI 的 Containerd，但我却面临两个问题：</p>
<ol>
<li>Containerd 需要 root 权限运行，而我并不想在 root 用户下再配置一次 ide 。</li>
<li>虽然可以在 root 下使用 delve 直接调试二进制文件，但我并不清楚 kubelet 调用 Containerd 时传递的参数，而我 Debug 的初衷就是想弄清楚 kubelet 传递的参数内容。</li>
</ol>
<p><strong>所以，我决定 Debug 一个运行中的 Containerd！</strong></p>
<p>这很容易做到，使用 <code>dlv attach pid</code>就可以 Debug Containerd 进程。万事俱备，只欠一套 k8s 环境。所幸，我们有 minikube ！</p>
<p>minikube 是在一个虚拟机中运行所有相关组件的，所以有两个问题需要解决：</p>
<ol>
<li>在 minikube 的虚拟机中准备 delve 工具。</li>
<li>准备一个可调试的 Containerd 服务。</li>
</ol>
<p>第一点很好解决，minikube 虚拟机和 Host 之间是通过一个网桥通信的，使用<code>minikube ssh</code>命令登录到 minikube 虚拟机中，scp 宿主机的工具到 minikube 中就可以了。</p>
<p>通过软件仓库安装的 Containerd 都是经过编译优化的二进制文件，里面缺乏调试信息，因此我们需要编译一份带有调试信息的二进制文件，观察 Containerd 的 makefile 可以发现如下内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> GODEBUG</span><br><span class="line">	EXTRA_LDFLAGS += -s -w</span><br><span class="line">	DEBUG_GO_GCFLAGS :=</span><br><span class="line">	DEBUG_TAGS :=</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	DEBUG_GO_GCFLAGS := -gcflags=all=<span class="string">&quot;-N -l&quot;</span></span><br><span class="line">	DEBUG_TAGS := static_build</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>如果环境变量没有设置 GODEBUG ，那么就启用编译优化，否则增加调试信息，所以我们在 make 之前，执行一下<code>export GODEBUG=1</code>即可编译出可调试的二进制文件了。编译完成后，使用 scp 拷贝到 minikube 中，重新启动 Containerd 即可。</p>
<p>delve 读取的本地文件系统中项目的内容用于显示单步中的代码，所以，还需要将编译时所用的源码 copy 到 minikube 中，并保持原有路径！</p>
<h2 id="开始-Debug"><a href="#开始-Debug" class="headerlink" title="开始 Debug"></a>开始 Debug</h2><p>上述准备工作完成后，就可以进入 minikube 虚拟机进行 debug 了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">richard@Richard-Manjaro:~ » minikube ssh</span><br><span class="line">docker@minikube:~$ sudo -i</span><br><span class="line">root@minikube:~<span class="comment"># ps -ef|grep containerd|grep -v shim</span></span><br><span class="line">root         504       1  3 06:47 ?        00:00:02 /usr/bin/containerd -l debug</span><br><span class="line">root         873       1  3 06:48 ?        00:00:02 /var/lib/minikube/binaries/v1.27.4/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --config=/var/lib/kubelet/config.yaml --container-runtime-endpoint=unix:///run/containerd/containerd.sock --hostname-override=minikube --kubeconfig=/etc/kubernetes/kubelet.conf --node-ip=192.168.49.2</span><br><span class="line">root@minikube:~<span class="comment"># dlv attach 504</span></span><br><span class="line">Type <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> list of commands.</span><br><span class="line">(dlv) bp</span><br><span class="line">Breakpoint runtime-fatal-throw (enabled) at 0x559126263aa4,0x559126263b84 <span class="keyword">for</span> (multiple <span class="built_in">functions</span>)() &lt;multiple locations&gt;:0 (0)</span><br><span class="line">Breakpoint unrecovered-panic (enabled) at 0x559126263f04 <span class="keyword">for</span> runtime.fatalpanic() /usr/lib/go/src/runtime/panic.go:1188 (0)</span><br><span class="line">	<span class="built_in">print</span> runtime.curg._panic.arg</span><br><span class="line">(dlv) b pkg/cri/server/container_create.go:222</span><br><span class="line">Breakpoint 1 <span class="built_in">set</span> at 0x559127d44f4d <span class="keyword">for</span> github.com/containerd/containerd/pkg/cri/server.(*criService).CreateContainer() /home/richard/opensource/containerd/pkg/cri/server/container_create.go:222</span><br><span class="line">(dlv) b services/tasks/local.go:167</span><br><span class="line">Breakpoint 2 <span class="built_in">set</span> at 0x55912734f072 <span class="keyword">for</span> github.com/containerd/containerd/services/tasks.(*<span class="built_in">local</span>).Create() /home/richard/opensource/containerd/services/tasks/local.go:167</span><br><span class="line">(dlv) bp</span><br><span class="line">Breakpoint runtime-fatal-throw (enabled) at 0x559126263aa4,0x559126263b84 <span class="keyword">for</span> (multiple <span class="built_in">functions</span>)() &lt;multiple locations&gt;:0 (0)</span><br><span class="line">Breakpoint unrecovered-panic (enabled) at 0x559126263f04 <span class="keyword">for</span> runtime.fatalpanic() /usr/lib/go/src/runtime/panic.go:1188 (0)</span><br><span class="line">	<span class="built_in">print</span> runtime.curg._panic.arg</span><br><span class="line">Breakpoint 1 (enabled) at 0x559127d44f4d <span class="keyword">for</span> github.com/containerd/containerd/pkg/cri/server.(*criService).CreateContainer() /home/richard/opensource/containerd/pkg/cri/server/container_create.go:222 (0)</span><br><span class="line">Breakpoint 2 (enabled) at 0x55912734f072 <span class="keyword">for</span> github.com/containerd/containerd/services/tasks.(*<span class="built_in">local</span>).Create() /home/richard/opensource/containerd/services/tasks/local.go:167 (0)</span><br><span class="line">(dlv) c</span><br><span class="line">&gt; github.com/containerd/containerd/services/tasks.(*<span class="built_in">local</span>).Create() /home/richard/opensource/containerd/services/tasks/local.go:167 (hits goroutine(2264):1 total:1) (PC: 0x55912734f072)</span><br><span class="line">   162:		monitor   runtime.TaskMonitor</span><br><span class="line">   163:		v2Runtime runtime.PlatformRuntime</span><br><span class="line">   164:	&#125;</span><br><span class="line">   165:	</span><br><span class="line">   166:	func (l *<span class="built_in">local</span>) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, error) &#123;</span><br><span class="line">=&gt; 167:		container, err := l.getContainer(ctx, r.ContainerID)</span><br><span class="line">   168:		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">   169:			<span class="built_in">return</span> nil, errdefs.ToGRPC(err)</span><br><span class="line">   170:		&#125;</span><br><span class="line">   171:		checkpointPath, err := getRestorePath(container.Runtime.Name, r.Options)</span><br><span class="line">   172:		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">(dlv) </span><br></pre></td></tr></table></figure>

<p>进入虚拟机后，切换到 root 执行 delve 指令 <code>dlv attach 504</code>，我在此设置了两个断点：</p>
<ol>
<li>pkg&#x2F;cri&#x2F;server&#x2F;container_create.go:222 这是 Containerd 的 CRI 实现里创建容器的接口函数，此函数隶属于一个 grpc server，当我们使用 kubectl 创建工作负载时，会触发此断点。</li>
<li>services&#x2F;tasks&#x2F;local.go:167 这是 Containerd 将 CRI 请求转化为任务事件的创建入口。</li>
</ol>
<p>使用 kubectl 提交一个负载就可以单步调试啦 ！O(∩_∩)O~</p>
<h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ol>
<li><p>由图 1-1 可知，k8s 使用 CRI 与容器运行时交互，所以确保 minikube 的运行时使用 Containerd，而不是 docker。docker 虽然也会使用 Containerd，但这种情况下  k8s 不会走 Containerd 的 CRI 接口，相反走的是 docker-shim 的接口，而后者已在 k8s 1.24 中被抛弃。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">richard@Richard-Manjaro:~/playground/k8s » ikube get nodes -o wide</span><br><span class="line">NAME       STATUS     ROLES           AGE     VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION       CONTAINER-RUNTIME</span><br><span class="line">minikube   NotReady   control-plane   5d23h   v1.27.4   192.168.49.2   &lt;none&gt;        Ubuntu 22.04.2 LTS   5.15.133-1-MANJARO   containerd://1.7.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想通过 Containerd 的日志进行简单的 debug，那么开启 debug 日志即可，方法为在执行文件后追加 —log-level&#x3D;debug</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker@minikube:~$ cat /usr/lib/systemd/system/containerd.service </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=containerd container runtime</span><br><span class="line">Documentation=https://containerd.io</span><br><span class="line">After=network.target local-fs.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=-/sbin/modprobe overlay</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/bin/containerd -l debug</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>一定要在你的玩具环境中调试，任何公共环境都不应被用来 debug ！</p>
</li>
</ol>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWx3b3Jrcy5jb20vZGlmZmVyZW5jZS1kb2NrZXItY29udGFpbmVyZC1ydW5jLWNyaW8tb2NpLw==">The differences between Docker, containerd, CRI-O and runc<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/10/05/theory/lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/05/theory/lua/" class="post-title-link" itemprop="url">神奇的 lua</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-05 09:56:28" itemprop="dateCreated datePublished" datetime="2023-10-05T09:56:28+08:00">2023-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从来没去了解过 lua，今天抽空看了一下原理，特此记录一下。</p>
<p>在此，我们先不去管 lua 的语法，仅就其神奇之处论之，看看它到底神在哪里。</p>
<p><strong>lua 的神奇之处是它的解释器很小，目前 5.4.6 版本的二进制只有 300k，及其小巧！</strong></p>
<p>唯其如此，它才可以被嵌入到服务端程序的内部！根据 lua 提供的 API，你可以在进程里启动一个 lua 虚拟机，来解释客户端提交上来的 lua 脚本或者字节码。</p>
<p>这还不算完，你还可以在进程里和 lua 脚本联动，在程序中提供 lua 脚本能访问的 API，之后就可以和 lua 脚本互相交换数据了，这就给了程序设计很大的自由空间，向客户端提供了操纵程序逻辑的摇杆。</p>
<p>lua 是用 C 语言写的，天然适配于 C 的后端，如果其它语言想要内嵌，则需要一个相关语言实现的 lua 解释器，比如 gopher-lua 就是 Go 语言实现的 lua 虚拟机和编译器，Go 程序就可以将其嵌入自身来解释 lua 脚本，并提供 API 给脚本使用，促成了程序功能的灵活多变性。</p>
<p>Redis 内嵌了 lua 的代码，提供了 lua 脚本可以访问的 Redis 对象。所以，你就可以在 lua 脚本里对 Redis 进行操作了。</p>
<p>Redis 使用 lua 脚本可以保证一组操作的原子性，我们知道 Redis 中的事务也可以做到，但是使用 lua 则更加灵活，你可以根据不同的条件执行不同的命令，这是事务所做不到的。</p>
<p>综上，lua 基本上就是“灵活” 的代名词！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/08/08/golang/a-little-thought-of-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/08/golang/a-little-thought-of-concurrency/" class="post-title-link" itemprop="url">关于并发的一点思考</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-08 18:08:30" itemprop="dateCreated datePublished" datetime="2023-08-08T18:08:30+08:00">2023-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>计算机之所以需要并发，是为了提高 CPU 的利用率，因为大多数任务场景是混合了计算和 I&#x2F;O 的，那么为了减少响应时间，使任务能够“同时”进行，计算机程序便演化出了并发的概念。</p>
<p>本文就针对 CPU-bound 和 IO-bound 两种极端场景，来聊一聊 Go 和 Tokio 的并发模型在应对不同并发场景下的异同。</p>
<p><a href="https://liupzmin.com/2023/06/28/golang/netpoller/">《异步 IO 探秘》</a> 和 <a href="https://liupzmin.com/2023/06/08/network/talk-rust-async-netio-with-chatgpt/">《对话 ChatGPT 理解 Rust 异步网络 io》</a> 已基于 Linux 平台就 Go 和 Tokio 的网络模型做了简要剖析，大致有如下几个要点：</p>
<ol>
<li>底层 Reactor 都是 非阻塞 I&#x2F;O + epoll 模型。</li>
<li>事件处理方式不同。Go 紧密结合 goroutine，让网络事件转化为对网络文件描述符感兴趣的 goroutine，并将其注入运行队列，伺机调度；Tokio 基于唤醒机制催动 Executor 去轮询每个 Future，每个 Future 都被编译为一个状态机。</li>
<li>异步编程是对并发模型的考验。程序必须有能力挂起不能继续的任务，转而执行其它的任务，因为网络文件描述符非阻塞的特性，异步网络 I&#x2F;O 才会成为可能。</li>
<li>普通文件 I&#x2F;O 的异步解决方案需要等待 io_uring 的普及。</li>
</ol>
<p>关于“<strong>异步编程是对并发模型的考验</strong>&quot;这一点，可以从 Tokio 官方对于异步编程的论述中得到印证：</p>
<blockquote>
<p>What is asynchronous programming?</p>
<p>Most computer programs are executed in the same order in which they are written. The first line executes, then the next, and so on. With synchronous programming, when a program encounters an operation that cannot be completed immediately, it will block until the operation completes. For example, establishing a TCP connection requires an exchange with a peer over the network, which can take a sizeable amount of time. During this time, the thread is blocked.</p>
<p>With asynchronous programming, operations that cannot complete immediately are suspended to the background. The thread is not blocked, and can continue running other things. Once the operation completes, the task is unsuspended and continues processing from where it left off. Our example from before only has one task, so nothing happens while it is suspended, but asynchronous programs typically have many such tasks.</p>
<p>Although asynchronous programming can result in faster applications, it often results in much more complicated programs. The programmer is required to track all the state necessary to resume work once the asynchronous operation completes. Historically, this is a tedious and error-prone task.</p>
</blockquote>
<p><strong>With asynchronous programming, operations that cannot complete immediately are suspended to the background</strong>，不能继续的任务，要被扔到后台。</p>
<p><strong>The thread is not blocked, and can continue running other things</strong>，底层线程不因此而阻塞，继续运行其它任务。</p>
<p><strong>Once the operation completes, the task is unsuspended and continues processing from where it left off</strong>，当被异步的操作完成后，被终止的任务恢复执行。</p>
<p>所以，“<strong>异步编程</strong>”和“<strong>异步</strong>”这两个概念是有所区别的，“<strong>异步</strong>”是一种特性，“<strong>异步编程</strong>”是基于此特性演化出的编程范式。</p>
<p>“异步”并不会使单个任务加速，Netpoller 和 Tokio 都是为了解决高并发网络 I&#x2F;O 而生的，并不会加速某个单一的任务，而是让多个任务在有限的 CPU资源下，跑出接近单个任务的响应时间，本质上是对 CPU 的充分利用。</p>
<p>在我看来，Tokio 口中异步编程的复杂性，完全来自于性能考量下的权衡，它解决的是高并发网络 I&#x2F;O 的问题，而不是并发的问题。不同的设计哲学，让它们在并发 CPU-bound 任务上走向了不同的目标。</p>
<p>我们看一个并发 CPU 的例子，此例中有 1 万个并发任务递归计算斐波那契数列。运行环境为 8 核，16G 内存，Manjaro Linux：</p>
<p><strong>Go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//runtime.GOMAXPROCS(24)</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">float64</span>, <span class="number">8</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	before := time.Now()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			_ = fib(<span class="number">40</span>)</span><br><span class="line">			el := time.Since(before).Seconds()</span><br><span class="line">			ch &lt;- el</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;耗时：%fs&quot;</span>, v)</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	elapsed := time.Since(before)</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	fmt.Println(elapsed, <span class="string">&quot;total,&quot;</span>, elapsed/<span class="number">10000</span>, <span class="string">&quot;avg per iteration&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>耗时区间：676 s ~ 814 s    总耗时：814s   平均耗时：81.4 ms </p>
</blockquote>
<p>再来看看 Tokio，依据 Tokio 官网建议，计算型任务使用<a target="_blank" rel="noopener" href="https://docs.rs/tokio/1.29.1/tokio/task/fn.spawn_blocking.html"><code>spawn_blocking</code></a> ，它会将任务派发到一个专门的线程池，根据并发任务的数量，这个线程池会增长到最多 500 个线程：</p>
<p><strong>Tokio</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"><span class="keyword">use</span> tokio::task;</span><br><span class="line"><span class="keyword">use</span> futures::future::&#123;<span class="keyword">self</span>, join_all&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read, Write&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10000</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tt</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        task::<span class="title function_ invoke__">spawn_blocking</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">fib</span>(<span class="number">40</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">duration</span> = start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dev_null</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;/dev/null&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            dev_null.<span class="title function_ invoke__">write</span>(&amp;r.<span class="title function_ invoke__">to_le_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            tt.<span class="title function_ invoke__">send</span>(duration.<span class="title function_ invoke__">as_secs_f64</span>() ).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="title function_ invoke__">drop</span>(tt);</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;耗时: &#123;:?&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">duration</span> = start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;总耗时: &#123;:?&#125;&quot;</span>, duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;平均耗时: &#123;:?&#125;&quot;</span>, duration / <span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fib</span>(n: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fib</span>(n - <span class="number">1</span>) + <span class="title function_ invoke__">fib</span>(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>耗时区间：0.6 s ~ 564 s    总耗时：564s   平均耗时：56.4 ms </p>
</blockquote>
<p>Tokio 建议使用 Rayon 来运行 CPU-bound 任务，我们再来看一下，Rayon 的版本：</p>
<p><strong>Rayon</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fib</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fib</span>(n - <span class="number">2</span>) + <span class="title function_ invoke__">fib</span>(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用rayon的并行迭代器来重复计算一万次</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">10000</span>];</span><br><span class="line">    results.<span class="title function_ invoke__">par_iter_mut</span>().for_each_with(tx,|tx,r| &#123;</span><br><span class="line">        *r = <span class="title function_ invoke__">fib</span>(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">duration</span> = start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tt</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        tt.<span class="title function_ invoke__">send</span>(duration.<span class="title function_ invoke__">as_secs_f64</span>() ).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(tt);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;耗时: &#123;:?&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">duration</span> = start.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;总耗时: &#123;:?&#125;&quot;</span>, duration);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;平均耗时: &#123;:?&#125;&quot;</span>, duration / <span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>耗时区间：0.00420079 s ~ 503 s    总耗时：507s   平均耗时：50 ms </p>
</blockquote>
<p>Rayon 默认只使用与 CPU 数量相同的线程来执行任务，执行效率反而比 Tokio 略好，Tokio 因为启动了大量的线程，导致我的电脑已无法正常响应键鼠了。</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>区间</th>
<th>总耗时</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>Go</td>
<td>676 s ~ 814 s</td>
<td>814 s</td>
<td>81.4 ms</td>
</tr>
<tr>
<td>Tokio</td>
<td>0.6 s ~ 564 s</td>
<td>564 s</td>
<td>56.4 ms</td>
</tr>
<tr>
<td>Rayon</td>
<td>0.00420079 s ~ 503 s</td>
<td>507 s</td>
<td>50 ms</td>
</tr>
</tbody></table>
<p>由于例子的特殊性，在总的执行时间上，Go 没有任何优势可言，因为 Go 和 Rust 的定位不同，性能也有差距，所以比较总耗时并没有意义。我们这里主要观察每个任务的耗时区间。</p>
<p>这里有意思的是 Go 的所有任务耗时趋向于“平均”，而 Rust 的两个框架是在每个线程上串行执行任务，任务耗时如同信号图标📶，由低到高渐进式增长。</p>
<p>所以，如果计算任务之间没有依赖，更看重总的响应时间的话，使用与 CPU 核数相当的线程池进行并行计算能得到最佳效果；如果任务是并发的，更加注重单个任务的响应时间，类似于 Go 的并发模型可能是更好的选择。本文所举的示例，每个任务的计算量相当，并不能体现 Go 的这一优势，不过可以想象一下：并发途中，一个计算量很小的任务加入队列，上述两种任务处理方式会给出不同的结果。</p>
<p>Go 是为并发而生的语言，所以你会发现，在编写 Go 代码的时候，你根本不用去考虑并发任务是计算型还是 I&#x2F;O 型的，在其并发模型下所有的任务都会尽可能得到及时的处理；而对于缺乏完善调度运行时的线程池来说，其注意事项就很多了，你要小心翼翼，不能在异步任务中写太多计算的代码。对此，甚至有博主指出：<a target="_blank" rel="noopener" href="https://ryhl.io/blog/async-what-is-blocking/">在进入<code>.await</code>之前，最好不要超过10 ~ 100 微秒</a>。</p>
<p>道理不难理解，以 Tokio 为例，虽然可以运行 CPU 密集型任务，但是官方很明确的说你要新开实例去运行，不要饿死 I&#x2F;O 任务，显然这是因为运行时缺乏调度能力的折中方案。CPU 密集型任务属于会阻塞 executor 线程的任务，容易霸占 CPU 而饿坏或者饿死其它任务，此时只能靠手动 yield 来让出 CPU，给其它任务以运行的机会；而网络 I&#x2F;O 之所以适合，完全是因为有非阻塞特性和 Reactor 的存在，每个 I&#x2F;O 读写点都是一次 yield 的机会！</p>
<p>不难想见的是，Tokio 虽然适合网络 I&#x2F;O 型并发，但是也要在 I&#x2F;O 任务里小心地控制计算型代码的时间，否则会导致运行时任务调度不均，从而长时间阻塞其它任务的运行。</p>
<p>是总的响应时间优先？还是每个任务的及时响应优先？这是一种选择和权衡！</p>
<p><strong>PS: 作为静态语言，Go 的性能真是差了 Rust 一大截，希望性能能再上一个台阶！</strong></p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly90b2tpby5ycy90b2tpby90dXRvcmlhbC9oZWxsby10b2tpbw==">Hello Tokio<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnJzL3Rva2lvL2xhdGVzdC90b2tpby9pbmRleC5odG1sI2NwdS1ib3VuZC10YXNrcy1hbmQtYmxvY2tpbmctY29kZQ==">CPU-bound tasks and blocking code<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yeWhsLmlvL2Jsb2cvYXN5bmMtd2hhdC1pcy1ibG9ja2luZy8=">Async: What is blocking?<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/06/28/golang/netpoller/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/28/golang/netpoller/" class="post-title-link" itemprop="url">异步 I/O 探秘 —— 为什么说 Go 为我们提供了同步的网络编程接口 ？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-28 20:08:30" itemprop="dateCreated datePublished" datetime="2023-06-28T20:08:30+08:00">2023-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文主要讲述了我对 I&#x2F;O 的一些理解，剖析了 Go 语言<code>netpoller</code>是如何结合 epoll 和 goroutine 的，文章还简单畅想了 io_uring 可能会带来的改变，并阐述了我对于异步编程的一点浅陋思考，希望能跟大家一起探讨。</p>
</blockquote>
<p>作为 Gopher，你想必听过<strong>“Go 为我们提供了同步的网络 I&#x2F;O 编程接口”</strong>，或者<strong>“Go 为我们提供了阻塞的网络 I&#x2F;O 编程接口”</strong>这样的表述。</p>
<p>那么，这样的表达有什么问题吗？</p>
<p>答案是：完全没问题！</p>
<p>这两句话所传达的事实是确凿无疑的，但前提是，你需要多思考一步：优异的网络框架不应该是同步的！</p>
<p>如果网络的读写都是同步的，就无法应对高并发、高吞吐的应用场景，二十多年前的计算机前辈们就提出了 <span class="exturl" data-url="aHR0cDovL3d3dy5rZWdlbC5jb20vYzEway5odG1s">C10K<i class="fa fa-external-link-alt"></i></span> 问题，也就是单机如何支持 1 万个并发连接的问题。</p>
<p>在 Linux 上， C10K 问题最终的解决方案是<strong>非阻塞 IO+epoll</strong> 的 <strong>I&#x2F;O 多路复用</strong>技术，且一直沿用至今。</p>
<p>所以，一门优秀的语言必须解决 C10K 问题。事实上，这里的“同步”仅仅是指 Go 提供的“编程接口”，而不是内在的网络模型。</p>
<p>但是，为什么一定要提供同步的编程接口呢？</p>
<p>人类生活在一个充满异步的世界里，许多事物和事件并行发生，而计算机的发展却是从同步开始的，汇编语言以及其它的低级语言为我们塑造了原始的同步编程模型，我们已经越来越习惯它了，这就导致异步编程成为一件复杂且困难的事。</p>
<p>因此，以高效的内在网络模型为内核，向外提供同步的用户编程接口，会成为解救程序员思维，让编程体验极度舒适的善举。</p>
<h2 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步"></a>为什么需要异步</h2><p>对异步的渴求，其实是源自于对高效率的渴望。</p>
<p>一切都因为 CPU 太快，I&#x2F;O 设备太慢，需要运行的任务太多。这是目前计算机所面临的现状。</p>
<p>然而，CPU 和 I&#x2F;O 设备是可以并行工作的。通过异步操作，CPU 可以在等待 I&#x2F;O 操作完成的同时继续执行其他指令，充分利用其计算能力。当 I&#x2F;O 操作完成时，CPU 会收到通知，并处理 I&#x2F;O 返回的结果，唤醒等待者。</p>
<p>可见，这种异步模型能极大地提高系统的吞吐量和响应能力，尤其在需要同时处理大量 I&#x2F;O 操作时，异步的优势相比同步会更加明显。</p>
<p>简单总结一下异步 I&#x2F;O 的优势，有如下两点：</p>
<ol>
<li><strong>能够在等待 I&#x2F;O 操作的同时执行其它任务，充分利用 CPU 的计算能力。</strong>换句话说，正在 CPU 上披荆斩棘的线程不会因为一次 I&#x2F;O 而停下脚步，在提交了 I&#x2F;O 申请之后可以去执行下一个任务，而执行下一个任务的能力是由并发模型决定的。</li>
<li><strong>最大限度地发挥 I&#x2F;O 设备的吞吐能力。</strong>当系统中存在大量并发的 I&#x2F;O 操作，或者有多个独立的任务可以并行处理时，异步 I&#x2F;O 能够提供更好的性能和资源利用率。</li>
</ol>
<p>最常见的文件 I&#x2F;O 和网络 I&#x2F;O 是最需要异步的，文件读写极有可能会遇到所读内容不在高速页缓存中的情况，此时需要等待慢速磁盘将内容读入内存；网络读写也无法永远保证 socket 缓冲区的就绪状态（读&#x2F;写系统调用发生时，缓冲区有内容可读与有空间可写）。等待这两种 I&#x2F;O 完成的代价实在太大，也就很有必要将其异步化——在 I&#x2F;O 设备工作的同时，让 CPU 去完成其它任务。</p>
<p>然而，需要留意的是：异步 I&#x2F;O 的效率提升主要取决于系统中存在的并行任务数量和性质。如果计算机只有少量任务且这些任务必须串行进行，那么异步 I&#x2F;O 可能不会带来明显的性能提升，因为任务之间无法并行执行。</p>
<h2 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h2><p><strong>同步、异步、阻塞、非阻塞</strong>这两对儿概念总是绕不过去的，同时也是无法轻易阐述明白的，本文无意做这种努力。<strong>软件领域并不存在一以贯之的概念，想要在概念上把软件行为掰扯清楚明白将注定徒劳无功。</strong></p>
<p>能够确定的是，在很多场景下，这两对概念可以描述同一件事情，比如，以电商系统中用户下单为例，对支付系统需不需要等待订单处理系统的反馈问题上，可以分为同步、异步或者阻塞、非阻塞两种情况。如果支付系统需要等待订单处理的结果，那么就可以说这个过程是同步的，或者说订单处理流程阻塞了用户下单；如果支付系统在用户支付后就向用户反馈结果，并将新生成的订单以消息事件的方式通知下游订单系统处理，就可以说这个过程是异步的，订单的处理是非阻塞的。</p>
<p>但事情并不总是这样，比如谈到网络 I&#x2F;O 时，这两对儿概念就不能等量齐观了。</p>
<p>每个 socket 连接都有两个缓冲区，一个用于发送，一个用于接收，当接收缓冲区为空，发送缓冲区满的时候，网络的读&#x2F;写就会阻塞，此时意味着线程会失去 CPU，应用发出的读&#x2F;写系统调用在内核代码路径中会触发进&#x2F;线程的调度，在缓冲区就绪之前，线程会被换下 CPU 进入被阻塞的等待状态。因此，当在系统调用、内核态等上下文中提到阻塞的时候，往往意味着进&#x2F;线程的切换，意味着有人失去 CPU，进而失去执行其它任务的机会。</p>
<p>同步就像是函数调用，一旦发出请求，就必须等到执行完成后返回，才能继续往下进行；异步则不然，发出请求后会立马返回，I&#x2F;O 操作会在未来某个时刻完成并通知请求者。这样看来，在网络 I&#x2F;O 这件事上，同步和阻塞的表达看上去没有什么区别，而非阻塞和异步就有些微妙了，这还要从非阻塞的功能意义上说起。</p>
<p><code>fnctl</code>系统调用可以通过<code>O_NONBLOCK</code>标志将文件设置为非阻塞，吊诡的是，这个非阻塞标志只对网络文件描述符起作用，对于普通的磁盘文件描述符是没有任何效果的。</p>
<p>这其实完全可以理解，文件并不像网络有一个缓冲区，文件流永远都是就绪的。那么，当网络文件描述符被设置为非阻塞之后会有什么样的表现呢？我们分别描述一个网络文件描述符在阻塞和非阻塞状态下<code>read</code>系统调用的过程。</p>
<p>假设应用基于这个文件描述符发出<code>read</code>系统调用的时候，socket 接收缓冲区为空（网络消息尚未到达）：</p>
<ol>
<li><strong>阻塞：</strong>当前的应用线程会因此被阻塞，进而被内核调离 CPU，当网络消息到达之后，缓冲区就绪，产生网络中断，内核获得 CPU 使用权，再次将应用线程换上 CPU ，<code>read</code>系统调用继续，CPU 将消息拷贝至用户空间，系统调用完成。</li>
<li><strong>非阻塞：</strong><code>read</code>系统调用会立即返回，并附带一个<code>EWOULDBLOCK</code>或者<code>EAGAIN</code>的错误，从错误含义就可以看出一些端倪，仿佛内核告诉你：“这次调用会造成阻塞，不过没关系，我发现你设置了非阻塞标志，我不会将你挂起，请你过一会儿再试吧！” 此时，应用就可以去做其它的任务，并在需要的时候重新发起<code>read</code>系统调用进行读取，缓冲区一旦就绪，CPU 就会将消息拷贝至用户空间。</li>
</ol>
<p>很明显的一点是，非阻塞调用除了通知应用缓冲区尚未就绪之外，没做其它的事情。应用需要不断地试探，在某一次碰巧赶上缓冲区就绪时，这次<code>read</code>系统调用才宣告成功，因此问题的关键是：<strong>应用在得知缓冲区就绪之前，不知道要发出多少系统调用来试探！</strong></p>
<p>而异步的网络 I&#x2F;O，除了会在系统调用发出后立即返回之外，还会在“后台”完成真正的 I&#x2F;O 操作，在这里就是将 socket 缓冲区中的内容拷贝至用户空间，并以某种方式通知应用，可见非阻塞和异步的区别还是很大的。</p>
<p>那么 Linux 平台提供异步 I&#x2F;O 的支持了吗？</p>
<p>简单说，有，但很难用，很多时候没法用！</p>
<p>POSIX 有对应的 <code>aio_read</code> 、<code>aio_write</code>等异步函数实现，但无奈太拉胯，性能奇差。</p>
<p>Linux 内核也有原生的异步 I&#x2F;O 支持，并冠以<code>AIO</code>之名，但限制很多，如只支持<code>O_DIRECT</code>访问、只支持特定设备、性能表现不佳等等，社区满意度极低，饱受诟病，我甚至找不到异步网络 I&#x2F;O 的例子，因此可以说，当前 Linux 只支持有限的文件异步 I&#x2F;O，不支持网络异步 I&#x2F;O（至少没有应用场景）。</p>
<p>要知道，在异步 I&#x2F;O 的概念出现之前，还有一种中间形态——IO 多路复用。</p>
<p>直到现在，IO 多路复用依然是 Linux 平台高并发网络的主流解决方案，以<code>epoll</code>为支点的事件循环结构铸就了当今互联网绝大多数网络程序的 <code>Reactor</code>模型。</p>
<h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p>我们可以用<strong>非阻塞+单线程或多线程</strong>的网络模型来处理大量网络连接，但是由于需要浪费 CPU 来试探缓冲区是否就绪，所以效率难免会大打折扣。</p>
<p>那么索性就让操作系统来通知我们就绪的网络文件描述符吧！这就是 I&#x2F;O 多路复用：应用只要阻塞在单个系统调用上，就可以监听多个网络文件描述符事件。</p>
<p>Linux 内核对 I&#x2F;O 多路复用支持的变迁史可简单描述为<code>select-&gt;poll-&gt;epoll</code>的改进路线 ，这三种方式原理大致相同，但性能越来越高。</p>
<p>我在读 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVy5fUmljaGFyZF9TdGV2ZW5z">Stevens<i class="fa fa-external-link-alt"></i></span> 先生的<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80MTE4NTc4Lw==">《UNIX网络编程》<i class="fa fa-external-link-alt"></i></span>时，常常奇怪：为什么书中只介绍了<code>select</code>和<code>poll</code>，却对<code>epoll</code>只字未提。后经求证，两部《UNIX网络编程》分别成书于 1990 年和 1999 年，<code>epoll</code>首次出现在 Linux 内核是在 2002 年。令人扼腕的是，Stevens 先生于 1999 年辞世，身后为我们留下了 7 部传世名著，其中就包括大家熟知的《TCP&#x2F;IP详解》三部曲。</p>
<p>让我们沿着伟人的叙述脉络，来看一看 I&#x2F;O 多路复用与其它 I&#x2F;O 模型的比较：</p>
<p><img data-src="https://qiniu.liupzmin.com/Comparison%20of%20the%20five%20IO%20models.png" alt="Comparison of the five IO models"></p>
<p>一次网络 I&#x2F;O 读取操作分成两个阶段：</p>
<p>（1）等待数据就绪 </p>
<p>（2）从内核空间拷贝数据到用户空间</p>
<p>可见，只有 <strong>blocking I&#x2F;O</strong> 和 <strong>asynchronous I&#x2F;O</strong> 能为请求者包揽两个阶段，其余的 I&#x2F;O 模型在第 1 阶段的表现各不相同，却在第 2 阶段表现一致，即均需要请求者主动完成。<strong>noblocking I&#x2F;O</strong> 为了探知数据是否就绪而空耗 CPU，这肯定是无法容忍的，于是内核出马，I&#x2F;O 多路复用诞生。</p>
<p>至于 <strong>blocking I&#x2F;O</strong> ，它是最简便的网络模型，用它来进行网络编程简洁却不高效，因为它会阻塞当前线程，引发线程切换，所以我们才会在寻求高效 I&#x2F;O 模型的道路上孜孜不倦。</p>
<p>图中有三种模型的第二阶段被标注为<code>blocked</code>，对此我有一点不同的看法，	当我们谈及系统调用的时候，阻塞通常意味着线程因工作无法继续而被调离 CPU，我们看上图中的 <strong>noblocking I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>和 <strong>signal-driven I&#x2F;O</strong> 三种模型，它们在第 1 阶段通过不同的方式得知数据已经就绪（<strong>noblocking I&#x2F;O</strong> 不是收到通知，而是通过撞运气），第 2 阶段发出系统调用开始读取数据，窃以为第 2 阶段并不存在阻塞，也并没有绝对的首恶元凶导致线程切换，这一阶段也就不应被称为“blocked”，如果非要用什么概念来描述一下的话，我愿用“同步”来称呼它。</p>
<p>事实上，Stevens 先生在讨论 asynchronous I&#x2F;O 的时候，确实将前面 4 种 I&#x2F;O 模型称为“同步 IO”，我认为这一说法成功把水搅浑了，特别是当 <strong>noblocking I&#x2F;O</strong> 和 <strong>I&#x2F;O 多路复用</strong>尚拥有一点“异步”特质的情况下，这往往让后来者很容易迷失在概念里。</p>
<p>正确的做法是：<strong>把概念丢掉，在内核和指令的维度去体认每一种 I&#x2F;O 模型</strong>。即便真的存在两个可以称之为“同步”、“异步”的明确概念，也大可不必将 noblocking I&#x2F;O、I&#x2F;O 多路复用和 signal-driven I&#x2F;O 套用其中。可以把它们看成一种中间形态，毕竟“同步”、“异步”的定语是修饰整个 I&#x2F;O 过程的，而非其中的某一步。</p>
<p><strong>非阻塞 I&#x2F;O 和 epoll</strong> 的组合或者说就是 I&#x2F;O 多路复用，是目前 Linux 平台主流的高并发网络解决方案，基本上所有的高性能网络框架或者服务器都是由此打造。然而每一项技术都不是独立存在的，也不应当被独立理解，Linux 为我们提供了 I&#x2F;O 多路复用这样一块积木，至于用这块积木能构建成怎样的世界，可能性似乎是无限的，Reactor 网络模型就是其中一例。</p>
<p>Reactor 是利用非阻塞 I&#x2F;O 和 epoll 构建的事件循环模型，是对 epoll 的抽象和封装，使得使用更加便捷，因为对事件分发，使用相应的 handler 来处理事件，非常像核反应堆，所以得名 Reactor。Reactor 的形式有多种多样，本文并不想去详细介绍个中细节，谈及 Reactor 仅仅是想说明：<strong>对于事物的理解，先要从一座森林理解一棵树，然后才能从一棵树理解整座森林。</strong></p>
<p>“<strong>异步编程</strong>”和“<strong>异步</strong>”这两个概念是有所区别的，“<strong>异步</strong>”是一种特性，“<strong>异步编程</strong>”是基于此特性演化出的编程范式。</p>
<p>在编程语言领域，我认为异步编程的终极形态是为上层开发者隐藏异步编程的复杂性，提供同步的编程接口。就像 Go 语言netpoller 那样，底层使用了目前最优秀的非阻塞和 epoll 模型构造的单线程 Reactor，上层为开发者呈现出简洁、直观的同步编程接口。</p>
<h2 id="netpoller"><a href="#netpoller" class="headerlink" title="netpoller"></a>netpoller</h2><p>在进入繁琐的<code>netpoller</code>源码之前，先来切身地体验一下 Go 的网络编程，相信下面的代码对每个 Gopher 来说都不陌生：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := conn.Read(buffer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error reading:&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		data := buffer[:n]</span><br><span class="line">		fmt.Println(<span class="string">&quot;Received data:&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码是使用<code>net</code>包编写的一个简单的网络 Server，其中<code>handleConnection</code>展示了如何读取 socket 中的内容，<code>n, err := conn.Read(buffer)</code>以同步阻塞的方式发出了<code>Read</code>请求，对于开发者来说一个读取操作就这样轻松完成了，简洁到无以复加！内里乾坤甚至是初学者根本不会去想的，这就是 Go 为开发者提供的网络编程接口，复古而优雅。</p>
<p>因为，根本不用担心 goroutine 所在的 M 线程被阻塞！</p>
<p>使用 epoll 进行网络程序的编写，需要三个步骤，分别是 <strong>epoll_create</strong>，<strong>epoll_ctl</strong> 和 <strong>epoll_wait</strong>。这三个 API 基本对应着 epoll 实例创建、增加监听描述符、poll 网络事件这三个动作，接下来我会就这三个动作来剖析一下 netpoller，此处参考 <code>go 1.18</code> 的源代码。</p>
<h3 id="epoll-初始化"><a href="#epoll-初始化" class="headerlink" title="epoll 初始化"></a>epoll 初始化</h3><p>netpoller 创建 epoll 实例的关键代码位于 <code>pollDesc</code> 这个结构体的 <code>init</code> 方法中：</p>
<p><strong>internal&#x2F;poll&#x2F;fd_poll_runtime.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	runtimeCtx <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverInit sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">	serverInit.Do(runtime_pollServerInit)</span><br><span class="line">	ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">	&#125;</span><br><span class="line">	pd.runtimeCtx = ctx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll.pollDesc 是 poll.FD 中的一个字段，poll.FD 表示文件描述符，os 包和 net 包都包含它来组成上层意义的<strong>网络连接</strong>和 <strong>OS 文件</strong>。poll.FD 的 Init 方法会调用 poll.pollDesc.init 来初始化 epoll 实例，初始化函数<code>runtime_pollServerInit</code>是个单例模式，也就是说，epoll 实例会在程序创建第一个文件描述符时被创建。我们看一下<code>runtime_pollServerInit</code>：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	netpollGenericInit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll_runtime_pollServerInit 是一个未导出的方法，此处将其链接成了<code>internal/poll.runtime_pollServerInit</code>，因此可以在 internal&#x2F;poll 包里直接调用。<code>netpollGenericInit</code>调用了<code>netpollinit</code>，<code>netpollinit</code>使用<code>epoll_create</code>来创建 epoll 实例：</p>
<p><strong>runtime&#x2F;netpoll_epoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">	<span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line">		<span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, -epfd)</span><br><span class="line">			throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		closeonexec(epfd)</span><br><span class="line">	&#125;</span><br><span class="line">	r, w, errno := nonblockingPipe()</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;runtime: pipe failed with&quot;</span>, -errno)</span><br><span class="line">		throw(<span class="string">&quot;runtime: pipe failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	ev := epollevent&#123;</span><br><span class="line">		events: _EPOLLIN,</span><br><span class="line">	&#125;</span><br><span class="line">	*(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">	errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, -errno)</span><br><span class="line">		throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	netpollBreakRd = <span class="type">uintptr</span>(r)</span><br><span class="line">	netpollBreakWr = <span class="type">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>epfd</code> 是 epoll 实例的文件描述符，它是一个全局变量，后续会作为 <code>epoll_ctl</code> 和 <code>epoll_wait</code> 系统调用的参数被传入。在创建完 epoll 实例之后，紧接着使用<code>epoll_ctl</code>加入了一个非阻塞的管道描述符，这里主要用于唤醒阻塞在 epoll_wait 上的 poll 线程。</p>
<p>这是可以理解的，毕竟 polling 事件的线程还有其它任务，如果待监听的描述符长时间无事件发生，不可能让线程一直阻塞下去。其实这个线程就是<code>sysmon</code>线程，一个不需要 P 即可运行的操作系统线程，稍后会介绍 <code>sysmon</code> 线程如何 polling 网络事件。</p>
<h3 id="向-epoll-实例注册描述符"><a href="#向-epoll-实例注册描述符" class="headerlink" title="向 epoll 实例注册描述符"></a>向 epoll 实例注册描述符</h3><p>随着 epoll 实例的成功创建，接下来就可以使用<code>epoll_ctl</code>系统调用向其中添加感兴趣的文件描述符了，最终会使用<code>epoll_wait</code>来收取这些网络文件描述符上的网络事件，我们这里主要聚焦于描述符的注册之上。</p>
<p>Go 网络编程中涉及到向 netpoller 注册描述符的行为大致有<code>Listen</code>、<code>Connect</code>、<code>Accept</code>三类，为避免繁琐的代码，此处我以 TCP 为例，仅列出函数调用路径，至 <code>epoll_ctl</code>为止。</p>
<ul>
<li>服务端 Accept 连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.TCPListener</span><br><span class="line">    ---&gt;net.TCPListener.Accept</span><br><span class="line">        ---&gt;net.TCPListener.accept</span><br><span class="line">            ---&gt;net.netFD.accept</span><br><span class="line">                ----&gt;net.netFD.init</span><br><span class="line">                    -----&gt;poll.FD.Init</span><br><span class="line">                        ------&gt;poll.pollDesc.init</span><br><span class="line">                            -------&gt;poll.runtime_pollOpen</span><br><span class="line">                                --------&gt;runtime.netpollopen</span><br><span class="line">                                    ---------&gt;epollctl</span><br></pre></td></tr></table></figure>

<p>这里值得一提的是，net.netFD.accept 调用 poll.FD.Accept， 进而调用 accept4 系统调用，将文件描述符设置为非阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrapper around the accept system call that marks the returned file</span></span><br><span class="line"><span class="comment">// descriptor as nonblocking and close-on-exec.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accept</span><span class="params">(s <span class="type">int</span>)</span></span> (<span class="type">int</span>, syscall.Sockaddr, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	ns, sa, err := Accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, sa, <span class="string">&quot;accept4&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ns, sa, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端监听</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net.ListenTCP</span><br><span class="line">    ---&gt;net.sysListener.listenTCP</span><br><span class="line">        ---&gt;net.internetSocket</span><br><span class="line">            ---&gt;net.socket</span><br><span class="line">                ----&gt;net.netFD.dial</span><br><span class="line">                    -----&gt;net.netFD.init</span><br><span class="line">                        ------&gt;poll.FD.Init</span><br><span class="line">                            -------&gt;poll.pollDesc.init</span><br><span class="line">                                --------&gt;poll.runtime_pollOpen</span><br><span class="line">                                    ---------&gt;runtime.netpollopen</span><br><span class="line">                                        ---------&gt;epollctl</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端拨号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">net.Dial</span><br><span class="line">    ---&gt;net.Dialer.Dial</span><br><span class="line">        ---&gt;net.Dialer.DialContext</span><br><span class="line">            ----&gt;net.sysDialer.dialSerial</span><br><span class="line">                -----&gt;net.sysDialer.dialSingle</span><br><span class="line">                    ------&gt;net.sysDialer.dialTCP</span><br><span class="line">                        -------&gt;net.sysDialer.doDialTCP</span><br><span class="line">                            --------&gt;net.internetSocket</span><br><span class="line">                                ---------&gt;net.socket</span><br><span class="line">                                    ----------&gt;net.netFD.dial</span><br><span class="line">                                        -----------&gt;net.netFD.connect</span><br><span class="line">                                            ------------&gt;poll.FD.Init</span><br><span class="line">                                                -------------&gt;poll.pollDesc.init</span><br><span class="line">                                                    --------------&gt;poll.runtime_pollOpen</span><br><span class="line">                                                        ---------------&gt;runtime.netpollopen</span><br><span class="line">                                                            ----------------&gt;epollctl</span><br></pre></td></tr></table></figure>

<p>三类操作最终都会调用 <code>runtime.netpollopen</code>，此函数会发出<code>epoll_ctl</code>调用，将<code>fd</code>与事件<code>_EPOLLIN、_EPOLLOUT 、_EPOLLRDHUP 、_EPOLLET</code>注册进 epoll 实例，并设置为边缘触发。</p>
<p><strong>runtime&#x2F;netpoll_epoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev epollevent</span><br><span class="line">	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">	<span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9lcG9sbF9jdGwuMi5odG1s">epoll_ctl<i class="fa fa-external-link-alt"></i></span> 有一个参数<code>event</code>，是和文件描述符关联的一个对象，在 go 源码中名为<code>epollevent</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> epollevent <span class="keyword">struct</span> &#123;</span><br><span class="line">	events <span class="type">uint32</span></span><br><span class="line">	data   [<span class="number">8</span>]<span class="type">byte</span> <span class="comment">// unaligned uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>data</code>是用户设置的，kernel 必须保存它并在文件描述符就绪时（通过 epoll_wait 调用）一并返回。此处，<code>ev.data</code>被设置为<code>pollDesc</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br></pre></td></tr></table></figure>

<p>每个网络文件描述符都会对应一个<code>pollDesc</code>，<code>pollDesc</code>是 Network poller descriptor，它控制着文件描述符的状态以及在该文件描述符上产生等待的 goroutine 的地址。</p>
<p>也就是说，当<code>epoll_wait</code>返回时，从就绪的<code>ev.data</code>中可以拿到等待读写的 goroutine 地址，我们接下来将详细剖析这个过程。</p>
<h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p><code>epoll_wait</code>的调用是由函数<code>netpoll</code>发出的，它会检查就绪的文件描述符，并且返回相关的 goroutine 列表，由此可见 netpoller 的事件分发特点：<strong>与 goroutine 紧密结合，将可读写的网络文件描述符转化为可运行的 goroutine，然后注入相关的运行队列，最终由调度器接管并伺机运行。</strong></p>
<p><strong>runtime&#x2F;netpoll_epoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netpoll checks for ready network connections.</span></span><br><span class="line"><span class="comment">// Returns list of goroutines that become runnable.</span></span><br><span class="line"><span class="comment">// delay &lt; 0: blocks indefinitely</span></span><br><span class="line"><span class="comment">// delay == 0: does not block, just polls</span></span><br><span class="line"><span class="comment">// delay &gt; 0: block for up to that many nanoseconds</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> gList &#123;</span><br><span class="line">	<span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">	<span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">		waitms = <span class="number">-1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;</span><br><span class="line">		waitms = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;</span><br><span class="line">		waitms = <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;</span><br><span class="line">		waitms = <span class="type">int32</span>(delay / <span class="number">1e6</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// An arbitrary cap on how long to wait for a timer.</span></span><br><span class="line">		<span class="comment">// 1e9 ms == ~11.5 days.</span></span><br><span class="line">		waitms = <span class="number">1e9</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 准备 epollevent 数组，最多 poll 128个事件</span></span><br><span class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// 发出 epoll_wait 调用</span></span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// toRun 是个 goroutine 链表，表示文件描述符已就绪，可以被调度运行的 goroutine</span></span><br><span class="line">	<span class="keyword">var</span> toRun gList</span><br><span class="line">	<span class="comment">// 遍历本次 epoll_wait 返回的就绪事件</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">		<span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 从 ev.data 中取出 pollDesc</span></span><br><span class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			pd.setEventErr(ev.events == _EPOLLERR)</span><br><span class="line">			<span class="comment">// 获取相关 goroutine 并插入到 toRun 链表</span></span><br><span class="line">			netpollready(&amp;toRun, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netpoll</code> 并不像我们平时看到的 epoll 使用案例那样使用一个死循环来无限地<code>epoll_wait</code>，事实上它只<code>epoll_wait</code>一次，无限循环调用的任务放在了<code>sysmon</code>中，我们稍后会看到，现在将注意力放在如何将事件转化为对应的 goroutine 上。</p>
<p>从代码中可以看出，<code>netpollready</code> 会获取相关 goroutine 并插入到 <strong>toRun</strong> 链表：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netpollready is called by the platform-specific netpoll function.</span></span><br><span class="line"><span class="comment">// It declares that the fd associated with pd is ready for I/O.</span></span><br><span class="line"><span class="comment">// The toRun argument is used to build a list of goroutines to return</span></span><br><span class="line"><span class="comment">// from netpoll. The mode argument is &#x27;r&#x27;, &#x27;w&#x27;, or &#x27;r&#x27;+&#x27;w&#x27; to indicate</span></span><br><span class="line"><span class="comment">// whether the fd is ready for reading or writing or both.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This may run while the world is stopped, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取等待读操作的 g</span></span><br><span class="line">		rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取等待写操作的 g</span></span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 将等待读操作的 g 插入链表</span></span><br><span class="line">		toRun.push(rg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 将等待写操作的 g 插入链表</span></span><br><span class="line">		toRun.push(wg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里交代一下 <strong>pollDesc</strong> 中的 <strong>rg，wg</strong> 字段，这两个字段就是控制描述符状态和相关 goroutine 地址的关键，它的定义如下：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// rg, wg are accessed atomically and hold g pointers.</span></span><br><span class="line">	<span class="comment">// (Using atomic.Uintptr here is similar to using guintptr elsewhere.)</span></span><br><span class="line">	rg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for read or nil</span></span><br><span class="line">	wg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for write or nil</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>rg</strong> 和 <strong>wg</strong> 都是原子类型，里面可能存放的内容为：<strong>pdReady, pdWait, G waiting for read or nil</strong>，<code>G</code> 就是 goroutine 的地址，我们继续沿着调用向下看：</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollunblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, ioready <span class="type">bool</span>)</span></span> *g &#123;</span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		old := gpp.Load()</span><br><span class="line">		<span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; !ioready &#123;</span><br><span class="line">			<span class="comment">// Only set pdReady for ioready. runtime_pollWait</span></span><br><span class="line">			<span class="comment">// will check for timeout/cancel before waiting.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> <span class="built_in">new</span> <span class="type">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> ioready &#123;</span><br><span class="line">			<span class="built_in">new</span> = pdReady</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 gpp 设置为 pdReady</span></span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old == pdWait &#123;</span><br><span class="line">				<span class="comment">// 如果设置为0，则 (*g)(unsafe.Pointer(old)) 为 nil</span></span><br><span class="line">				old = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将 old 的值转换为 *g 返回，old 通常就是发生等待的 goroutine 地址</span></span><br><span class="line">			<span class="keyword">return</span> (*g)(unsafe.Pointer(old))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 <code>*g</code> 之后，就可以插入<code>toRun</code>链表了：</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A gList is a list of Gs linked through g.schedlink. A G can only be</span></span><br><span class="line"><span class="comment">// on one gQueue or gList at a time.</span></span><br><span class="line"><span class="keyword">type</span> gList <span class="keyword">struct</span> &#123;</span><br><span class="line">	head guintptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push adds gp to the head of l.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *gList)</span></span> push(gp *g) &#123;</span><br><span class="line">	gp.schedlink = l.head</span><br><span class="line">	l.head.set(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toRun</code>是<code>gList</code>类型，<code>gList</code>是一个靠<code>g.schedlink</code>串联起来的单链表。</p>
<p>是时候看看<code>netpoll</code>的调用者如何处理这些 goroutine 链表了，前面说过这个工作是<code>sysmon</code>来完成的，<code>sysmon</code>会在单独的操作系统线程中运行，看一下其创建过程：</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> GOARCH != <span class="string">&quot;wasm&quot;</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sysmon</code>的功能很多，我们这里只看它如何 polling network：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">		lastpoll := <span class="type">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="type">uint64</span>(lastpoll), <span class="type">uint64</span>(now))</span><br><span class="line">			list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">				<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">				<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">				<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">				<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">				<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">				<span class="comment">// and reports deadlock.</span></span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果距离上次 polling 过了 10ms，那么就再次发出 polling，如果结果不为空，则调用 <code>injectglist</code>，而 <code>injectglist</code> 会将结果链表中的 goroutine 的状态修改为<code>runnable</code>后放入本地或全局队列，后面就是调度器接手了，此处不再赘述。</p>
<h3 id="goroutine-的停泊与-pollDesc"><a href="#goroutine-的停泊与-pollDesc" class="headerlink" title="goroutine 的停泊与 pollDesc"></a>goroutine 的停泊与 pollDesc</h3><p>上面介绍了网络事件如何转换为对应的 goroutine ，这个过程依靠的关键是<code>pollDesc</code>中的 rg 和 wg，但是 rg 和 wg 是在何时设置为当前 goroutine 的地址的呢？当 socket 缓冲区未就绪时，一个<code>Read</code>调用将会发生什么呢？</p>
<p>其实，只要稍加思索就会明白，这两个问题极具相关性。Go 中的网络连接是线程安全的，允许多个 goroutine 同时发出读写操作，而 pollDesc 只有一个 rg 和 wg，因此多个 goroutine 读写必定是用锁来串行化的，rg 和 wg 也必然是在读写遭遇阻塞时设置的。事实上，我也正是从这个思路出发，在源码中找到关键所在的。</p>
<p>让我们从一个<code>Read</code>调用开始，看看其内在端倪。</p>
<p>以 TCP 的读取为例，沿着 <code>conn</code> 的 <code>Read</code> 接口调用路径<code>net.netFD.Read---&gt;poll.FD.Read</code>，可以定位到<code>poll.FD.Read</code>:</p>
<p><strong>internal&#x2F;poll&#x2F;fd_unix.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements io.Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := fd.readLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fd.readUnlock()</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fd.IsStream &amp;&amp; <span class="built_in">len</span>(p) &gt; maxRW &#123;</span><br><span class="line">		p = p[:maxRW]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 发出 Read 系统调用</span></span><br><span class="line">		n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			n = <span class="number">0</span></span><br><span class="line">			<span class="comment">// 如果 收到 EAGAIN 错误，且文件描述符是可 poll 的，则进入等待</span></span><br><span class="line">			<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		err = fd.eofError(n, err)</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 socket 缓冲区未就绪，读取一个非阻塞的网络文件描述符时会返回<code>EAGAIN</code>或者<code>EWOULDBLOCK</code>错误，紧接着调用链<code>runtime.pollDesc.waitRead---&gt;runtime.pollDesc.wait---&gt;poll.runtime_pollWait---&gt;runtime.netpollblock</code>会触发调度，将当前 goroutine 换下 CPU，寻找一个新的 goroutine 来运行。</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns true if IO is ready, or false if timedout or closed</span></span><br><span class="line"><span class="comment">// waitio - wait only for completed IO, ignore errors</span></span><br><span class="line"><span class="comment">// Concurrent calls to netpollblock in the same mode are forbidden, as pollDesc</span></span><br><span class="line"><span class="comment">// can hold only a single waiting goroutine for each mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set the gpp semaphore to pdWait</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Consume notification if already ready.</span></span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(pdReady, <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> gpp.CompareAndSwap(<span class="number">0</span>, pdWait) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Double check that this isn&#x27;t corrupt; otherwise we&#x27;d loop</span></span><br><span class="line">		<span class="comment">// forever.</span></span><br><span class="line">		<span class="keyword">if</span> v := gpp.Load(); v != pdReady &amp;&amp; v != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;runtime: double wait&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// need to recheck error states after setting gpp to pdWait</span></span><br><span class="line">	<span class="comment">// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl</span></span><br><span class="line">	<span class="comment">// do the opposite: store to closing/rd/wd, publishInfo, load of rg/wg</span></span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError &#123;</span><br><span class="line">		<span class="comment">// 开启 park 流程，休眠当前 goroutine</span></span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// be careful to not lose concurrent pdReady notification</span></span><br><span class="line">	old := gpp.Swap(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: corrupted polldesc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netpollblock</code>会将<code>pollDesc</code>中的 rg 或 wg 设置为<code>pdWait</code>，然后调用<code>gopark</code>将当前 goroutine 休眠，进入<code>schedule</code>流程挑选新的 goroutine 来运行。</p>
<p><code>gopark</code>的调用在一个<code>if</code>判断里，按目前的代码只要<code>netpollcheckerr</code>没有错误发生，就会调用<code>gopark</code>，因此我觉得<code>waitio</code>特别是像为真正的异步 I&#x2F;O 预留的接口，以备向后兼容。</p>
<p>请记住传入<code>gopark</code>的前两个参数：<code>netpollblockcommit</code>和<code>unsafe.Pointer(gpp)</code>，然后再来看<code>gopark</code>中的相关内容：</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Puts the current goroutine into a waiting state and calls unlockf on the</span></span><br><span class="line"><span class="comment">// system stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If unlockf returns false, the goroutine is resumed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// unlockf must not access this G&#x27;s stack, as it may be moved between</span></span><br><span class="line"><span class="comment">// the call to gopark and the call to unlockf.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that because unlockf is called after putting the G into a waiting</span></span><br><span class="line"><span class="comment">// state, the G may have already been readied by the time unlockf is called</span></span><br><span class="line"><span class="comment">// unless there is external synchronization preventing the G from being</span></span><br><span class="line"><span class="comment">// readied. If unlockf returns false, it must guarantee that the G cannot be</span></span><br><span class="line"><span class="comment">// externally readied.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reason explains why the goroutine has been parked. It is displayed in stack</span></span><br><span class="line"><span class="comment">// traces and heap dumps. Reasons should be unique and descriptive. Do not</span></span><br><span class="line"><span class="comment">// re-use reasons, add new ones.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="type">bool</span>, lock unsafe.Pointer, reason waitReason, traceEv <span class="type">byte</span>, traceskip <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">		checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时 lock 是 gpp(pollDesc 中的 rg)</span></span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	<span class="comment">// 此时 unlockf 是 netpollblockcommit</span></span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gopark</code>会获取当前所在的<code>m</code>，并将函数<code>netpollblockcommit</code>和<code>unsafe.Pointer(gpp)</code>（<strong>pollDesc</strong> 中的 <strong>rg</strong>）分别赋值给<code>mp.waitlock</code>和<code>mp.waitunlockf</code>，接下来进入<code>mcall(park_m)</code>的调用，<code>mcall</code> 是个汇编函数，它会调用传参中的函数且不再返回，我们看一下<code>mcall</code>的内容，明确一下将要传给函数<code>park_m</code>的参数：</p>
<p><strong>runtime&#x2F;asm_amd64.s</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// func mcall(fn func(*g))</span><br><span class="line">// Switch to m-&gt;g0&#x27;s stack, call fn(g).</span><br><span class="line">// Fn must never return. It should gogo(&amp;g-&gt;sched)</span><br><span class="line">// to keep running g.</span><br><span class="line">TEXT runtime·mcall&lt;ABIInternal&gt;(SB), NOSPLIT, $0-8</span><br><span class="line">	MOVQ	AX, DX	// DX = fn</span><br><span class="line"></span><br><span class="line">	// save state in g-&gt;sched</span><br><span class="line">	// 下面这 5 行指令是保存当前 goroutine 的状态到 g-&gt;sched </span><br><span class="line">	MOVQ	0(SP), BX	// caller&#x27;s PC</span><br><span class="line">	MOVQ	BX, (g_sched+gobuf_pc)(R14)</span><br><span class="line">	LEAQ	fn+0(FP), BX	// caller&#x27;s SP</span><br><span class="line">	MOVQ	BX, (g_sched+gobuf_sp)(R14)</span><br><span class="line">	MOVQ	BP, (g_sched+gobuf_bp)(R14)</span><br><span class="line"></span><br><span class="line">	// switch to m-&gt;g0 &amp; its stack, call fn</span><br><span class="line">	// 准备切换到 g0 及其堆栈</span><br><span class="line">	MOVQ	g_m(R14), BX    // 通过 R14 拿到当前的 m</span><br><span class="line">	MOVQ	m_g0(BX), SI	// SI = g.m.g0 通过 m 拿到 m 的 g0</span><br><span class="line">	CMPQ	SI, R14	// if g == m-&gt;g0 call badmcall</span><br><span class="line">	JNE	goodm</span><br><span class="line">	JMP	runtime·badmcall(SB)</span><br><span class="line">goodm:</span><br><span class="line">	MOVQ	R14, AX		// AX (and arg 0) = g 把当前 goroutine 地址放入 AX</span><br><span class="line">	MOVQ	SI, R14		// g = g.m.g0  SI 是 g.m.g0，这一句将 goroutine 切换到 g0</span><br><span class="line">	get_tls(CX)		// Set G in TLS</span><br><span class="line">	MOVQ	R14, g(CX)  // 设置 g0 到线程本地存储</span><br><span class="line">	MOVQ	(g_sched+gobuf_sp)(R14), SP	// sp = g0.sched.sp 切换到 g0 堆栈</span><br><span class="line">	PUSHQ	AX	// open up space for fn&#x27;s arg spill slot</span><br><span class="line">	MOVQ	0(DX), R12</span><br><span class="line">	CALL	R12		// fn(g)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	JMP	runtime·badmcall2(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p>根据<span class="exturl" data-url="aHR0cHM6Ly9nby5nb29nbGVzb3VyY2UuY29tL2dvLysvcmVmcy9oZWFkcy9kZXYucmVnYWJpL3NyYy9jbWQvY29tcGlsZS9pbnRlcm5hbC1hYmkubWQ=">Go internal ABI specification<i class="fa fa-external-link-alt"></i></span>的描述，<code>amd64</code>平台下整型参数传递依次使用如下寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAX, RBX, RCX, RDI, RSI, R8, R9, R10, R11</span><br></pre></td></tr></table></figure>

<p>这里有一个知识点：<strong>R14 寄存器存放当前 goroutine 的地址</strong>，可以从汇编代码中看到<code>mcall</code>是如何利用 R14 寄存器切换到 g0 的。</p>
<p><code>mcall</code>的主要工作就是保存当前 goroutine 的状态，切换到 g0 堆栈并执行传入的函数<code>fn</code>，这里即将执行<code>park_m</code>。</p>
<p><code>MOVQ	R14, AX		// AX (and arg 0) = g</code>这一句将当前 g 的地址存入 AX 寄存器，并在接下来<code>CALL	R12		// fn(g)</code>的时候，充当第一个参数。</p>
<p>接下来进入<code>park_m</code>:</p>
<p><strong>runtime&#x2F;proc.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// park continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 调用 netpollblockcommit</span></span><br><span class="line">		ok := fn(gp, _g_.m.waitlock)</span><br><span class="line">		_g_.m.waitunlockf = <span class="literal">nil</span></span><br><span class="line">		_g_.m.waitlock = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			execute(gp, <span class="literal">true</span>) <span class="comment">// Schedule it back, never returns.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 进入调度循环，不再返回</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，参数<code>gp</code>是发出<code>Read</code>系统调用的 goroutine 地址，在进入<code>schedule()</code>调度循环之前，我们仅关注<code>ok := fn(gp, _g_.m.waitlock)</code>这一句，<code>gopark</code>函数已经将<code>netpollblockcommit</code>和<code>unsafe.Pointer(gpp)</code>（pollDesc 中的 rg）分别赋给了<code>mp.waitlock</code>和<code>mp.waitunlockf</code>，所以这里的调用实际上是<code>netpollblockcommit(gp, unsafe.Pointer(gpp))</code>。</p>
<p>不知道你有没有好奇，挂起的明明是当前的 goroutine，为什么函数的名字是<code>park_m</code>呢？这里的<code>m</code>显然就是 GMP 中的线程 M 啊，我是这样理解的：M 就像是一列高速运行的汽车，乘客是<code>goroutine</code>，当某个乘客因某些原因不能继续乘坐时，M 需要停下来让乘客下车，然后再开动去寻找下一位乘客，所以这个挂起 goroutine 的过程就像是 M 停泊了一样。</p>
<p>但为了叙述方便，我还是称 goroutine 停泊好了，毕竟比喻并不十分恰当，从指令角度看 M 可是一路狂奔从未停过，只是从代码所有权角度来看， M 确实是换了一位乘客。</p>
<p><strong>runtime&#x2F;netpoll.go</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	r := atomic.Casuintptr((*<span class="type">uintptr</span>)(gpp), pdWait, <span class="type">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line">	<span class="keyword">if</span> r &#123;</span><br><span class="line">		<span class="comment">// Bump the count of goroutines waiting for the poller.</span></span><br><span class="line">		<span class="comment">// The scheduler uses this to decide whether to block</span></span><br><span class="line">		<span class="comment">// waiting for the poller if there is nothing else to do.</span></span><br><span class="line">		atomic.Xadd(&amp;netpollWaiters, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>atomic.Casuintptr((*uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))</code>将<code>rg</code>的值更新为<strong>发出<code>Read 调用的 goroutine</code>地址</strong>。</p>
<p>至此，两件重要的事情已经完成：</p>
<ol>
<li>休眠发出<code>Read</code> 调用的 goroutine。</li>
<li>设置与该<code>goroutine</code>感兴趣的文件描述符相关的<code>pollDesc.rg</code>为该 <code>goroutine</code> 的地址，以便后续<code>polling</code>时促成网络事件向<code>goroutine</code>链表的转化。</li>
</ol>
<p>这种模型的好处是非常节省 M，M 在 Go 的 GMP 并发模型中代表操作系统线程，因为网络 I&#x2F;O 非阻塞的特性，M 会从系统调用中立即返回，不会因为数据未就绪而被内核剥离 CPU，M 当然就可以挂起当前 goroutine，转而去寻找其它的 goroutine 来运行。</p>
<p>反观文件 I&#x2F;O 则不然，文件 I&#x2F;O 没有异步和非阻塞特性（不考虑臭名昭著的AIO），当 M 因为系统调用陷入内核时，如果要读取的内容不在页高速缓存中，就会触发缺页处理，内核需要向磁盘发出 I&#x2F;O 请求，因为这个过程不是异步的，内核会将 M 剥离，调度其它线程来运行。可想而知，此时此刻 go runtime 只能新建 M 来匹配 P，新建的 M 需要加入内核运行队列，等待内核调度，经过这样一番折腾，吞吐自然就下来了。</p>
<p>更可怕的是如果有大量 I&#x2F;O 请求，势必会让更多的 M 陷入内核无法自拔，go runtime 除了创建更多的 M 之外别无良策，在这种情况下仍不断地创建 M 无异于扬汤止沸，如果 M 的数量超过 1 万，程序就 panic 了。</p>
<p>所以，<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZVhSQnowbEFIQW9kWFc5TlZsaXlPZw==">go 并不适合文件 io 密集型任务<i class="fa fa-external-link-alt"></i></span>，除非有真正的异步 I&#x2F;O，使得文件也可以享用 Reactor 的好处。</p>
<p>本质上， netpoller 使用非阻塞I&#x2F;O和<code>epoll</code>模型构建的是一个单线程的<code>Reactor</code>，即便如此，也已经可以满足绝大多数的场景需求，可以说这套模型是 Linux 平台的最佳、最高效的解决方案。然而实在是拗不过<strong>非阻塞I&#x2F;O 和 epoll</strong>这对组合有一些不那么“同步”的特性，以讹传讹间，不少不明就里的人就把这种模型称为异步 I&#x2F;O 了。</p>
<p>直到 2019 年 <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmcucGRm">io_uring<i class="fa fa-external-link-alt"></i></span> 横空出世，Linux 异步世界才终于迎来了一丝曙光！</p>
<h2 id="下一代异步-I-O"><a href="#下一代异步-I-O" class="headerlink" title="下一代异步 I&#x2F;O"></a>下一代异步 I&#x2F;O</h2><p>io_uring 由 Jens Axboe 提出和实现，并于 2019 年 5 月随 Linux 5.1 发布。io_uring 是 Linux 内核引入的新型异步 I&#x2F;O 框架，旨在改善 AIO 的性能和可扩展性，社区称<strong>“io_uring can change everything”</strong>。本文不准备对其做过多介绍，感兴趣的朋友可以参考 <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmcucGRm">Efficient IO with io_uring<i class="fa fa-external-link-alt"></i></span> 这篇文章。这里仅从系统调用的角度来谈一谈 io_uring 可能为上层带来的变化。</p>
<ul>
<li><p>网络 I&#x2F;O</p>
<p>以非阻塞 I&#x2F;O 和<code>epoll</code>为蓝本的 Reactor 在收到网络事件之后，仍然需要主动发起一次系统调用去读取 socket 的内容，在 io_uring 下就没有这一步系统调用了，当等待者被唤醒以后，数据就已经在手边了。不过，要适配 io_uring 还需要不少工作要做，比如 go 的 netpoller 就需要对 runtime 做改造适配，当然适配完成后的网络模型就不是 Reactor 了，而是 Proactor，当然了，叫什么并不重要，重要的是它怎么干这件事。</p>
</li>
<li><p>文件 I&#x2F;O</p>
<p>前面讨论过，Reactor 并不能拯救文件 I&#x2F;O，Go 运行时甚至会出现“卡线程”的情况。但是，io_uring 完美解决了这一痛点，不像它的前任 AIO 每次追加请求以及获取结果都要发起一次系统调用，io_uring 实现了用户空间和内核空间的内存无锁共享，很多很多的系统调用被节省了，所有 I&#x2F;O 全都可以交给专门的线程负责，这就是 Proactor。</p>
<p>如果 Go runtime 适配了 io_uring 会怎样？届时意味着“卡线程”成为历史，Go 不仅适合网络密集型I&#x2F;O，也会适合文件密集型I&#x2F;O 。</p>
</li>
</ul>
<p>事实上，Go 社区已经在讨论适配的可能性了（见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMzE5MDg=">#31908<i class="fa fa-external-link-alt"></i></span>），进展算不上快，但未来可期！</p>
<h2 id="再论异步编程模型"><a href="#再论异步编程模型" class="headerlink" title="再论异步编程模型"></a>再论异步编程模型</h2><p>直接进行异步编程是复杂且困难的，你需要设计专门的模块统一处理 I&#x2F;O 请求，并且具备唤醒机制，即便这些问题得到了完美解决，你也会发现你创造了另一个 Reactor 或者 Proactor。但如果不做这些，异步就无法发挥作用。试想一下，一个任务发出异步请求之后，请求立即返回了，那么任务本身该何去何从呢？没有 I&#x2F;O 的结果 任务就无法推进，这个时候就要有将任务 Park 的能力了。</p>
<p>由此可见，异步编程其实是考验并发模型的，也就是分解任务的能力，如果一门编程语言只能以线程来分解任务，那么使用异步的代价就会增加，这个问题的解决方案就是协程，如果编程语言实现了协程，那么任务分解的粒度变为协程，则更能有效的利用异步 I&#x2F;O 带来的优势。</p>
<p>Go 就是这种玩法，非阻塞和异步都可以拿来和协程相配合，思路非常容易理解。Rust 的异步运行时也有协程的概念，走的是状态机路线（<a href="https://liupzmin.com/2023/06/08/network/talk-rust-async-netio-with-chatgpt/">对话 ChatGPT 理解 Rust 异步网络 io</a>），属于另外一种玩法，很难说孰优孰劣。Go 使用有栈协程，调度原理很好理解，编程接口简单直接，缺点是<code>goroutine</code>数量过多会有隐患；Rust 使用无栈协程，利用状态机实现协程切换，好处是节省了不少指令，理论上有性能优势，缺点是接口太过晦涩。</p>
<p>可见，<strong>trade-off</strong> 无处不在！</p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80MTE4NTc4Lw==">UNIX网络编程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">Linux&#x2F;UNIX系统编程手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDMyNzAxP3RhYj1jYXRhbG9n">网络编程实战<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDg0MzAx">Redis 源码剖析与实战<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmcucGRm">Efficient IO with io_uring<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzc3NjcwMy8=">Ringing in a new asynchronous I&#x2F;O API<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzgxMDQxNC8=">The rapid growth of io_uring<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwuZGsvaW9fdXJpbmctd2hhdHNuZXcucGRm">What’s new with io_uring<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLm1hdHRlcm1vc3QuY29tL2Jsb2cvaGFuZHMtb24taW91cmluZy1nby8=">Getting Hands on with io_uring using Go<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMzE5MDg=">#31908<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/06/08/network/talk-rust-async-netio-with-chatgpt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/08/network/talk-rust-async-netio-with-chatgpt/" class="post-title-link" itemprop="url">对话 ChatGPT 理解 Rust 异步网络 io</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-08 21:18:20" itemprop="dateCreated datePublished" datetime="2023-06-08T21:18:20+08:00">2023-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从已知理解未知是人类的自然思维模式，但这很容易让人陷入认知偏差的思维陷阱。我在理解 Rust 异步网络 io 时就陷入了思维定式，总是试图以线程切换或者 goroutine 协程切换的模式来理解 Rust 协程的调度，而这两种调度方式有着天壤之别。</p>
<p>以 tokio 为首的 Rust 异步运行时，为用户呈现了一种无栈协程，既然都是协程，那么拿来与 go 的协程作比较是很自然的一种想法，加之我对协程切换、CPU 执行流改变近乎迷恋。所以，从 go 的角度去推测 Rust 也就情有可原了。</p>
<p>很多文章或者名家专栏在介绍异步 io 时，无一例外都是从 Stevens 先生在 《UNIX环境高级编程》中 对于 io 模型的介绍开始的，然后介绍 Linux 下的 epoll 多路复用，之后引出 reactor 模式，最后进入对 Rust 异步 io 的介绍。这其中有很大的断层，并不是很容易理解其中的脉络，所以，Rust 的异步 io 模型一直没搞明白，直到 chatgpt 的出现......</p>
<p>我先问了它go 的netpoller 和 tokio 两种网络模型的异同。</p>
<ol>
<li><p><strong>请比较一下go的netpoller网络模型和tokio的网络模型的异同</strong></p>
<blockquote>
<p>Go的netpoller网络模型是基于epoll&#x2F;kqueue&#x2F;iocp等多路复用技术的，它使用同步编程模式达到异步执行的效果。它以网络描述符netFD为中心，当在一个netFD上读写遇到EAGAIN错误时，就将当前goroutine存储到这个netFD对应的PollDesc中，并调用gopark把当前goroutine给park住，直到这个netFD上再次发生读写事件，才将此goroutine给ready激活重新运行。<br>Tokio的网络模型也是基于poll模型的，它使用异步编程模式实现高效的任务调度。它提供了TCP、UDP等网络类型，在tokio::net模块中可以找到像TcpListener、TcpStream、UdpSocket这些类型。Tokio的任务由Tokio调度器管理的最小可执行单元，它需要实现Future trait，并在poll方法中返回Async::NotReady或Async::Ready状态。<br>两者的异同点有：</p>
<ul>
<li>Go使用同步编程模式，Tokio使用异步编程模式</li>
<li>Go以netFD为中心管理网络操作，Tokio以Future为中心管理任务</li>
<li>Go使用goroutine作为轻量级线程，Tokio使用task作为轻量级线程</li>
<li>Go通过gopark和ready来控制goroutine的状态转换，Tokio通过Executor来调度task的状态转换</li>
</ul>
</blockquote>
<p>这个回答不是很抽象，如果以前没有了解相关内容的话，并不太好理解。但是解释大致是正确的，“Go使用同步编程模式，Tokio使用异步编程模式”这句话并不准确，Go 是通过netpoller 和 goroutine 的配合为用户提供了编写同步编码的接口，网络的 io 本质上还是基于 epoll 的非阻塞 io，而 Tokio 就需要用户真正的编写异步代码了。</p>
</li>
<li><p><strong>请介绍一下tokio的future使用poll来推进执行的内部原理</strong></p>
<p>因为事先了解过 Rust 的 funture 、调度器、执行器体系，所以我直接问其内部原理</p>
<blockquote>
<p>Tokio的future使用poll来推进执行的内部原理是：</p>
<ul>
<li>Future是一个trait，它有一个poll方法，用于检查future是否已经完成或者还需要等待</li>
<li>poll方法返回一个Poll枚举类型，它有三个可能的值：Ok(Async::Ready(t))表示future已经成功完成并返回t；Ok(Async::NotReady)表示future还没有准备好完成；Err(e)表示future已经失败并返回e</li>
<li>当future被创建时，它会注册自己到Tokio调度器中，并告诉调度器它依赖哪些资源（比如TCP socket）来完成</li>
<li>当资源变得可用时（比如TCP socket收到数据），调度器会通知future，并调用它的poll方法</li>
<li>如果poll方法返回Ok(Async::Ready(t))，那么future就完成了，并将t传递给下一个future；如果poll方法返回Ok(Async::NotReady)，那么future就继续等待资源变得可用；如果poll方法返回Err(e)，那么future就失败了，并将e传递给下一个future<br>这样，Tokio可以通过不断地调用poll方法来驱动异步任务的执行。</li>
</ul>
</blockquote>
<p>这些回答流于表面，但是能起到帮我建立上下文的作用，然后继续追问。</p>
</li>
<li><p><strong>我以前不理解执行流是如何改变的，现在有些模糊的认识，你帮我参谋一下：对于一个 future 执行流的改变总是发生在对于一个异步函数的 await 的调用处，其它非 await 调用的语句是不会中断的，所以一个 future 只会在 await 处被中断和恢复，我理解的对吗？</strong></p>
<p>之所以有此一问，是因为我还局限在线程切换和 goroutine 切换的思维定式当中，不论是线程还是 goroutine 都会被抢占，也就是说执行流在任务中的任何一行代码上都可能发生改变，被调度器保存上下文换上新的任务运行，既然 Rust 中也是任务，任务之间的切换没理由不遵循已经被验证过的设计方式。</p>
<blockquote>
<p>你的理解基本上是对的。await是一个语法糖，它会将异步函数分割成多个future，并在每个await处暂停和恢复执行流。但是有一点需要注意，就是如果一个future返回Ok(Async::Ready(t))，那么它不会被中断，而是直接继续执行下一个future。所以只有当一个future返回Ok(Async::NotReady)时，它才会被中断，并等待资源变得可用再恢复。</p>
</blockquote>
<p>很好，这个回答验证了一个猜想，那就是 Rust 的协程无法被 tokio 运行时自由抢占，抢占的任务依赖于底层的线程调度。</p>
</li>
<li><p><strong>嗯，我明白，现在我们再深入一下，tokio 是如何在 await 返 Ok(Async::NotReady) 时保护现场的？又是如何恢复现场的呢？</strong></p>
<p>我依旧对于执行流的改变耿耿于怀，我的认知是：<strong>当 await 无法完成时，执行器会转而执行其他的任务，而且会在合适的时机再次回到上次的中断处继续。</strong> 后面会证明这个想法是错误的</p>
<blockquote>
<p>Tokio是如何在await返回Ok(Async::NotReady)时保护现场的，又是如何恢复现场的呢：</p>
<ul>
<li>当一个future被创建时，它会被包装在一个Task结构体中，这个结构体包含了future的状态和上下文信息</li>
<li>当一个future被调度器调用poll方法时，它会获取Task的引用，并将其传递给future</li>
<li>当一个future返回Ok(Async::NotReady)时，它会创建一个Waker对象，并将其存储在Task中。Waker对象是一个通知机制，它可以让future告诉调度器什么时候再次poll自己</li>
<li>当资源变得可用时，Waker对象会被触发，并通知调度器再次poll对应的future</li>
<li>调度器会从Task中获取future的状态和上下文信息，并恢复执行流<br>这样，Tokio可以通过Task和Waker来保护和恢复现场。</li>
</ul>
</blockquote>
<p>表示对这个回答无感，可能是了解的不够深，无法 get 到正确的点，那就继续发问</p>
</li>
<li><p><strong>还有一个疑问：poll 函数到底怎么推进 future 的执行呢？如果实现 future 的这个异步函数中有很多普通的语句，这些语句怎么能通过 poll 得到执行呢？</strong></p>
<p>我其实隐约感觉到了 future 的执行比较特别，因为很多资料的介绍都是说 future 的执行是在被执行器一次次的 poll 中前进的。</p>
<blockquote>
<p>poll函数到底怎么推进future的执行呢：</p>
<ul>
<li>poll函数是Future trait的核心方法，它会尝试将future推进到完成状态</li>
<li>如果future已经完成，poll函数会返回Poll::Ready(t)，其中t是future的结果</li>
<li>如果future还没有完成，poll函数会返回Poll::Pending，并安排一个wake()函数在future准备好继续执行时被调用</li>
<li>当一个异步函数被调用时，它会被编译器分割成多个future，并在每个await处暂停和恢复执行流</li>
<li>每个future都有一个状态机，它记录了当前的执行位置和局部变量</li>
<li>当poll函数被调用时，它会根据状态机来决定接下来要执行哪些语句，并更新状态机</li>
<li>如果遇到一个await表达式，poll函数会检查被等待的future是否已经完成</li>
<li>如果已经完成，poll函数会获取结果并继续执行下一个语句；如果还没有完成，poll函数会返回Poll::Pending，并等待wake()函数再次唤醒自己<br>这样，poll函数可以通过状态机来控制异步任务的执行流程</li>
</ul>
</blockquote>
<p>不知道它说的这些哪些有问题，所以我想要一个被编译过后的实现了 future trait的异步函数内容，先看看再说。</p>
</li>
<li><p><strong>能给我一个poll函数执行future的示例吗？</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyFuture</span> &#123;</span><br><span class="line">    <span class="comment">// some fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">MyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="comment">// do some work</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">            <span class="comment">// return the result</span></span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="number">42</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// register a waker</span></span><br><span class="line">            cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">wake_by_ref</span>();</span><br><span class="line">            <span class="comment">// return pending</span></span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它没给出原来的异步函数内容，所以我有点生气（因为自己太平庸了，后来才明白 <code>// do some work</code> 就是异步函数中的普通语句）。</p>
</li>
<li><p><strong>但是这个异步函数的内容是什么？我没看到poll执行了异步函数的内容</strong></p>
<p><code>异步函数的内容是由编译器自动分割成多个future的，每个future都有一个poll方法，它会执行一部分异步函数的内容，直到遇到一个await表达式。例如，下面这个异步函数：</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">await</span> <span class="title function_ invoke__">bar</span>();</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>会被编译器转换成类似这样的代码：</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FooFuture</span> &#123;</span><br><span class="line">    State1,</span><br><span class="line">    <span class="title function_ invoke__">State2</span>(Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = <span class="type">i32</span>&gt;&gt;&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">FooFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            FooFuture::State1 =&gt; &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">fut</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="title function_ invoke__">bar</span>());</span><br><span class="line">                *<span class="keyword">self</span> = FooFuture::<span class="title function_ invoke__">State2</span>(fut);</span><br><span class="line">                cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">wake_by_ref</span>();</span><br><span class="line">                Poll::Pending</span><br><span class="line">            &#125;</span><br><span class="line">            FooFuture::<span class="title function_ invoke__">State2</span>(fut) =&gt; <span class="keyword">match</span> fut.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(cx) &#123;</span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(x) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// do something else</span></span><br><span class="line">                    Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">                &#125;</span><br><span class="line">                Poll::Pending =&gt; Poll::Pending,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>这样，你可以看到poll执行了异步函数的内容，并在每个await处暂停和恢复执行流。</code></p>
<p>看到这里我才恍然大悟，以前没有细细追究编译器将异步函数编译为一个状态机到底意味着什么。</p>
</li>
<li><p><strong>你的意思是编译器会把异步函数中的语句拆分到不同的状态机状态中，poll 的时候这些代码就会被执行是吗?</strong></p>
<p>看，多么痛的领悟~</p>
<blockquote>
<p>是的，你理解得很对。编译器会把异步函数中的语句拆分到不同的状态机状态中，poll的时候这些代码就会被执行。这样，异步函数就可以实现非阻塞的并发操作。</p>
</blockquote>
<p>但是，这仅仅是发现了新大陆而已，不能忘记为何出发</p>
</li>
<li><p><strong>那 await 放弃执行权是根据一个非阻塞文件描述符返回 EAGAIN 标志吗？</strong></p>
<p>根据 go 的经验，我问了一个底层的问题，想试着在Rust上缝合这一块儿内容</p>
<blockquote>
<p>await放弃执行权不是根据一个非阻塞文件描述符返回EAGAIN标志，而是根据future的poll方法返回Poll::Pending。当future的poll方法返回Poll::Pending时，它会注册一个waker，这个waker会在future可以继续执行时唤醒它。这样，异步函数就可以在等待某些操作完成时让出CPU资源给其他任务。</p>
</blockquote>
<p>它显然没理解我的意思，是我太跳跃了，那就给它点提示。</p>
</li>
<li><p><strong>那 poll 方法根据什么返回一个 Poll::Pending 呢？</strong></p>
<blockquote>
<p>poll方法根据future是否完成来返回一个Poll::Pending。如果future还没有完成，poll会返回Poll::Pending，并存储一个从当前Context复制的Waker的克隆。这个Waker会在future可以继续执行时唤醒它。例如，一个等待socket变为可读的future会调用Waker的.clone()方法并存储它。当socket变为可读时，Waker会被唤醒，然后再次调用poll方法。</p>
</blockquote>
<p>显然不能让它这么轻易几句就打发了，我决定要一个具体的例子。</p>
</li>
<li><p><strong>给我一个读取 socket 产生 pending 的例子，我要看看这个函数生成的 poll 内容，因为我对如何发出 socket 读取，并且不会陷入系统调用发生阻塞感兴趣。我是想要 tokio 异步编程中，一个异步函数读取 socket，被编译器编译出来的 poll 方法的内容，可以吗？</strong></p>
<p>你总是需要小心描述你的要求，这对中文来说是个很大的挑战，但是我又没有耐心一点点儿地抠英文，学渣的无奈啊！</p>
<p><code>tokio异步编程中，一个异步函数读取socket，被编译器编译出来的poll方法的内容可能是这样的： </code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::io::&#123;AsyncReadExt, AsyncWriteExt&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个异步函数，从socket中读取数据，并写回去</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">echo</span>(<span class="keyword">mut</span> stream: TcpStream) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0</span>; <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// 读取socket，如果没有数据可读，返回Poll::Pending，并注册一个waker</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// socket已经关闭，退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将读取到的数据写回socket</span></span><br><span class="line">        stream.<span class="title function_ invoke__">write_all</span>(&amp;buf[<span class="number">0</span>..n]).<span class="keyword">await</span>?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会将上面的异步函数转换为一个实现了Future特质的结构体类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Echo</span> &#123;</span><br><span class="line">    stream: TcpStream,</span><br><span class="line">    buf: [<span class="type">u8</span>; <span class="number">1024</span>],</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    Reading &#123; n: <span class="type">usize</span> &#125;,</span><br><span class="line">    Writing &#123; n: <span class="type">usize</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">Echo</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">                State::Reading &#123; <span class="keyword">mut</span> n &#125; =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 尝试从socket中读取数据</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">result</span> = Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.stream).<span class="title function_ invoke__">poll_read</span>(cx, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.buf[n..]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">match</span> result &#123;</span><br><span class="line">                        <span class="comment">// 如果成功读取到数据，更新n和state，并继续循环</span></span><br><span class="line">                        Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Ok</span>(m)) =&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">                                <span class="comment">// socket已经关闭，返回Poll::Ready(Ok(()))</span></span><br><span class="line">                                <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Ok</span>(()));</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                n += m;</span><br><span class="line">                                <span class="keyword">self</span>.state = State::Writing &#123; n &#125;;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果没有数据可读，返回Poll::Pending，并注册一个waker</span></span><br><span class="line">                        Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                        <span class="comment">// 如果出现错误，返回Poll::Ready(Err(e))</span></span><br><span class="line">                        Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Err</span>(e)) =&gt; <span class="keyword">return</span> Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Err</span>(e.<span class="title function_ invoke__">into</span>())),</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                State::Writing &#123; <span class="keyword">mut</span> n &#125; =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 尝试将数据写回socket</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">result</span> = Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.stream).<span class="title function_ invoke__">poll_write</span>(cx, &amp;<span class="keyword">self</span>.buf[..n]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">match</span> result &#123;</span><br><span class="line">                        <span class="comment">// 如果成功写入数据，更新n和state，并继续循环</span></span><br><span class="line">                        Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Ok</span>(m)) =&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> m == n &#123;</span><br><span class="line">                                <span class="comment">// 数据已经全部写入，重置n和state，并继续循环</span></span><br><span class="line">                                n = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">self</span>.state = State ::Reading &#123; n &#125;;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 数据还有剩余部分没有写入，减少n并保持state不变，并继续循环</span></span><br><span class="line">                                n -= m;</span><br><span class="line">                                <span class="keyword">self</span>.state = State ::Writing &#123; n &#125;;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果没有空间可写，返回Poll ::Pending，并注册一个waker</span></span><br><span class="line">                        Poll ::Pending =&gt; <span class="keyword">return</span> Poll ::Pending,</span><br><span class="line">                        <span class="comment">// 如果出现错误，返回Poll ::Ready (Err (e))</span></span><br><span class="line">                        Poll ::<span class="title function_ invoke__">Ready</span> (<span class="title function_ invoke__">Err</span> (e)) =&gt; <span class="keyword">return</span> Poll ::<span class="title function_ invoke__">Ready</span> (<span class="title function_ invoke__">Err</span> (e.<span class="title function_ invoke__">into</span>())),</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个例子就可以看出对于有 2 个 await 的异步函数，编译过后的状态机模样了</p>
</li>
<li><p><strong>tokio::net::TcpStream.poll_read 是如何做到不阻塞的？</strong></p>
<p>我选了 read 方法问它是如何做到不阻塞的</p>
<blockquote>
<p>tokio::net::TcpStream.poll_read 是一个异步读取方法，它可以从一个 TCP 流中接收数据，但不会等待新数据到达。它是非阻塞的，因为它不会挂起当前线程，而是返回一个 Poll 结果，表示操作是否完成或需要重试 。要使用这个方法，你需要确保 TCP 流是在非阻塞模式下创建的</p>
</blockquote>
<p>显然，它不知道我想要更底层的内容</p>
</li>
<li><p><strong>可以给出源码吗？它是在收到 EAGAIN  时返回一个 pending 吗？</strong></p>
<blockquote>
<p>你可以在这里查看 tokio::net::TcpStream.poll_read 的源码。它是一个 trait 方法，它调用了 TcpStream 的 poll_read_priv 方法，该方法使用了 PollEvented 来封装一个 mio::net::TcpStream。如果收到 EAGAIN 错误，它会返回一个 Pending 结果，并注册当前任务的唤醒器，以便在流变得可读时再次轮询。</p>
</blockquote>
<p>OK，问到我想要的答案了，接下来转移话题。</p>
</li>
<li><p><strong>我有个疑问，Rust 不内置异步运行时，那么编译器在编译 await 时，如何在返回 pending 时放弃 future 的执行权将执行流引向 executor 代码的呢？</strong></p>
<p>之所以问出这种问题，是因为我对Rust的异步运行时并不了解，也不清楚 future 是如何被催动的</p>
<blockquote>
<p>这是一个很好的问题。Rust 的 async&#x2F;await 特性是基于 trait 的，这意味着它不依赖于任何特定的运行时或执行器。编译器在编译 await 时，会将当前函数转换为一个状态机，其中每个 await 点都是一个状态转换。当一个 future 被轮询时，它会执行到下一个 await 点，然后返回 Pending 或 Ready 结果。执行器负责轮询 future，并在它们变得可用时恢复它们的执行。因此，编译器不需要知道执行器的细节，只需要生成合适的状态机和轮询逻辑。</p>
</blockquote>
</li>
<li><p><strong>奥，是不是执行器负责执行 future，当 future 中的 await 返回 pending 时，执行器放弃执行当前的 future，转而去寻找其它的 future 继续轮询，我理解的对吗？</strong></p>
<blockquote>
<p>是的，你的理解是对的。执行器就是负责管理和调度 future 的组件，它可以根据不同的策略来选择哪些 future 要轮询或暂停。执行器可以是单线程或多线程的，也可以支持不同的并发模型，如协程、线程池、事件循环等。</p>
</blockquote>
<p>ChatGPT 的优点就是可以节约你很多研究时间，当看到被肯定时，还是挺激动地，但是不能止步，终极问题还没解决</p>
</li>
<li><p><strong>详细讲解一下future是如何保存现场和恢复现场的？</strong></p>
<p>还是绕回到这个话题上来了，因为我的思维定式就是任务切换，要保存上下文的，IP，SP这些寄存器，及其他通用寄存器</p>
<blockquote>
<p>future 是一种抽象的类型，它表示一个异步计算的结果，它可以在某个时刻被轮询并返回一个值或者继续挂起。future 本身不保存任何现场，它只是一个状态机，它根据输入的上下文（Context）和缓冲区（ReadBuf）来决定下一步的动作。当 future 被轮询时，它会执行到下一个 await 点，并将自己的状态和局部变量封装在一个 Pin&lt;Box&lt;…&gt;&gt; 中返回给执行器。这个 Pin&lt;Box&lt;…&gt;&gt; 就是 future 的保存的现场，它可以在之后被再次传入 future 的 poll 方法来恢复执行。</p>
</blockquote>
<p>这个回答的好处是引出了<code>Pin&lt;Box&lt;…&gt;&gt;</code>,虽然细节不太清楚，但以前就混过脸熟，只要记住上下文放在这里就行。</p>
</li>
<li><p><strong>那么为什么要用 Pin&lt;Box&lt;…&gt;&gt; 来封装 future 上下文呢？</strong></p>
<blockquote>
<p>是为了保证 future 的内存地址不会改变，从而避免破坏 future 的安全性和正确性。Pin 是一个指针类型，它表示一个不能被移动的值。Box 是一个堆分配的智能指针，它可以存储任意类型的值 。将 future 包装在 Pin&lt;Box&lt;…&gt;&gt; 中，就相当于将 future 放在堆上，并且保证它不会被移动或者删除 。这样，future 就可以安全地保存自己的状态和局部变量，并且可以在任何时候被恢复执行。</p>
</blockquote>
<p>这个时候感觉的一点匪夷所思的是，执行器在一个线程上不断轮询若干个 future，而且 Rust 的协程是无栈协程，那么代码执行就只用到线程栈，按照前面的说法使用 Pin 保存现场，那么是否future的执行不依赖于栈中的内容，否则，在多个future之间跳来跳去岂不是乱了套？</p>
</li>
<li><p><strong>那future是不是对堆栈的依赖不大？</strong></p>
<blockquote>
<p>这个问题没有一个确定的答案，因为 future 的实现和使用方式可能不同。一般来说，future 会尽量减少对堆栈的依赖，因为堆栈是有限的资源，而 future 可能会有很多。future 通常会将自己的状态和局部变量存储在堆上，或者使用一些优化技术来避免不必要的内存分配。但是，future 也可能会使用一些堆栈空间来执行一些临时的计算或调用其他函数。因此，future 对堆栈的依赖程度取决于具体的情况和设计。</p>
</blockquote>
</li>
<li><p><strong>那 future 在保存现场的时候不考虑堆栈中的内容吗？</strong></p>
<blockquote>
<p>future 在保存现场的时候，只需要考虑自己的状态和局部变量，而不需要考虑堆栈中的内容。这是因为 future 的 poll 方法是一个纯函数，它不会修改堆栈中的任何数据，也不会依赖于堆栈中的任何数据。堆栈中的内容只是一些临时的计算或调用结果，它们在 future 挂起或恢复时并不重要。因此，future 只需要将自己封装在一个 Pin&lt;Box&lt;…&gt;&gt; 中，并将其返回给执行器，就可以实现现场的保存和恢复。</p>
</blockquote>
<p>至此，我大概理解 Rust 的异步网络 io 模型了。</p>
</li>
<li><p><strong>我有点理解了，每次 poll 或许会使用堆栈，但 poll 完之后，poll 函数返回堆栈内容就弹出了，但是上一次执行的状态会被保存在 pin 结构中，下一次 poll 的时候，会基于 pin 中的内容决定状态机的走向，进而一步步推动整个 future 逻辑的前行，是不是？</strong></p>
<blockquote>
<p>是的，你的理解是正确的。future 的 poll 方法就是一个状态机，它会根据自己的状态和输入的上下文来决定下一步的动作。每次 poll 完成后，future 会将自己的状态和局部变量保存在 pin 结构中，并返回一个值表示 future 是否已经完成或者还需要继续轮询。下一次 poll 的时候，future 会从 pin 结构中恢复自己的状态和局部变量，并继续执行到下一个 await 点或者结束。这样，future 就可以实现异步计算的逻辑。</p>
</blockquote>
</li>
</ol>
<p>因为我用的是NewBing，所以20句就截止了，所幸问题已经聊清楚了，其实类似于 tokio 之类的异步运行时在调度协程时并没有我惯性思维中以为的那种保存寄存器恢复寄存器的过程，它的核心在于每个异步函数都会被编译为一个状态机，这个状态机是玄机所在，再加上一个 pin 的结构来保存和恢复一些中间变量或者说状态。这样一来，依靠 epoll 事件，调度器和执行器的配合，不停地去 poll 这个状态机就行了，事件的发生会导致状态的改变，从而执行不同状态下的代码。这种架构理解起来不算直观，不如go的协程好理解。</p>
<p>go 的 netpoller 网络模型是与 goroutine 的密切配合实现的，作为 reactor，netpoller 只是根据网络文件描述符的状态修改关注它的 goroutine 的状态，剩余的工作交给调度器；以同步模式使用的网络 socket 读取代码，会在一个非阻塞的 socket 上获得 EAGAIN 错误时执行 gopark 进入调度循环，放弃执行，等待再次被调度。</p>
<p>至于 tokio 的网络模型，虽然 reactor 的底层逻辑都是使用 epoll 事件循环，但是当被激活时的行为是完全不同的，tokio 的 reactor被激活时会调用 executor 事先注册好的 waker 函数来通知 executor 去轮询 future，猜测这种模型的运行时要比 go 的运行时要小，加上 future 是无栈协程，理论上在处理大量网络连接时的效率要高。但是，tokio 也仅仅适用于 io 相关的操作，无法像 go 的goroutine 一样万事皆可异步！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"liupzmin","repo":"liupzmin.github.io","client_id":"77654195445087c01c56","client_secret":"eda09eecd05b86f0ef995d8067ec751abeb753d9","admin_user":"liupzmin","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","ClientID":"ae0756501dfc5de89d35","ClientSecret":"26befb359f7a466031bb96b4b7e0715c41c63fb8","owner":"liupzmin","adminUser":"['liupzmin']","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","createIssueManually":true,"distractionFreeMode":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
