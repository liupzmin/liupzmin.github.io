<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liupzmin.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="左手人文 | 右手科技">
<meta property="og:type" content="website">
<meta property="og:title" content="兔子先生">
<meta property="og:url" content="http://liupzmin.com/page/3/index.html">
<meta property="og:site_name" content="兔子先生">
<meta property="og:description" content="左手人文 | 右手科技">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="巴流">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://liupzmin.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>兔子先生 - 探寻计算机的历史与哲学密码</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="兔子先生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">兔子先生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探寻计算机的历史与哲学密码</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">63</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="巴流"
      src="/images/gzh.jpg">
  <p class="site-author-name" itemprop="name">巴流</p>
  <div class="site-description" itemprop="description">左手人文 | 右手科技</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liupzmin"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdXB6bWluQGdtYWlsLmNvbQ==" title="E-Mail → mailto:liupzmin@gmail.com"><i class="envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2021/01/03/design_patterns/strategy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/03/design_patterns/strategy/" class="post-title-link" itemprop="url">策略模式（上）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-03 20:42:35" itemprop="dateCreated datePublished" datetime="2021-01-03T20:42:35+08:00">2021-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DesignPatterns/" itemprop="url" rel="index"><span itemprop="name">DesignPatterns</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DesignPatterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本篇为策略模式的上篇，我以<strong>传统的严格意义上的面向对象语言 <strong><code>Java</code>为例来说明此模式；我会在下一篇用</strong>非严格意义上的OO语言</strong> <code>Go</code>基于同样的例子进行说明。</p>
</blockquote>
<h2 id="有一个游戏"><a href="#有一个游戏" class="headerlink" title="有一个游戏"></a>有一个游戏</h2><p>假设我们在设计一款鸭子游戏。玩家可以通过按钮选择任意一款鸭子，使得对应的鸭子可以在屏幕上展现，并且做相应的动作。为此我们设计了如下的高层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    Duck duck;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Game</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;picnic&quot;</span>)) &#123;</span><br><span class="line">            duck = <span class="keyword">new</span> <span class="title class_">MallardDuck</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;hunting&quot;</span>)) &#123;</span><br><span class="line">            duck = <span class="keyword">new</span> <span class="title class_">DecoyDuck</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;inBathTub&quot;</span>)) &#123;</span><br><span class="line">            duck = <span class="keyword">new</span> <span class="title class_">RubberDuck</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        duck.display();</span><br><span class="line">        duck.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望<code>Duck</code>是一个超类，并且在这里起到多态的作用。通过<code>type</code>输入参数来模拟用户通过按钮选择鸭子这一行为，并且在构造函数中初始化相应的鸭子实例，以便于后续调用<code>play</code>函数来在屏幕上展示。</p>
<p>我们假定<strong>每种鸭子都有独一无二的外观，并且每种鸭子都有相同的游泳方式</strong>。记住我们的这两个假设，因为我们马上要据此设计超类。</p>
<h2 id="超类"><a href="#超类" class="headerlink" title="超类"></a>超类</h2><p>我们之前假设了鸭子的两种特征：</p>
<ol>
<li>每种鸭子都有独一无二的外观</li>
<li>每种鸭子的游泳方式都相同</li>
</ol>
<p>我们把<code>Duck</code>设计为一个抽象类，因为外观是独一无二的，所以<code>display</code>设计为抽象方法，具体的外观由每一个具体的子类去实现；<code>swim</code>的行为每种鸭子都一样，所以我们在抽象类里将其实现，以达到所有子类共享的目的。</p>
<p>但是，我们忽然又意识到鸭子还有<code>quack</code>叫的特征，但是目前又不确定quack是不是有变化，所以暂时将其也在抽象类里实现。我们的超类代码大概如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quack quack quack!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;All ducks float, even decoys!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来总结一下如此设计的目的：</p>
<ol>
<li>抽象类<code>Duck</code>用于实现多态</li>
<li>抽象方法<code>display</code>用于统一接口，让子类分别实现</li>
<li><code>quack</code>和<code>swim</code>分别用于继承，以达到代码复用的目的</li>
</ol>
<p>我们用一张图来表示这种继承关系：</p>
<p><img data-src="https://qiniu.liupzmin.com/duck" alt="duck"></p>
<p>我们的设计是利用继承达到多态和代码复用的目的。绿头鸭和红头鸭分别是具体的实现，它们继承了<code>quack</code>和<code>swim</code>代码，又各自实现了<code>display</code>的方法。目前来看，我们的设计还算完美，如果不是一只<code>橡皮鸭子</code>出现的话。</p>
<h2 id="现在要让鸭子飞"><a href="#现在要让鸭子飞" class="headerlink" title="现在要让鸭子飞"></a>现在要让鸭子飞</h2><p>​	现在游戏上线了一种新的鸭子—<strong>橡皮鸭</strong>，橡皮鸭与之前的鸭子不同的是，它不会“呱呱”叫，只会“吱吱”叫。我们所有种类的鸭子都是<code>继承</code>自超类<code>Duck</code>，所以我们可以在橡皮鸭的子类中覆盖<code>Duck</code>的<code>quack</code>方法，向下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RubberDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am a rubber duck!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;squeak squeak squeak!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为橡皮鸭子不会呱呱叫，所以我们覆写了<code>quack</code>方法。子类重写虽然能解决当前的问题，但也势必会引入新的问题，我们接着往下看。</p>
<p>现在有一个新的需求要加入到游戏当中去，那就是我们需要让鸭子展示<code>飞行</code>的动作。基于我们目前的设计，很容易想到的是：在<code>Duck</code>中加入<code>fly()</code>方法：</p>
<p><img data-src="https://qiniu.liupzmin.com/duck-fly" alt="fly"></p>
<p>那么，问题来了，我们是将<code>fly()</code>设计成抽象方法呢，还是将其在超类里实现呢？在超类里实现就会出现橡皮鸭子会飞的情况，我们自然会想到子类重写，就像重写<code>quack</code>函数一样。但是，如果以后又加入了其它的不会飞也不会叫的鸭子怎么办？比如诱饵鸭是木头鸭，不会飞也不会叫；橡皮鸭不会飞但是会叫。长此以往，我们的代码会充斥着各种子类、各种重写的方法，这显然是有问题的。换句话说，我们之前的重写<code>quack</code>是不明智之举。</p>
<p>其实，问题的本质是<strong>继承不适用于目前的场景。</strong></p>
<p>使用继承的问题：</p>
<ul>
<li>如果是抽象的方法，代码在多个子类中重复，即代码无法复用。试想一下：一部分鸭子的飞行代码相同，而又有很多种类的鸭子飞行行为各有特色。</li>
<li>每次新增行为都要修改抽象类和子类，包括以后面临的修改，这都违反了开闭原则，且不可能预知全部的行为。</li>
<li>如果超类实现子类继承，复写子类方法同样无法达到代码复用，因为可能有多个种类的鸭子飞行行为相同，但又不同于超类里的实现。如果一旦涉及到修改，势必会带来维护上的噩梦。</li>
<li>改变会牵一发而动全身，造成其他鸭子不想要的改变。</li>
</ul>
<h2 id="接口能解决问题么"><a href="#接口能解决问题么" class="headerlink" title="接口能解决问题么"></a>接口能解决问题么</h2><p><code>Java</code>为我们提供了<code>interface</code>来实现多态。既然不能使用继承和重写来实现对应的功能，那么我们很容易想到用定义接口的方式让子类分别实现<code>quack</code>和<code>fly</code>接口：</p>
<p><img data-src="https://qiniu.liupzmin.com/duck-interface" alt="duck interface"></p>
<p>像图中那样将<code>quack</code>和<code>fly</code>作为单独的接口去实现。这可以解决部分问题，也就是不会有鸭子和行为不符合的情况，但依然面临严峻的问题：</p>
<ul>
<li>行为只是可能会发生变化的话，每个子类都实现接口，会造成代码无法复用，继而也会带来维护上的噩梦。</li>
<li>如果我想在运行中随时改变飞行的动作呢？继承超类和子类实现单独的接口都无法有效的解决问题。</li>
</ul>
<p>其实，单独的接口和抽象方法所面临的问题是一致的，即代码复用和维护变更的问题。试想一下，如果有48个Duck子类的飞行行为相同，代码实现就会有48份，而你恰巧在某个时刻需要修改这个行为...</p>
<p>这时，你肯定期待着<code>设计模式</code>能骑着白马来解救你！</p>
<h2 id="分开变化和不变的部分"><a href="#分开变化和不变的部分" class="headerlink" title="分开变化和不变的部分"></a>分开变化和不变的部分</h2><p>幸运的是，有一个设计原则，恰好适用于此状况。</p>
<blockquote>
<p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>
</blockquote>
<p>这样的概念很简单，几乎是每个设计模式背后的精神所在。所有的模式都提供了一套方法让<strong>“系统中的某部分改变不会影响其它部分”</strong>。</p>
<p>我们试分析一下，关于变和不变存在以下三种情况：</p>
<ol>
<li>一定不变的</li>
<li>一定会变的</li>
<li>可能会变的</li>
</ol>
<p>对于<strong>一定会变的</strong>，我们很容易用<strong>抽象方法或者接口</strong>来解决（<code>display</code>）。对于<strong>一定不变</strong>的（<code>swim</code>），我们就用<strong>继承</strong>，把实现放在超类里。</p>
<p>棘手的是可能会变化的部分，比如这里的<code>fly</code>和<code>quack</code>，这正是让我们左支右绌、进退维谷的根源。根据上面提到的原则，我们应该把这两个部分从<code>Duck</code>类中取出来，建立一组新类来代表每个行为。</p>
<p><img data-src="https://qiniu.liupzmin.com/separate-behavior" alt="separate behavior"></p>
<p>我们该如何实现新的行为类呢？我们希望每种Duck在使用行为类的时候具有弹性和灵活性，比如可以动态改变，也就是说我们可以在Duck类中增加设定行为的方法，这样就可以在运行时动态的改变鸭子的行为了。</p>
<p>那么，有什么设计原则可以指导我们么？</p>
<blockquote>
<p>针对接口编程，而不是针对实现编程。</p>
</blockquote>
<p>我们理应在Duck类中使用接口，而不是具体的实现。也就是说Duck类不负责实现<code>fly</code>和<code>quack</code>，具体的实现交给新的类去实现<code>FlyBehavior</code>和<code>QuackBehavior</code>接口。</p>
<p>Duck类应该只针对接口编程，<strong>“针对接口编程”真正的意思是“针对超类型编程”。</strong>这里所谓的“接口”有多个含义，关键在于使用<code>多态</code>。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。“针对超类型编程”这句话，可以明确的说成“变量的声明应该是超类型，通常是一个抽象类或者是一个接口。如此，只要是具体实现次超类型的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型！”</p>
<p><strong>也就是说，高层代码应该针对行为编程！</strong></p>
<h2 id="实现行为"><a href="#实现行为" class="headerlink" title="实现行为"></a>实现行为</h2><p><img data-src="https://qiniu.liupzmin.com/impl-duck-behavior" alt="implement duck&#39;s behavior"></p>
<p>我们设计了两个接口<strong>FlyBehavior</strong>和<strong>QuackBehavior</strong>，还有它们对应的类，负责实现具体的行为。这样的设计，可以让飞行和呱呱叫的动作被其它的对象复用，因为这些行为已经与鸭子类无关了。而我们可以新增一些行为，不会影响到既有的行为类，也不会影响到使用飞行行为的鸭子类。这么一来，有了继承的代码复用好处，却没有了继承所带来的包袱。</p>
<p>用代码实现一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyWithWings</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I&#x27;m flying!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyNoWay</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I can&#x27;t fly&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyRocketPowered</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I&#x27;m flying with a rocket&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quack</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Quack&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Squeak</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Squeak&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MuteQuack</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;&lt;&lt; Silence &gt;&gt;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>把行为整合进抽象类duck</p>
<p><img data-src="https://qiniu.liupzmin.com/new-duck.png" alt="new duck"></p>
<p>上图是新的鸭子类，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">    QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performQuack</span><span class="params">()</span> &#123;</span><br><span class="line">        flyBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performFly</span><span class="params">()</span> &#123;</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;All ducks float, even decoys!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们重新实现一下绿头鸭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallardDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MallardDuck</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		quackBehavior = <span class="keyword">new</span> <span class="title class_">Quack</span>();</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> <span class="title class_">FlyWithWings</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I&#x27;m a real Mallard duck&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的绿头鸭代码里有针对实现的代码，就是实例化行为的两行，这貌似违背了了我们之前所述，<strong>针对接口编程，而不是针对实现</strong>；其实，这里可以改为工厂模式，使得我们的代码彻底的面向接口。但工厂模式不是我们本次的重点，关于这一点我会稍后再略作解释，让我们继续完善我们的代码吧！</p>
<p>之前我们说要把鸭子的行为设计成可以动态改变，现在貌似还差点火候。那么，让我们在Duck类中再加入两个设定行为的方法吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlyBehavior</span><span class="params">(FlyBehavior fb)</span> &#123;</span><br><span class="line">		flyBehavior = fb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuackBehavior</span><span class="params">(QuackBehavior qb)</span> &#123;</span><br><span class="line">		quackBehavior = qb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	从此以后，我们可以随时调用这两个方法来改变鸭子的行为。来做个模拟吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiniDuckSimulator</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="type">Duck</span> <span class="variable">mallard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MallardDuck</span>();</span><br><span class="line">		mallard.performQuack();</span><br><span class="line">		mallard.performFly();</span><br><span class="line">   </span><br><span class="line">		<span class="type">Duck</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelDuck</span>();</span><br><span class="line">		model.performFly();</span><br><span class="line">		model.setFlyBehavior(<span class="keyword">new</span> <span class="title class_">FlyRocketPowered</span>());</span><br><span class="line">		model.performFly();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quack</span><br><span class="line">I&#x27;m flying!!</span><br><span class="line">I can&#x27;t fly</span><br><span class="line">I&#x27;m flying with a rocket!</span><br></pre></td></tr></table></figure>

<p>​	可见，在运行时想改变鸭子的行为，只需要调用<code>setter</code>方法即可。我们通过把可能变化的行为抽象为接口，使用单独的类去实现它。这样即解决了代码复用的问题，又使得维护变得简单。</p>
<h2 id="是的，这就是策略模式"><a href="#是的，这就是策略模式" class="headerlink" title="是的，这就是策略模式"></a>是的，这就是策略模式</h2><p><em><strong>没错，我们刚刚完成一个策略模式！</strong></em></p>
<p>是时候了解一下<code>策略模式</code>的具体定义了：</p>
<blockquote>
<p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
</blockquote>
<p>翻译一下：<strong>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</strong></p>
<p>让我们把描述问题的措辞稍作改变，不再把鸭子的行为说成是“一组行为”，我们开始把行为想成“一族算法”，算法代表了鸭子能做的事。如今算法和鸭子类之间不再是<code>IS-A</code>的关系，而是<code>HAS-A</code>的关系。</p>
<p><code>“有一个”</code>关系相当有趣：每一个鸭子都有一个<code>FlyBehavior</code>和一个<code>QuackBehavior</code>，好将飞行和呱呱叫的行为委托给它们代为处理。当你将两个类结合起来使用，如同本例一般，这就是<strong>“组合”</strong>。这种做法和“继承”的不同之处在于，鸭子的行为不是继承来的，而是和合适的行为对象“组合”来的。</p>
<p>这也是我们通常所说的另一个设计原则：<strong>多用组合，少用继承</strong>。</p>
<h2 id="策略模式就是简单的多态么"><a href="#策略模式就是简单的多态么" class="headerlink" title="策略模式就是简单的多态么"></a>策略模式就是简单的多态么</h2><p>纵观<code>策略模式</code>的定义以及各种围绕<code>策略模式</code>的示例，我们很容易产生一个疑问：<strong>策略模式就是简单的多态么？策略模式的定义何其标题看不出任何联系，到底何为策略？</strong></p>
<p>从维基百科上策略模式的定义可以看出，策略模式乃是一个方法论，不拘于多态一种实现方式：</p>
<blockquote>
<p>Typically, the strategy pattern stores a reference to some code in a data structure and retrieves it. This can be achieved by mechanisms such as the native <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnVuY3Rpb25fcG9pbnRlcg==">function pointer<i class="fa fa-external-link-alt"></i></span>, the <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlyc3QtY2xhc3NfZnVuY3Rpb24=">first-class function<i class="fa fa-external-link-alt"></i></span>, classes or class instances in <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2JqZWN0LW9yaWVudGVkX3Byb2dyYW1taW5n">object-oriented programming<i class="fa fa-external-link-alt"></i></span> languages, or accessing the language implementation&#39;s internal storage of code via <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVmbGVjdGlvbl8oY29tcHV0ZXJfc2NpZW5jZSk=">reflection<i class="fa fa-external-link-alt"></i></span>.</p>
</blockquote>
<p><code>stackoverflow</code>上亦有相同的发问 <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc2NzA4NDIvaXMtc3RyYXRlZ3ktZGVzaWduLXBhdHRlcm4tbm8tbW9yZS10aGFuLXRoZS1iYXNpYy11c2Utb2YtcG9seW1vcnBoaXNt">Is &#39;Strategy Design Pattern&#39; no more than the basic use of polymorphism?<i class="fa fa-external-link-alt"></i></span> 得票最高的回答也阐述了相同的意思：<strong>策略模式，或者说设计本身，它不是指细节代码，而是一种思维方式。</strong></p>
<p>我们虽然在这里用多态的方式实现了策略模式，但策略模式的实现方式绝非多态一种。</p>
<p>另外我观 <span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDM5MDAx">设计模式之美<i class="fa fa-external-link-alt"></i></span> 中对策略模式的阐述，其称：<strong>不使用工厂模式而直接实例化行为对象的情况为简单的面向接口编程，并非严格意义的策略模式。</strong>如此观点虽有启发，但仍未消除心中疑虑，因为<strong>“策略”</strong>一词在我心中还有另一个概念。</p>
<p>策略模式的概念与定义难以让我释怀。我必须自己寻找一个答案，并说服自己去相信它，即便它可能不那么正确。因为我们每个人之所以要不断的思考，就是要缝合自我认知体系里矛盾的地方。</p>
<p>而<code>策略</code>一词，在我的知识体系里，是矛盾的！</p>
<h2 id="从Unix设计哲学中取经"><a href="#从Unix设计哲学中取经" class="headerlink" title="从Unix设计哲学中取经"></a>从Unix设计哲学中取经</h2><p>在最初接触<code>策略模式</code>时，我很自然的就联想到<code>Unix设计哲学</code>中的一条原则：<strong>分离原则。</strong></p>
<p><em><strong>Rule of Separation: Separate policy from mechanism; separate interfaces from engines.</strong></em></p>
<p><strong>分离原则：策略同机制分离，接口同引擎分离</strong></p>
<p><strong>policy</strong> 和 <strong>strategy</strong> 同被翻译为“策略”，我以为思想肯定也很接近。但是<code>Gof</code>中描述的算法族，每个具体的算法就是一个策略，让我一度觉得这两个原则之间可能没有关系。</p>
<p>的确，按照定义，这两个原则对<code>策略</code>的理解不是一个层面的东西，就如同英语中的微妙区别一样，一个是具体的行动计划，一个是指导性原则。</p>
<p>但吊诡的是，这两者居然能品出一丝完全相反的味道来。</p>
<p>先来了解一下分离原则。其实它比策略模式要更加普世，虽然分离原则和策略模式同为软件设计原则，但分离原则要更加抽象，而策略模式更贴近于代码，分离原则更偏向于架构。</p>
<p>分离原则讲究把策略同机制分离，策略是针对使用方，机制则说的是实现方。分离原则认为，策略和机制是按照不同的时间尺度变化的，策略的变化要远远快于机制。所以，把策略和机制揉成一团有两个负面影响：一来会使策略变的死板，难以适应用户需求的改变；二来也意味着任何策略的改变都极有可能动摇机制。</p>
<p>相反，将两者剥离，就有可能<strong>在探索新策略的时候不会打破机制</strong>。另外也更容易为机制写出较好的测试，因为策略都太过短命，不值得花太多经历在上面。《UNIX编程艺术》一书中，举了x图形引擎的例子。让X成为一个通用的图形引擎，而将用户界面风格留给工具包或者系统其它层来决定。GUI工具包的观感时尚来去匆匆，而光栅操作和组合却是永恒的。</p>
<p>让我们回想一下策略模式中的策略，<code>Gof</code>说每个具体的算法类就是策略。我认为以此起**&quot;策略模式&quot;<strong>这个名字多少有些以偏概全，未准确传达此模式使</strong>“算法族可以互相替换”<strong>的主旨。分离原则和策略模式中的策略是不同场景下对不同内容的描述：</strong>分离原则的策略是指使用多种不同机制的方法，让机制与使用分离，本质上还是抽离不变与变化的东西**；而策略模式之策略是指一系列做同类事的算法，因为同类，所以可互换，可多态！</p>
<p>所以，忘掉<code>策略模式</code>概念本身吧，它或许不是一个好名字，但却是一个好的、常用的、易用的代码设计方法。只要心中牢记“面向接口，而不是实现编程”，也许一不小心就会写出<strong>策略模式</strong>了！</p>
<h2 id="总结学到的思想"><a href="#总结学到的思想" class="headerlink" title="总结学到的思想"></a>总结学到的思想</h2><ol>
<li><strong>面向接口编程，而不是面向实现编程</strong></li>
<li><strong>“针对接口编程”真正的意思是“针对超类型编程”</strong></li>
<li><strong>“针对超类型编程”这句话，可以明确的说成“变量的声明应该是超类型，通常是一个抽象类或者是一个接口。如此，只要是具体实现次超类型的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型”</strong></li>
<li><strong>多用组合，少用继承</strong></li>
<li><strong>唯一不变的就是变化本身</strong></li>
<li><strong>所有的模式都提供了一套方法让“系统中的某部分改变不会影响其它部分”</strong></li>
</ol>
<p><em><strong>参考文献：</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zNDI2MjMwNS8=">设计模式：可复用面向对象软件的基础<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yMjQzNjE1Lw==">Head First 设计模式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDM5MDAx">设计模式之美<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/08/01/python/everything-is-an-object-in-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/01/python/everything-is-an-object-in-python/" class="post-title-link" itemprop="url">浅析 python 一切皆对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-01 13:29:02" itemprop="dateCreated datePublished" datetime="2020-08-01T13:29:02+08:00">2020-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/%E9%87%8D%E5%AD%A6python/" itemprop="url" rel="index"><span itemprop="name">重学python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="变量的迷惑"><a href="#变量的迷惑" class="headerlink" title="变量的迷惑"></a>变量的迷惑</h2><p>如果你有其它类C语言的使用经历(<code>c</code>,<code>java</code>,<code>c++</code>,<code>Go</code>等)，那么一提到变量，我们会将变量想象成一个<code>box</code>，它代表了计算机中的一块内存，是一个可以存放值的容器：</p>
<p><img data-src="http://qiniu.liupzmin.com/cbox.jpg" alt="box"></p>
<p>如上图所示，声明初始化一个<code>a=1</code>，就相当于在内存中开辟了一块空间用于存放值<code>1</code>，使用变量名<code>a</code>就可以改变内存中的值<code>a=2</code>。 当把<code>a</code>赋给一个新的变量<code>b</code>的时候，会在内存中为<code>b</code>重新开辟一块空间，并把<code>a</code>的一个副本存入其中。也就是说变量与变量之间完全独立，抱有这种认识的人大多会对 python 中的变量产生很大的误解，不信我们试看下面的代码片段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(<span class="number">9527</span>, <span class="number">9527</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232581997552</span>, <span class="number">140232581997552</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>上面的代码段初始化了一个变量<code>a</code>并将其赋值为 9527，之后又把<code>a</code>赋给了变量<code>b</code>，打印他们的值都为 9527，到现在 python 中的变量表现和其它语言没什么不同（表面上看起来）。但我们接着打印了这两个变量的地址，你会惊奇的发现，<strong>他们竟然相同</strong>。使用<code>is</code>来判断，<code>b</code>就是<code>a</code>，也就是说此时在内存中只有一块空间来存放<code>9527</code>这个值。现在我们试着改变一下<code>a</code>的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(<span class="number">1024</span>, <span class="number">9527</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232581997456</span>, <span class="number">140232581997552</span>)</span><br></pre></td></tr></table></figure>

<p>我们赋予<code>a</code>一个新的值<code>1024</code>，然后打印了他们的值，python 的表现仍然跟我们<code>“预期”</code>的一样：<em>a的值改变了，b的值没有。</em>，但是在我们打印了他们的内存地址之后，一切看起来并没那么简单。</p>
<p><code>a</code>和<code>b</code>的地址最初都是<code>140232581997552</code>，当<code>a</code>重新赋值之后，<code>b</code>的地址没有改变，而<code>a</code>的地址却变成了<code>140232581997456</code>。也就是说，python的解释器重新开辟了一块内存给了<code>a</code>，这完全颠覆了我们印象中基于<code>box和store</code>对变量的理解。虽然目前看起来还算工作正常，但是我准备再对示例代码做一些改动：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232582690624</span>, <span class="number">140232582690624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这一次我们使用了<code>list</code>，一切看起来和刚才一样，<code>a</code>和<code>b</code>指向同一块内存，现在我们试着改变<code>list</code>中的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br></pre></td></tr></table></figure>

<p>你认为上段代码的输出会是什么？ <code>b</code>中元素的值也会改变么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a,b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] [<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>没错，这就是 python 让你惊讶的地方之一，这一次的表现不仅和你的<code>预期</code>不同，甚至和它上一次的表现也不相同。</p>
<p>第一次我们使用的是<code>number</code>，它在 python 中是一个<code>不可变对象</code>，python 中的变量其实是内存对象的一个标签，赋值仅仅是一个绑定的动作，画一个形象的图来表示：</p>
<p><img data-src="http://qiniu.liupzmin.com/python-label.jpg" alt="label"></p>
<p>当我们使用<code>list</code>时表现又不同，这是因为<code>list</code>在 python 中是一个<code>可变对象</code>。在 python 中一切皆对象，这种特殊的数据模型是造成我们误解的根本原因，接下来我们重点讨论一下 python 中的对象。</p>
<h2 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h2><blockquote>
<p>Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer”, code is also represented by objects.)<br>Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The ‘is’ operator compares the identity of two objects; the id() function returns an integer representing its identity.</p>
</blockquote>
<p>以上是 python 官网文档中的描述，翻译一下：<strong>Python中对象是所有数据的抽象。所有Python程序中的值都由对象或者对象之间的关系表示。Python中每个对象有一个唯一标识identity，一个对象的标识在对象被创建后不再改变。可以认为对象的identity是对象在内存中的地址，其值可以由内置函数id()求得。is操作符可以比较两个对象的identity是否相同，即两个对象是否是同一个。</strong></p>
<p>对于 python 中的变量赋值操作，有两种类比说法。一个是 <strong>“boxes vs. label”</strong> ，另一个是<strong>“names and bindings”</strong> 。我们采用<code>“names and bindings”</code> 这种说法，在 python 里一切都是对象，如interger、string、list、dict、set、function等。当我们赋值给一个变量的时候，我们仅仅把变量当成一个名字（name）：</p>
<p><code>&lt;name&gt; = &lt;object&gt;</code></p>
<p><strong>我们实际上是将一个对象和一个名称绑定，需要注意的是一个对象可以被多个名称绑定</strong>，这是最司空见惯的情况，也是最容易引起歧义的地方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(<span class="number">9527</span>, <span class="number">9527</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232581997552</span>, <span class="number">140232581997552</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;bohu&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;bohu&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="number">140090288720896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="number">140090288720896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这段代码就展示了一个对象被多个名称绑定的情况，<code>number 9527</code>和字符串<code>bohu</code>是一个数值对象和一个字符串对象，并分别被两个变量绑定。</p>
<p>现在我们使用<code>list</code>来代替<code>number</code>和<code>string</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="number">140090289536200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="number">140090288737736</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，我们看到<code>a</code>和<code>b</code>指向了不同的内存空间，python 的表现之所以有所不同是因为<code>string</code>和<code>number</code>是<code>immutable</code>对象，而<code>list</code>是<code>mutable</code>的对象，关于python中对象的<code>mutability</code>见下表：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>immutable</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>Y</td>
</tr>
<tr>
<td>int</td>
<td>Y</td>
</tr>
<tr>
<td>float</td>
<td>Y</td>
</tr>
<tr>
<td>list</td>
<td>N</td>
</tr>
<tr>
<td>tuple</td>
<td>Y</td>
</tr>
<tr>
<td>str</td>
<td>Y</td>
</tr>
<tr>
<td>set</td>
<td>N</td>
</tr>
<tr>
<td>frozenset</td>
<td>Y</td>
</tr>
<tr>
<td>dict</td>
<td>N</td>
</tr>
</tbody></table>
<p>可见除了<code>list</code>，<code>set</code>，<code>dict</code>之外其余都是<code>不可变</code>的，一个<code>immutable</code>的对象被创建之后是不可以改变的。如果你试图通过与之绑定的变量去修改这个对象时，python会创建一个新的实例对象并与原来的变量绑定，之前的对象则伺机被回收。相反，一个<code>mutable</code>的对象是可以被原地改变的，比如之前的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232582690624</span>, <span class="number">140232582690624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a,b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] [<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232582690624</span>, <span class="number">140232582690624</span>)</span><br></pre></td></tr></table></figure>

<p>除非重新赋值，否则<code>a</code>和<code>b</code>绑定的对象的内存地址是不会改变的。当你使用<code>b = a</code>时，你并没有成功的<code>copy</code>一个<code>list</code>，你只是把两个<code>name</code>绑定到了同一个<code>list</code>对象之上。因此，正确的理解 python 的对象模型会帮助你正确的调试你的程序。</p>
<p>要理解 python 中的变量，我们就不能把变量当成一个盛放<code>值</code>的盒子，我们要把 python 中的变量当做贴在盒子上的<code>标签</code>。我们可以在同一个盒子上贴多个标签，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;super hero powers&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;super hero powers&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>当我们执行<code>a = &quot;super hero powers&quot;</code>时，我们说：<code>创建了等号右边的对象，并且把名称 a 绑定到这个对象上</code>。当我们执行<code>a = b</code>时，我们说：<code>把 a 绑定到 b 绑定的对象上</code>。</p>
<p>由此可见，在python中：</p>
<ul>
<li>变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。</li>
<li>可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。</li>
<li>对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+&#x3D; 等等）更新不可变对象的值时，会返回一个新的对象。</li>
<li>变量可以被删除，但是对象无法被删除。</li>
</ul>
<h2 id="函数调用，传值还是传引用"><a href="#函数调用，传值还是传引用" class="headerlink" title="函数调用，传值还是传引用?"></a>函数调用，传值还是传引用?</h2><p>先来看官方的一段描述：</p>
<blockquote>
<p>Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per se.</p>
</blockquote>
<p>参数的传递是通过赋值进行传递（<code>passed by assignment</code>）。也就是说，参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func1</span>(<span class="params">b</span>):</span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">my_func1(a)</span><br><span class="line">a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里的参数传递，使变量 a 和 b 同时指向了 1 这个对象。但当我们执行到 b &#x3D; 2 时，系统会重新创建一个值为 2 的新对象，并让 b 指向它；而 a 仍然指向 1 这个对象。所以，a 的值不变，仍然为 1。</p>
<p>那么对于上述例子的情况，是不是就没有办法改变 a 的值了呢？答案当然是否定的，我们只需稍作改变，让函数返回新变量，赋给 a。这样，a 就指向了一个新的值为 2 的对象，a 的值也因此变为 2。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func2</span>(<span class="params">b</span>):</span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a = my_func2(a)</span><br><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>当你想获取改变后的值的时候，最好的选择就是返回一个元组来包含多个结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line"><span class="meta">... </span>    a = <span class="string">&#x27;new-value&#x27;</span>        <span class="comment"># a and b are local names</span></span><br><span class="line"><span class="meta">... </span>    b = b + <span class="number">1</span>              <span class="comment"># assigned to new objects</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b            <span class="comment"># return new values</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="string">&#x27;old-value&#x27;</span>, <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(x, y)</span><br><span class="line">(<span class="string">&#x27;new-value&#x27;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>当传入的参数是一个<code>mutable</code>的对象时，改变对象的值，就会影响所有指向它的变量，因此，我们可以利用这一点达到传引用的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a</span>):</span><br><span class="line"><span class="meta">... </span>    a[<span class="number">0</span>] = <span class="string">&#x27;new-value&#x27;</span>     <span class="comment"># &#x27;a&#x27; references a mutable list</span></span><br><span class="line"><span class="meta">... </span>    a[<span class="number">1</span>] = a[<span class="number">1</span>] + <span class="number">1</span>        <span class="comment"># changes a shared object</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="string">&#x27;old-value&#x27;</span>, <span class="number">99</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(args)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args</span><br><span class="line">[<span class="string">&#x27;new-value&#x27;</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>但我们要注意的是，<code>改变变量和重新赋值的区别</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">l2</span>):</span><br><span class="line">  l2 = l2 + [<span class="number">4</span>]</span><br><span class="line">  <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_func(l1)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>为什么 l1 仍然是[1, 2, 3]，而不是[1, 2, 3, 4]呢？</p>
<p>要注意，这里 l2 &#x3D; l2 + [4]，表示创建了一个“末尾加入元素 4“的新列表，并让 l2 指向这个新的对象。这个过程与 l1 无关，因此 l1 的值不变。当然，同样的，如果要改变 l1 的值，我们就得让上述函数返回一个新列表，再赋予 l1 即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">l2</span>):</span><br><span class="line">  l2 = l2 + [<span class="number">4</span>]</span><br><span class="line">  <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l1 = my_func(l1)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>当我们说深拷贝和浅拷贝时，一般都是针对于集合类型来讲的，如 python 中的<code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code>等。其它语言中的<code>struct</code>类型也会涉及到深浅拷贝之说，通常是指这些集合类型或者结构体中有其它集合的引用。</p>
<h3 id="浅拷贝-shallow-copy"><a href="#浅拷贝-shallow-copy" class="headerlink" title="浅拷贝(shallow copy)"></a>浅拷贝(shallow copy)</h3><p> <strong>浅拷贝会创建新对象，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用</strong>。注意，其内容非原对象本身的引用，而是原对象内第一层对象的引用。浅拷贝有三种形式:</p>
<ul>
<li>类型构造器</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = <span class="built_in">list</span>(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1),<span class="built_in">id</span>(l2)</span><br><span class="line">(<span class="number">140232580721664</span>, <span class="number">140232580722496</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1),<span class="built_in">id</span>(s2)</span><br><span class="line">(<span class="number">140232582029088</span>, <span class="number">140232580748448</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这里，l2 就是 l1 的浅拷贝，s2 是 s1 的浅拷贝。当然，对于可变的序列，我们还可以通过切片操作符&#39;:&#39;完成浅拷贝。</p>
<ul>
<li>切片操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3 = l1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l3</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>copy 模块中的 copy 函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = copy.copy(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1),<span class="built_in">id</span>(l2)</span><br><span class="line">(<span class="number">140232580721408</span>, <span class="number">140232580721664</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>因为浅拷贝只是创建一个新对象，集合中的元素内容仍然是原对象中子对象的引用，我们用以上三种方式中的任意一种来观察一下（因为他们都是浅拷贝，结果都是相同的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = copy.copy(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1),<span class="built_in">id</span>(l2)</span><br><span class="line">(<span class="number">140232580721408</span>, <span class="number">140232580721664</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1[<span class="number">2</span>]),<span class="built_in">id</span>(l2[<span class="number">2</span>])</span><br><span class="line">(<span class="number">140232598059200</span>, <span class="number">140232598059200</span>)</span><br></pre></td></tr></table></figure>

<p>这里<code>l1</code>和<code>l2</code>是两个不同的对象，而<code>l1[2]</code>和<code>l2[2]</code>是两个变量名称，通过<code>id()</code>可以看到他们两个绑定到了相同的对象之上：</p>
<p><img data-src="http://qiniu.liupzmin.com/copy-list.jpg" alt="不带可变对象的拷贝"></p>
<p>这是没有可变对象的情况下的拷贝，当有可变对象时，也就是说当对象元素中有<code>list</code>、<code>set</code>、<code>dict</code>等集合对象时，浅拷贝只是做一个引用绑定，并不会创建新的可变对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = copy.copy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = copy.deepcopy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582406832</span>, <span class="number">140232582406832</span>, <span class="number">140232582406832</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>])</span><br><span class="line">(<span class="number">140232580722432</span>, <span class="number">140232580722432</span>, <span class="number">140232580722624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>][<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582979824</span>, <span class="number">140232582979824</span>, <span class="number">140232582979824</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码片段增加了深拷贝的例子，关于深拷贝我们一会儿再说，这里只看<code>s1</code>和<code>s2</code>，其中<code>s1</code>是包含列表的列表，经过浅拷贝之后我们发现：<code>s1[3]</code>和<code>s2[3]</code>指向同样的对象。可以说明浅拷贝只是对子列表做了变量绑定，并没有创建新的对象。那么你在修改<code>s1</code>的同时，必然会影响到<code>s2</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&quot;行藏在我&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>用一张图来描述一下此时的内存图景：</p>
<p><img data-src="http://qiniu.liupzmin.com/copy-with-list.jpg" alt="带可变对象的拷贝"></p>
<h3 id="深拷贝-deep-copy"><a href="#深拷贝-deep-copy" class="headerlink" title="深拷贝(deep copy)"></a>深拷贝(deep copy)</h3><p>深拷贝只有一种形式，copy 模块中的 deepcopy() 函数。深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。</p>
<p>通过上面的浅拷贝示例可知，浅拷贝不会为可变的子对象构建新的对象，这样就会带来修改了新数据之后旧数据也会被修改的副作用。有时候为了避免这种副作用，我们会使用深拷贝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = copy.copy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = copy.deepcopy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582406832</span>, <span class="number">140232582406832</span>, <span class="number">140232582406832</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>])</span><br><span class="line">(<span class="number">140232580722432</span>, <span class="number">140232580722432</span>, <span class="number">140232580722624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>][<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582979824</span>, <span class="number">140232582979824</span>, <span class="number">140232582979824</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&quot;行藏在我&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>还是上一节浅拷贝的例子，我们重点来看<code>s3</code>，<code>s3</code>是用深拷贝构建出来的，观察<code>可变子对象</code>的id可以发现它是一个新的对象，拥有全新的内存地址，但是<code>其中的不可变对象</code>仍然共享了原来的对象。</p>
<p>我们通过<code>s1[3][0] = &quot;行藏在我&quot;</code>改变了子列表中的内容之后，深拷贝构造出来的<code>s3</code>并未受到影响，因为<code>s1[3][0]</code>改变的是<code>s1[3]</code>指向的对象本身，而<code>s3[3]</code>指向的是另一个不同的对象，此时的内存图景为：</p>
<p><img data-src="http://qiniu.liupzmin.com/deep-copy.jpg" alt="带可变对象的深拷贝"></p>
<p>关于元组copy时的注意事项：</p>
<ul>
<li>元组只包含非容器类型时（如数字、字符串、和其他&#39;原子&#39;类型的对象），无论是浅拷贝还是深拷贝返回的都是原元组对象的引用。</li>
<li>元组包含可变对象时（如<code>list</code>、<code>set</code>、<code>dict</code>等），浅拷贝依然返回引用，深拷贝则会创建一个新的对象和子对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 = <span class="built_in">tuple</span>(tup1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tup1),<span class="built_in">id</span>(tup2)</span><br><span class="line">(<span class="number">140232580721216</span>, <span class="number">140232580721216</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 = copy.copy(tup1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4 = copy.deepcopy(tup1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tup3)</span><br><span class="line"><span class="number">140232580721216</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tup4)</span><br><span class="line"><span class="number">140232580721216</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4 <span class="keyword">is</span> tup1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 <span class="keyword">is</span> tup1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 <span class="keyword">is</span> tup1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist2 = copy.copy(tupwithlist1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist3 = copy.deepcopy(tupwithlist1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tupwithlist1),<span class="built_in">id</span>(tupwithlist2),<span class="built_in">id</span>(tupwithlist3)</span><br><span class="line">(<span class="number">140232580724112</span>, <span class="number">140232580724112</span>, <span class="number">140232580724672</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tupwithlist1[<span class="number">3</span>]),<span class="built_in">id</span>(tupwithlist2[<span class="number">3</span>]),<span class="built_in">id</span>(tupwithlist3[<span class="number">3</span>])</span><br><span class="line">(<span class="number">140232580722304</span>, <span class="number">140232580722304</span>, <span class="number">140232580743680</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist1[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist1</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">9527</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist2</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">9527</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist3</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<h2 id="再论元组"><a href="#再论元组" class="headerlink" title="再论元组"></a>再论元组</h2><blockquote>
<p>元组是<code>immutable</code>的，却有潜在的被更改的可能性</p>
</blockquote>
<p>元组本身是不可变的，但是它包含的值却有可能被更改，特别是当元组<code>hold</code>住一个<code>mutable</code>的对象时，例如<code>list</code>。</p>
<p>有了之前把变量名称当做一个对象的标签的论述，我们这里举起例子来就容易多了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dee = (<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum = (<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum == dee</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum <span class="keyword">is</span> dee</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(dum), <span class="built_in">id</span>(dee)</span><br><span class="line">(<span class="number">4313018120</span>, <span class="number">4312991048</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom = dum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom</span><br><span class="line">(<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom == dum</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom <span class="keyword">is</span> dum</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>我们创建了2个tuple对象，<code>dum</code>和<code>t_doom</code>是第一个对象的标签，<code>dee</code>是第二个对象的标签。</p>
<p><img data-src="http://qiniu.liupzmin.com/dum-t_doom-dee.png" alt="dum-t_doom-dee"></p>
<p>现在我们为<code>t_doom</code>增加技能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>skills = t_doom[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>skills.append(<span class="string">&#x27;rap&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom</span><br><span class="line">(<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum</span><br><span class="line">(<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><code>dum</code>和<code>t_doom</code>都获得了<code>rap</code>技能，原因是他们绑定的是同一个对象， <code>t_doom[1]</code> 和 <code>skills</code>也绑定到了同一个<code>list</code>对象上面：</p>
<p><img data-src="http://qiniu.liupzmin.com/dum-skills-references.png" alt="dum-skills-references"></p>
<p>那么我们为什么说此时元组仍是不可变的呢？其实不可变值得是元组的物理内容，元组里包含的是什么？是对于各种对象的引用，<code>dum[1]</code>引用的<code>list</code>对象的<code>值</code>改变了，但被引用的对象本身的<code>id</code>并没有变。所以，元组中的可变对象可能会有改动，但是可变对象本身却总保持不变。</p>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3N3bGgvZXZlcnl0aGluZy1pcy1hbi1vYmplY3QtaW4tcHl0aG9uLWxlYXJuLXRvLXVzZS1mdW5jdGlvbnMtYXMtb2JqZWN0cy1hY2U3ZjMwZTI4M2U=">Everything Is an Object in Python — Learn to Use Functions as Objects<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BsYXJtYWxhZGUvcHl0aG9uLWV2ZXJ5dGhpbmctaXMtYW4tb2JqZWN0LWFuZC1zb21lLW9iamVjdHMtYXJlLW11dGFibGUtNGY1NWViMmI0Njhi">Python: Everything is an Object, and Some Objects are Mutable<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qZWZma251cHAuY29tL2Jsb2cvMjAxMi8xMS8xMy9pcy1weXRob24tY2FsbGJ5dmFsdWUtb3ItY2FsbGJ5cmVmZXJlbmNlLW5laXRoZXIv">Is Python call-by-value or call-by-reference? Neither.<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3JhZGFyLm9yZWlsbHkuY29tLzIwMTQvMTAvcHl0aG9uLXR1cGxlcy1pbW11dGFibGUtYnV0LXBvdGVudGlhbGx5LWNoYW5naW5nLmh0bWw=">Python tuples: immutable but potentially changing<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9yZWZlcmVuY2UvZGF0YW1vZGVsLmh0bWwjb2JqZWN0cy12YWx1ZXMtYW5kLXR5cGVz">Objects, values and types<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaS1wcm9ncmFtbWVyLmluZm8vcHJvZ3JhbW1pbmcvcHl0aG9uLzExNjgzLXByb2dyYW1tZXJzLXB5dGhvbi12YXJpYWJsZXMtb2JqZWN0cy1hbmQtYXR0cmlidXRlcy5odG1s">Programmer&#39;s Python - Variables, Objects and Attributes<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="python%E5%8F%98%E9%87%8F%E8%B7%9FC%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">python变量跟C中变量的区别</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/07/25/c/struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/25/c/struct/" class="post-title-link" itemprop="url">结构体速记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-25 13:29:02" itemprop="dateCreated datePublished" datetime="2020-07-25T13:29:02+08:00">2020-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E9%87%8D%E5%AD%A6C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">重学C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>平时阅读 C 语言的代码，少不了要在各种形式的 struct 中周旋，特此记录，以备查阅。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><code>struct&#123; ... &#125; x, y, z;</code></p>
<p>此种方式指明了类型，并为其声明了变量，分配了存储空间。</p>
<p>但是这种方式没有对结构体类型命名，假如在程序的其它地方再次声明此种类型时会使程序膨胀极难维护。</p>
<p>因此，C 语言提供了两种方式来命名结构体类型：</p>
<ol>
<li>结构标记</li>
<li>typedef 定义</li>
</ol>
<h2 id="结构标记"><a href="#结构标记" class="headerlink" title="结构标记"></a>结构标记</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> on_hand;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>part</code> 就是创建的标记，之后可以使用它来声明变量了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part</span> <span class="title">part1</span>, <span class="title">part2</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>part</code> 不是类型名，因此 <code>struct</code> 关键字不能省略！</strong></p>
<p>另外，结构标记的声明可以和结构体变量的声明合并在一起，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> on_hand;    </span><br><span class="line">&#125; part1, part2;</span><br></pre></td></tr></table></figure>

<h2 id="typedef-定义"><a href="#typedef-定义" class="headerlink" title="typedef 定义"></a>typedef 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> on_hand;</span><br><span class="line">&#125; Part;</span><br></pre></td></tr></table></figure>

<p>类型 <code>Part</code> 的名字必须出现在定义的末尾，此后便可以像内置类型一样使用 <code>Part</code> 了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Part part1, part2;</span><br></pre></td></tr></table></figure>

<p>有两种使用 <code>typedef</code> 定义结构体类型的方法.</p>
<p>第一种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">Point</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point p1;</span><br><span class="line">    p1.x = <span class="number">1</span>;</span><br><span class="line">    p1.y = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, p1.x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, p1.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point p1;</span><br><span class="line">    p1.x = <span class="number">1</span>;</span><br><span class="line">    p1.y = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, p1.x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, p1.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>为什么 C 语言会提供两种方式的类型命名呢？其实 C 语言早期并没有 <code>typedef</code> ，所以标记是结构类型命名唯一的方法。当加入 typedef 时已经太晚了，标记已经无法删除了。</p>
<p>虽然我们可以使用任意一种方式来命名结构体类型，甚至可以同时具有标记和typedef：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">part</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> on_hand;</span><br><span class="line">&#125; Part;</span><br></pre></td></tr></table></figure>

<p>甚至标记的名字和typedef的名字都可以一样，但通常并不这么做，因为这在早期的编译器中会出现问题。</p>
<p>但是，有时候我们只能使用结构体标记，那就是结构体成员有自引用的时候，一个典型的例子就是链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下，如果没有标记 <code>node</code> 就无法声明 <code>next</code> 的类型。</p>
<h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><h3 id="声明时初始化"><a href="#声明时初始化" class="headerlink" title="声明时初始化"></a>声明时初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明同时进行初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125; s1 = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="number">89</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标记声明并初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> <span class="title">s2</span> =</span> &#123;<span class="string">&#x27;A&#x27;</span>, <span class="number">91</span>, <span class="string">&quot;Alan&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h3><p><code>C99</code> 中允许指定初始化，将点号和成员名称组合起来称为<code>指示符</code>，指定初始化的优点是初始化值的顺序不需要和声明时一致。如果初始化中有没有指定的成员，那么这些成员将被设为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> <span class="title">s2</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;YunYun&quot;</span>,</span><br><span class="line">        .c = <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">        .score = <span class="number">92</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>结构体数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_st</span> <span class="title">stus</span>[2] =</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .c = <span class="string">&#x27;D&#x27;</span>,</span><br><span class="line">        .score = <span class="number">94</span>,</span><br><span class="line">        <span class="comment">/*也可以只初始化部分成员*/</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .c = <span class="string">&#x27;D&#x27;</span>,</span><br><span class="line">        .score = <span class="number">94</span>,</span><br><span class="line">        .name = <span class="string">&quot;Xxx&quot;</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h3><p><code>C99</code> 中可以使用<code>复合字面量</code>来创建没有名字的数组，这通常用于函数的参数传递，以避免先创建变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = sum_array((<span class="type">int</span> [])&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>复合字面量的格式为：<strong>先在一对圆括号内给定类型名，随后在一对花括号内设定所包含的元素的值。</strong></p>
<p>同样，复合字面量也可以用于”实时“创建一个结构，而不需要将其存储在变量中。生成的结构也可以像参数一样传递，可以被函数返回，也可以赋值给变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看如下函数调用</span></span><br><span class="line">print_part((<span class="keyword">struct</span> part)&#123;<span class="number">528</span>, <span class="string">&quot;Disk drive&quot;</span>, <span class="number">100</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量赋值</span></span><br><span class="line">part1 = (<span class="keyword">struct</span> part)&#123;<span class="number">528</span>, <span class="string">&quot;Disk drive&quot;</span>, <span class="number">100</span>&#125;；</span><br></pre></td></tr></table></figure>

<p>细细体会一下变量赋值的例句，它有些类似于含有初始化的声明，但是并不完全一样，初始化只能出现在声明中，不能出现在赋值语句中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part1</span> =</span> &#123;<span class="number">528</span>, <span class="string">&quot;Disk drive&quot;</span>, <span class="number">100</span>&#125;; <span class="comment">// ok</span></span><br><span class="line">part1 = &#123;<span class="number">528</span>, <span class="string">&quot;Disk drive&quot;</span>, <span class="number">100</span>&#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/07/16/golang/three-index-slice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/16/golang/three-index-slice/" class="post-title-link" itemprop="url">Go 语言中的 Three-index slices</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-16 10:41:24" itemprop="dateCreated datePublished" datetime="2020-07-16T10:41:24+08:00">2020-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%81%87%E8%A7%81Go/" itemprop="url" rel="index"><span itemprop="name">遇见Go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近在看一段源码的时候，发现了一个从未见过的 slice 的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> batchSize &lt; <span class="built_in">len</span>(readValues) &#123;</span><br><span class="line">    rawValues[address] = readValues[<span class="number">0</span>:batchSize:batchSize]</span><br><span class="line">    address = address + <span class="number">1</span></span><br><span class="line">    readValues = readValues[batchSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>readValues[0:batchSize:batchSize]</code>为一个切片操作，但令人困惑的是其拥有3个索引值；这种书写形式在我读过的有限书籍中从未见过，官方的 <code>[Specification](https://golang.org/ref/spec)</code> 也没有找到相应的描述，所以打算将其弄个一清二楚。</p>
<p>经过一番 google 之后，<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjc5MzgxNzcvZ29sYW5nLXNsaWNlLXNsaWNpbmctYS1zbGljZS13aXRoLXNsaWNlYWJj">golang slice, slicing a slice with slice[a:b:c]<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI3Njg3NDQvcmUtc2xpY2luZy1zbGljZXMtaW4tZ29sYW5n">Re-slicing slices in Golang<i class="fa fa-external-link-alt"></i></span> 两篇问答让我顺藤摸瓜找到了源头，它源自 Go1.2 中的新特性——<span class="exturl" data-url="aHR0cHM6Ly90aXAuZ29sYW5nLm9yZy9kb2MvZ28xLjIjdGhyZWVfaW5kZXg=">Three-index slices<i class="fa fa-external-link-alt"></i></span>。</p>
<p>我们知道，一个 slice 由三个部分构成：<strong>指针、长度和容量</strong>:</p>
<ul>
<li>指针, 指向其第一个元素对应的底层数组元素的地址</li>
<li>长度,对应的是slice中的元素个数，也就是通过下标对slice中的元素进行访问时，不得超过长度的大小，否则会<code>panic</code></li>
<li>容量,<code>一般是</code>从slice的第一个元素位置到底层数据的结尾位置。</li>
</ul>
<p><code>slice[i:j:k]</code> 第二个冒号之后的索引便是<code>容量</code>，默认情况下的容量是这个slice能<code>hold</code>住的最大元素个数，也就是上文提到的从slice的第一个元素位置到底层数据的结尾位置，即使这个slice再被截取，容量也是从起始位置到底层数组的结尾位置。</p>
<p>那什么叫<code>hold</code>住呢？<code>长度以外容量以内</code>的元素又不能通过下标访问，这能叫<code>hold</code>么？当然，<code>长度以外容量以内</code>意味着你可以<code>append</code>，我们试举一例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">b := a[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(b[<span class="number">3</span>]) <span class="comment">// panic</span></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">100</span>)</span><br><span class="line">fmt.Println(b[<span class="number">3</span>])</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3 4 5 100 7 8 9 10]</span></span><br></pre></td></tr></table></figure>

<p>可以看到切片b的长度为3，直接通过下标访问b[3]会报运行时恐慌，而它的默认容量是8，所以可以append新值进去，并且最终修改了底层数组的值，通过打印切片a就可以看到底层数组也被修改了，a与b共享底层数组。</p>
<p>接下来我们使用第三个索引来指定切片的容量和长度一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := a[<span class="number">2</span>:<span class="number">5</span>:<span class="number">5</span>]</span><br><span class="line">c = <span class="built_in">append</span>(c, <span class="number">200</span>)</span><br><span class="line">fmt.Println(c) <span class="comment">// [3 4 5 200]</span></span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3 4 5 100 7 8 9 10]</span></span><br></pre></td></tr></table></figure>

<p>可见，切片a的内容并没有变，因为c的容量有限，append操作引起了扩容，从而使得切片c的底层数组与切片a的底层数组分道扬镳。<span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20v">码农桃花源<i class="fa fa-external-link-alt"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcWNyYW8tMjAxOC9wLzEwNjMxOTg5Lmh0bWw=">深度解密Go语言之Slice<i class="fa fa-external-link-alt"></i></span>中对于数组扩容有更精彩的图文论述，其中也有<code>data[low:high:max]</code>的论述，只是当时阅读数未曾引起重视。</p>
<p>官网用于说明的例子是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>一句话来表述容量被限制之后的结果：<code> It is impossible to use this new slice value to access the last three elements of the original array.</code> </p>
<p>这个特性偶尔会很有用，比如在处理底层的[]byte时，如果很清楚调用者不会去修改slice中的值，那么就可以使用这种方式来更好的保护底层的数组，正如我开篇提到的那段代码一样。</p>
<p>三个索引值，第一个可以省略，如果省略就代表 0.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/03/24/c/static-link-dynamic-link-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/24/c/static-link-dynamic-link-1/" class="post-title-link" itemprop="url">重学C语言：编译和链接那些事儿（一）—— 编译过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-24 13:29:02" itemprop="dateCreated datePublished" datetime="2020-03-24T13:29:02+08:00">2020-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>大学时用 Turbo C 2.0 学 C 语言，只记得是蓝底黄字的丑陋界面，不清楚编译完的程序有何用处，也不知道编译和链接这些基本概念。现在想来只学到了 C 的语法，几年下来也忘得精光。本篇以 Linux 下 GCC 为例，简单描述编译链接的过程。</p>
</blockquote>
<h2 id="GCC-隐藏的细节"><a href="#GCC-隐藏的细节" class="headerlink" title="GCC  隐藏的细节"></a>GCC  隐藏的细节</h2><p>我们首先使用 GCC 来编译并运行一个经典的hello world程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 GCC 来编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;14:59&#125;~/Learing/c/src:master ✗ ➭ gcc hello.c </span><br><span class="line">&#123;14:59&#125;~/Learing/c/src:master ✗ ➭ ls  </span><br><span class="line"> a.out   hello.c</span><br><span class="line">&#123;14:59&#125;~/Learing/c/src:master ✗ ➭ </span><br></pre></td></tr></table></figure>

<p>可以看到在不指定 <code>-o</code>选项的时候，默认生成了一个 <code>a.out</code>文件，这就是最后的可执行程序，我们来执行它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;14:59&#125;~/Learing/c/src:master ✗ ➭ ./a.out </span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>程序向标准输出打印了 <code>hello world!</code>，我们的程序执行成功。但是 GCC 期间做了哪些工作？<code>a.out</code> 是一步生成的么？</p>
<p>事实上，这个默认过程至少经历了四个阶段，分别是<code>预处理</code>、<code>编译</code>、<code>汇编</code>和<code>链接</code>，如下图所示：</p>
<p><img data-src="http://qiniu.liupzmin.com/compile.png" alt="GCC 编译分解过程"></p>
<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>第一阶段的工作就是预处理，由预处理器完成，处理和源代码相关的头文件，生成一个 <code>.i</code> 后缀的中间文件。C 预处理器（C Pre-Processor）也常简写为 CPP，是一个与 C 编译器独立的小程序，预编译器并不理解 C 语言语法，它仅是在程序源文件被编译之前，实现文本替换的功能。可以使用 GCC 的 <code>-E</code> 选项来控制只进行预编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>

<p>预编译阶段主要是处理源文件中以 <code>#</code>开头的预编译指令。比如 <code>#include</code> 、<code>#define</code> 等，主要的规则如下：</p>
<ul>
<li>将所有的 <code>#define</code> 删除，并展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，比如 <code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>。</li>
<li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其它文件。</li>
<li>删除所有的注释 <code>//</code> 和 <code>/* */</code>。</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>接下来就是整个程序构建最核心的阶段—<code>编译</code>，通过对预处理阶段产生的结果文件进行一些列的词法分析、语法分析、语义分析以及某些编译器优化之后生成<code>汇编代码文件</code>。编译的过程可以使用如下命令单独进行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>

<p>其实目前的 GCC 已经将预编译和编译两个阶段合而为一了，使用一个叫 <code>ccl</code> 的程序来完成这两个步骤，我的机器上这个程序在 <code>/usr/lib/gcc/x86_64-pc-linux-gnu/9.3.0/cc1</code> ，我们可以直接调用它来完成预编译和编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;16:12&#125;~/Learing/c/src:master ✗ ➭ /usr/lib/gcc/x86_64-pc-linux-gnu/9.3.0/cc1 hello.c</span><br><span class="line"> main</span><br><span class="line">Analyzing compilation unit</span><br><span class="line">Performing interprocedural optimizations</span><br><span class="line"> &lt;*free_lang_data&gt; &lt;visibility&gt; &lt;build_ssa_passes&gt; &lt;opt_local_passes&gt; &lt;remove_symbols&gt; &lt;targetclone&gt; &lt;free-fnsummary&gt;Streaming LTO</span><br><span class="line"> &lt;whole-program&gt; &lt;fnsummary&gt; &lt;inline&gt; &lt;free-fnsummary&gt; &lt;single-use&gt; &lt;comdats&gt;Assembling functions:</span><br><span class="line"> &lt;materialize-all-clones&gt; &lt;simdclone&gt; main</span><br><span class="line">Time variable                                   usr           sys          wall               GGC</span><br><span class="line"> phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.01 ( 33%)    1220 kB ( 70%)</span><br><span class="line"> phase parsing                      :   0.02 (100%)   0.00 (  0%)   0.01 ( 33%)     459 kB ( 26%)</span><br><span class="line"> phase opt and generate             :   0.00 (  0%)   0.00 (  0%)   0.01 ( 33%)      58 kB (  3%)</span><br><span class="line"> preprocessing                      :   0.01 ( 50%)   0.00 (  0%)   0.00 (  0%)     136 kB (  8%)</span><br><span class="line"> lexical analysis                   :   0.01 ( 50%)   0.00 (  0%)   0.01 ( 33%)       0 kB (  0%)</span><br><span class="line"> initialize rtl                     :   0.00 (  0%)   0.00 (  0%)   0.01 ( 33%)      12 kB (  1%)</span><br><span class="line"> TOTAL                              :   0.02          0.00          0.03           1747 kB</span><br></pre></td></tr></table></figure>

<p>或者，可以直接通过 <code>gcc</code> 和源文件来编译成汇编代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure>

<p>通过这些方式都可以得到 <code>hello.s</code> 的汇编文件。事实上 <code>GCC</code> 是个编译工具集，会根据不同的情况调用不同的工具处理每阶段的工作，比如编译时调用 <code>ccl</code>，汇编时调用 <code>as</code>，链接时调用 <code>ld</code>。</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>正如前文所言，当编译完成得到汇编文件之后，接下来的工作就交给汇编器来执行了，汇编器是将汇编代码转变成机器指令的工具，每一条汇编语句几乎都对应一条机器指令。所以汇编器的活儿相对来说比较简单，只是把汇编指令跟机器指令对照翻译一下，当然翻译完文件就由可读的汇编代码变为只有机器才可以看懂的二进制文件了。对于上面得汇编文件我们可以使用 <code>as</code> 来完成汇编：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>或者使用 GCC 的 <code>-c</code> 选项，它的意思是编译或者汇编源文件，但不进行链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>或者直接从 C 文件到<code>目标文件</code>（Object File 的概念非常重要，但此处不展开，留待以后单独讨论）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>到这里，我们距离生成最后的可执行文件只有一步之遥，让我们来调用 <code>ld</code> 来生成最后的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/9.3.0/crtbeginT.o -L /usr/lib/gcc/x86_64-pc-linux-gnu/9.3.0 -L /usr/lib -L /lib hello.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-pc-linux-gnu/9.3.0/crtend.o /usr/lib/crtn.o -o hello</span><br></pre></td></tr></table></figure>

<p>执行 <code>hello</code> 程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;17:00&#125;~/Learing/c/src:master ✗ ➭ ./hello </span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>程序成功执行并输出了 <code>hello world!</code>，但是我们可以看到上面的 <code>ld</code> 命令链接了一大堆的文件才最后生成 <code>hello</code> 可执行文件。</p>
<p>初学者很容易产生的疑问就是：汇编完成的之后的文件不就是二进制文件么？为什么还要进行链接这个步骤呢？链接到底干了些啥？为什么不直接生成最后的可执行文件呢？要说清楚这些问题并不是一件很容易的事，可以说是一件异常困难的事，这里面涉及到静态链接、动态链接、静态库、动态库、运行时库、标准库、链接器等一系列的问题，以至于<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zNjUyMzg4Lw==">《程序员的自我修养》<i class="fa fa-external-link-alt"></i></span>用了整整一部书来讲链接这件事情，所以囫囵吞枣看个大概的想法，也是何其难哉！</p>
<p>但这正是我想写这一系列文章的初衷，我希望我能将这些概念总结出来，略去一些细节，只保留轮廓，便于记忆，同时也给初学者以借鉴。</p>
<p>本篇文章先简单描述编译的过程，下一篇文章我们谈静态链接。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/03/19/c/operator-precedence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/19/c/operator-precedence/" class="post-title-link" itemprop="url">重学C语言：运算符与优先级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-19 10:20:42" itemprop="dateCreated datePublished" datetime="2020-03-19T10:20:42+08:00">2020-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>C 语言有很多种运算符（差不多50种），如果一条表达式中有多个运算符，就不可避免的产生二义性．C 语言通过优先级与结合性来解决这个问题，因运算符过多，优先级难以全部准确记忆，故将运算符优先级表记录在此，以备日后有疑问时进行查阅．</p>
</blockquote>
<p><img data-src="http://qiniu.liupzmin.com/operator-precedence.png" alt="C 运算符优先级"></p>
<h2 id="运算符的种类"><a href="#运算符的种类" class="headerlink" title="运算符的种类"></a>运算符的种类</h2><p>常用的运算符有如下几类：</p>
<ol>
<li>算数运算符（<code>+ - * / % ++ --</code>）</li>
<li>关系运算符（<code>== != &gt; &lt; &gt;= &lt;=</code>）</li>
<li>逻辑运算符（<code>&amp;&amp; || !</code>）</li>
<li>位运算符（<code>&amp; | ^</code>）</li>
<li>赋值运算符（<code>= += -+ *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code>）</li>
<li>杂项运算符（<code>sizeof() &amp; * ?:</code>）</li>
</ol>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p><code>+</code>和<code>-</code>既可以是一元运算符正负号，又可以是二元运算符加减．一元运算符优先级要高于二元运算符．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i + j / k; <span class="comment">// 等价于 (-i) + ( j / k)</span></span><br></pre></td></tr></table></figure>

<p>当表达式中包含两个或者更多个相同优先级的运算符时，就需要根据<code>结合性</code>的规则来运算．</p>
<p>如果运算符是从左向右结合的，就称为<code>左结合</code>，如果是从右像左结合的就称为<code>右结合</code>．二元算数运算符都是左结合的．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i - j - k; <span class="comment">// 等价于 (i - j) - k</span></span><br><span class="line">i * j / k; <span class="comment">// 等价于 (i * j) / k</span></span><br></pre></td></tr></table></figure>

<p>一元算数运算符都是右结合的．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- + i; <span class="comment">// 等价于 -(+i)</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>在许多编程语言中，赋值是<code>语句</code>．然而，在C语言中，赋值就像 <code>+</code> 一样是<code>运算符</code>．换句话说，赋值操作产生结果，就如同两数相加产生结果一样．赋值表达式 <code>v=e</code> 的值就是赋值运算后 v 的值.</p>
<p>既然赋值是运算符，那么多个赋值就可以串联在一起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = j = k = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>运算符 <code>=</code> 是右结合的，所以上述表达式等价于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (j = (k = <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>有一个例子来说明赋值表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span> <span class="params">(<span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = s1;</span><br><span class="line">    <span class="keyword">while</span> (*p)</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">while</span> (*p++ = *s2++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个字符串拼接函数，函数中的两个 while 循环的条件表达式都是赋值表达式，因此除了<code>空字符</code>以外所有的字符都为真，当指针到达字符串末尾的 <code>&#39;\0&#39;</code> 时，表达式的值为　<code>0</code>.</p>
<h2 id="自增运算符和自减运算符"><a href="#自增运算符和自减运算符" class="headerlink" title="自增运算符和自减运算符"></a>自增运算符和自减运算符</h2><p>自增自减运算符略微有些复杂，那是因为它们既可以作为前缀又可以作为后缀，而且它们还有个副作用就是:<code>会改变操作数的值</code>.</p>
<p>因此，使用自增自减运算符时，我们要谨记两点：</p>
<ol>
<li>表达式的值</li>
<li>操作数的值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i++); <span class="comment">// prints &quot;i is 1&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i);   <span class="comment">// prints &quot;i is 2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, ++i); <span class="comment">// prints &quot;i is 2&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i);   <span class="comment">// prints &quot;i is 2&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>i++</code> 先赋值再自增，<code>++i</code> 先自增再赋值．</p>
<p>需要注意的是，后缀运算符要比前缀运算符优先级要高，从文章开头的表格中可以看到，后缀自增自减优先级为 1，前缀自增自减优先级为 2．</p>
<p>试想一下，对于 <code>*p++;</code>　语句，自增的是指针还是指针指向的值呢？</p>
<p>很多地方包括 K&amp;R 都是这样解释：尽管 * 和 ++ 的优先级相同，但由于连接的规则是从右往左，所以 p 先和 ++ 进行连接．因此，被自增的不是 *p 而是 p．</p>
<p>对照开头的优先级表，后缀 ++ 优先级要比间接寻址运算符 * 高，因此被进行加法的不是 *p 而是 p．</p>
<p>从语法上看，这种解释才比较合理．</p>
<h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>C 语言有一条不同寻常的规则，那就是任何表达式都可以用作语句．换句话说，不论表达式是什么类型，计算什么结果，我们都可以通过在后面添加分号将其转化为语句．例如，可以把表达式 ++i 转换为语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i++;</span><br></pre></td></tr></table></figure>

<p>i 先自增再赋值，但是值会被丢弃，接着执行下一条语句．</p>
<h2 id="一个优先级引起的错误"><a href="#一个优先级引起的错误" class="headerlink" title="一个优先级引起的错误"></a>一个优先级引起的错误</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="type">char</span> sendline[MAXLINE];</span><br><span class="line">    <span class="type">char</span> recieve[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 消除字符串中的换行符</span></span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">strlen</span>(sendline);</span><br><span class="line">        <span class="keyword">if</span> (sendline[i - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sendline[i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((n = read(sockfd, recieve, MAXLINE) == <span class="number">0</span>))</span><br><span class="line">            err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line"></span><br><span class="line">        recieve[n] = <span class="number">0</span>;</span><br><span class="line">        Fputs(recieve, <span class="built_in">stdout</span>);</span><br><span class="line">        Fputs(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我编写的一个 socket 客户端的代码，我在读取 socket 描述符中的内容时犯了错误，在 if 条件中的括号放错了位置，这导致我原本想要进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n = read(sockfd, recieve, MAXLINE)) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>变成了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n = read(sockfd, recieve, MAXLINE) == <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>也就是条件变成了 <code>n = read() == 0</code>，对照优先级表，关系运算符 <code>==</code> 要比赋值运算符 <code>=</code> 优先级高，所以这里先进行 read　读取，再与0进行判等，当有正常内容被读出的时候，结果为假，之后赋值给 n，这里 n 会变成 0，进而造成 recieve 被置空．</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/02/26/network/tcp-time-wait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/26/network/tcp-time-wait/" class="post-title-link" itemprop="url">好朋友 TIME_WAIT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-26 15:18:20" itemprop="dateCreated datePublished" datetime="2020-02-26T15:18:20+08:00">2020-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP-IP/computer-theory/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>今天这篇文章我准备说一说 <code>TIME_WAIT</code> ，我相信很多人在工作中都或多或少遇到 TIME_WAIT 的情况，而且在面试中也经常被问到 <code>遇到大量的 TIME_WAIT 时应该怎么办？</code>这样的问题。 因为对 TIME_WAIT 这个状态印象并不是很深，所以被问到类似问题的时候也经常说不出所以然，因此，我花了很长的时间深入研究了一下 TCP 的相关问题，然后在此记录一下。</strong></p>
<p>先放一个 TCP Header 在这里。</p>
<p><img data-src="http://qiniu.liupzmin.com/tcp-header.jpg" alt="TCP 头格式"></p>
<h2 id="什么是-TIME-WAIT"><a href="#什么是-TIME-WAIT" class="headerlink" title="什么是 TIME_WAIT"></a>什么是 TIME_WAIT</h2><p><code>TIME_WAIT</code> 是 TCP 状态机中的一个，它出现在连接正常断开的时候。</p>
<p><img data-src="http://qiniu.liupzmin.com/tcp-state.png" alt="Figure 1. The TCP state transition diagram"></p>
<p>从状态转换图中可以看出，<code>TIME_WAIT</code> 是断开连接时的最后一个状态，其上有个计时器表示连接在 <code>TIME_WAIT</code> 这个状态停留的时长为 <code>2MSL(Maximum Segment Lifetime)</code>，意为 2 个最大报文生存时间（ <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5MyNwYWdlLTI4">RFC793<i class="fa fa-external-link-alt"></i></span> 定义了MSL为2分钟，然而在常见的实现中有 30s，1 分钟，2 分钟的情况；其中 Linux 设置成了 30s，并且是硬编码无法更改，除非重新编译内核；Windows 下默认是 1 分钟，且可以修改）。</p>
<p>大部分人对 <code>TIME_WAIT</code> 的第一印象并不好，但是 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTkwJTg2JUU2JTlGJUE1JUU1JUJFJUI3JUMyJUI3JUU1JThGJUIyJUU4JTkyJTgyJUU2JTk2JTg3JUU2JTk2JUFG">Richard Stevens<i class="fa fa-external-link-alt"></i></span> 在他的 <span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8xNTAwMTQ5Lw==">《UNIX网络编程》<i class="fa fa-external-link-alt"></i></span>一书中却说道：<code>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它。</code></p>
<p>这也正是我所希望的，让我们从 TCP 的四次挥手说起。</p>
<p><img data-src="http://qiniu.liupzmin.com/tcp-3estab-4term.png" alt="Figure 2. TCP states corresponding to normal connection establishment and termination"></p>
<p>从上图我们可以看出 TCP 四次挥手的过程：</p>
<ol>
<li>客户端调用 close()，协议层发送 FIN 报文表示主动断开连接，而后进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到客户端发送的 FIN ，返回一个 ACK 通知对端：我已知晓，并进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到 ACK 后进入 <code>FIN_WAIT_2</code> 状态，等待服务端应用程序调用 close()操作。</li>
<li>服务端处理完数据之后调用 close()，协议层发送 FIN 报文给客户端，等待 ACK，然后进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到 FIN 报文之后发送 ACK，并进入 <code>TIME_WAIT</code> 状态。</li>
<li>服务端收到 ACK 之后进入 <code>CLOSED</code> 状态。</li>
<li>客户端等待 <code>2*MSL</code> 时间后进入 <code>CLOSED</code> 状态。</li>
</ol>
<p>通过上面的步骤我们可以得出以下几点：</p>
<ol>
<li>只有主动关闭的一方才会进入 <code>TIME_WAIT</code>，这既可以发生在客户端，也可以发生在服务端。</li>
<li><code>TIME_WAIT</code> 会持续 <code>2*MSL</code> 的时间，之后进入<code>CLOSED</code> 状态。</li>
<li>在连接没有进入 <code>CLOSED</code> 之前是无法被重用的。</li>
</ol>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><p>在继续深入讨论 <code>TIME_WAIT</code> 之前，我们先来明确几个术语概念：</p>
<ul>
<li><strong>TTL （Time-to-Live）</strong>，意为生存期，它是 IP 头部的一个字段，用于设置一个数据报可经过的路由器的数量上限。发送方将它初始化为某个值（RFC 建议设为 64，但是 128 或 255 也不少见），每个路由器在转发数据报时将该值减 1。当这个字段达到 0 时，该数据报被丢弃，用于防止路由环路导致数据报在网络中永远循环。有意思的是最初 TTL 这个字段意思是指定 IP 数据报在网络上的最大生存秒数，但路由器总需要将这个值至少减 1。实际上，路由器在正常操作下通常不会持有数据报超过 1 秒钟，因此较早的规则早已被遗忘，这个字段在 IPv6 中根据实际用途已被重命名为跳数限制。</li>
<li><strong>MSL（Maximum Segment Lifetime）</strong>，意为最大报文生存时间，是 TCP 协议中的概念，指的是一个 TCP 的 Segment 在网络上生存的最大时间。很多书籍中都提到 MSL 是由 IP 层的 TTL 来保证的，但 TTL 和 MSL 不绝对相等，一般 MSL 会大于 TTL。我观 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5Mw==">RFC793<i class="fa fa-external-link-alt"></i></span> 中使用了 <strong>assume</strong> 一词（<code>Since we assume that segments will stay in the network no more than the Maximum Segment Lifetime</code>），所以我理解 TCP 并不会保证一个报文的最大生存时间，只是将 MSL 作为前提假设进行协议上的设计。</li>
<li><strong>SN（Sequence Number）</strong>，<code>序列号</code>是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。SN 是一个 32 位的无符号数，因此在到达 $2^{32} -1$ 之后再循环回到 0。</li>
<li><strong>ISN（Initial Sequence Number）</strong>，<code>初始序列号</code> 是一个连接建立之前双方商议的初始的序列号，也就是传输的第一个字节的编号（通常是 SYN 位，因为 SYN 消耗一个序列号，相对的 ACK 不会消耗序列号，毕竟 SYN 和 FIN 是要保证可靠传输的）。很显然这个初始序列号不能是 0 或者 1，它必须是一个随机的数，并会随时间改变，这样每一个连接都拥有不同的<code>初始序列号</code>。<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5MyNwYWdlLTI3">RFC793<i class="fa fa-external-link-alt"></i></span> 指出初始化序列号可被视为一个32位的计数器，该计数器的数值每 4 微秒加 1，这样循环一次需要 4.55 小时。此举的目的在于为一个连接的报文段安排序列号，以防止出现与其它连接的序列号重叠的情况，尤其是对于同一个连接的两个不同实例（也叫不同的化身）而言，新的序列号也不能出现重叠的情况。</li>
</ul>
<p><strong>解释一下所谓的<code>同一个连接的不同实例</code>，我们知道标识一个连接需要 2 个 IP 和 2 个端口号，称为四元组。如果再加上协议类型就称为五元组，因为我们只讨论 TCP，所以也可以直接叫四元组。所谓的同一个连接的不同实例是指一个连接关闭后，又以相同的四元组打开了一个新的连接，通常称老的连接为前一个化身。</strong></p>
<p>试想一下，一个连接因为某种原因被关闭，紧接着又以相同的四元组被重新建立。如果这时旧连接的一个延时的报文又到达了，碰巧这个延时的报文段的序列号对新连接又是有效的，那么这个报文就会被视为有效的数据进入新连接的数据流中。TCP 的很多设计目标都是为了避免这种恼人的情况，更为复杂的是随着网路性能的提升，带宽的增加，这种问题甚至出现在同一个连接实例当中，因为 SN 这个 32 位的字段也是要回绕重用的，如果一个回绕的时间太短，小于一个 MSL 的时候，我们也要面对延时报文的问题。</p>
<p> <code>TIME_WAIT</code> 的设计初衷就是为了解决 TCP 新旧连接延迟报文的。</p>
<h2 id="TIME-WAIT-的目的"><a href="#TIME-WAIT-的目的" class="headerlink" title="TIME_WAIT 的目的"></a>TIME_WAIT 的目的</h2><p><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExODUjcGFnZS0xMg==">RFC1185<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEzMjMjcGFnZS0yOA==">RFC1323<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzczMjMjcGFnZS0zNQ==">RFC7323<i class="fa fa-external-link-alt"></i></span> 中阐明了 <code>TIME_WAIT</code> 存在的两个目的：</p>
<ol>
<li>可靠的实现 TCP 全双工连接的终止。</li>
<li>允许老的重复的报文段在网络中消失。</li>
</ol>
<p>第一个理由可以通过查看 <code>Figure 2</code> 四次挥手过程，并假设最终的 ACK 丢失来解释。这时服务端将重新发送它的最后的那个 FIN，因此客户端必须维护状态信息，以允许它重新发送最终的 ACK。要是客户端不维护状态信息，其所在的服务器将响应一个 RST，服务端将收到这个 RST 并将其解释为一个错误，这对于一个可靠的协议来说是不完美的终止方式。为了防止这种情况出现，客户端必须等待足够长的时间确保对端收到 ACK，如果对端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。但是你可能会说重新发送的 ACK 还是有可能丢失啊，没错，但 TCP 已经等待了那么长的时间了，已经算仁至义尽了。</p>
<p>为了理解第二个理由必须要很好的理解 <code>Squence Number</code> 和 <code>ISN</code>，也就是<code>序列号</code>和<code>初始序列号</code>，我们再次强调：<strong>TCP 是面向字节流的协议。</strong> 为了解决可靠传输和乱序问题，<strong>TCP 为每一个传输的字节都编上了号</strong>，TCP 头部的 squence number 表示的是该报文中携带数据的第一个字节的编号，下图可以形象的说明这一点：</p>
<p><img data-src="http://qiniu.liupzmin.com/dividing-data-into-tcp-segments.png" alt="Figure 3. 文件数据划分成 TCP 报文段"></p>
<p>图中例子假设主机 A 上的一个进程想通过一条 TCP 连接向主机 B 上的一个进程发送一个数据流，这个数据流可能是一个文件。主机 A 中的 TCP 将隐式的对数据流中的每一个字节编号。假定该字节流是一个由 500000 字节的文件组成，其 MSS 为 1000 字节，数据流的首字节编号为 0。如图所示，TCP 将构建 500 个报文段，给第一个报文段分配序号 0，第二个报文段分配序号 1000，第三个报文段分配序号 2000，以此类推。每一个序号被填入到相应的 TCP 报文段头部的序列号字段中。</p>
<p>这个例子中我们假定数据流的首字节编号从 0 开始是不准确的，因为 SYN 消耗一个序列号，所以第一个字节总是 ISN 加上 1。前面讲到 ISN 是一个基于时间的计数器，它是一个随机值，每 4.55 小时回绕一次。相似地，Sequence Number 也是一个 32 位的循环使用字段。也就是说，大约每传送 4GB 的数据之后，序列号就会回到最初的值（也就是 ISN，因为当达到最大值时会再从 0 开始一直加到 ISN），如此循环往复。</p>
<p>有了上面的基本概念，我们现在就可以假设如下情况了。</p>
<p>一个由四元组标识的唯一连接，因某种原因被关闭。但随即以相同的四元组重新打开。那么这是同一个连接的新化身（incarnation），这个时候 TCP 必须要防止前一个连接的老的报文段因为网络延迟而重新到达，以致被误解为新连接的数据。如 <code>Figure 4</code> 所示：</p>
<p><img data-src="http://qiniu.liupzmin.com/duplicate-segment.png" alt="Figure 4. Due to a shortened TIME-WAIT state, a delayed TCP segment has been accepted in an unrelated connection."></p>
<p>图中该连接的前一个化身序列号为 3 的报文段超时重传了，之后连接关闭。假设没有经过 <code>TIME_WAIT</code>，或者 <code>TIME_WAIT</code> 的时间很短，在新的连接化身刚刚发送完序列号为 2 的报文段之后，前一个化身迷途的 <code>seq=3</code> 的报文段又抵达了。TCP 必须防止这种情况。</p>
<p>为了做到这一点，TCP 设计了 <code>TIME_WAIT</code> 。它会锁定这个四元组 <code>2*MSL</code> 的时间 ，这期间不允许以相同的四元组打开新连接，我们知道 MSL 是 TCP 报文段最大的网络生存时间，那么 <code>2*MSL</code> 足以让这个连接上的所有延迟的报文被丢弃，通过 <code>TIME_WAIT</code> 这个规则，我们就能保证每成功建立一个 TCP 连接时，来自该连接先前化身的老的重复的报文都已在网络中消逝了。</p>
<p>前一个连接的老的报文给当前的连接造成错乱的前提是其携带的序列号刚好在当前的连接有效，虽然这不太可能发生，但是因为 ISN 和 SN 两个字段值都是会 <code>wrap around（回绕）</code> 的，所以理论上是会出现这种情况的，<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExODUjcGFnZS0xNQ==">RFC1185<i class="fa fa-external-link-alt"></i></span> 中有针对该问题详细的讨论描述，我们借用里面的图来说明这种情况。</p>
<p>为了应对老的重复报文，Tomlinson 提出了基于时间驱动的 ISN 方案，但这个方案只对短连接和传输速率慢的连接有效，如下图所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    |- 2**32       ISN             ISN</span><br><span class="line">    |              *               *</span><br><span class="line">    |             *               *</span><br><span class="line">    |            *               *</span><br><span class="line">    |           *x              *</span><br><span class="line">    |          o               *</span><br><span class="line">^   |         *               *</span><br><span class="line">|   |        *  x            *</span><br><span class="line">    |       * o             *</span><br><span class="line">S   |      *o              *</span><br><span class="line">e   |     o               *</span><br><span class="line">q   |    *               *</span><br><span class="line">    |   *               *</span><br><span class="line">#   |  * x             *</span><br><span class="line">    | *o              *</span><br><span class="line">    |o_______________*____________</span><br><span class="line">                     ^         Time --&gt;</span><br><span class="line">                   4.55hrs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Figure 5.  Clock-Driven ISN  avoiding duplication on</span><br><span class="line">            short-Lived, slow connections.</span><br></pre></td></tr></table></figure>

<p>横轴为时间，纵轴为序列号或初始序列号（它们本质上是同一个东西，ISN 只是以某种方式选择的序列号初始值），<code>*</code> 代表 ISN，<code>o</code> 代表同一个短时连接的不同化身的轨迹，其序列号在 <code>x</code> 处终止。因为<code>慢</code>，所以每个化身序列号的增长曲线是低于 ISN 的增长曲线的。也就是说，此时没有 <code>TIME_WAIT</code> 也一样能排除老的重复报文段，因为每个化身的 ISN 均会保证大于前一个化身最后使用的序列号。只要一个报文段的序列号小于当前连接的初始序列号，TCP 自动就可以识别出来从而将其丢弃。但是，对于长连接或者一个快速的网络环境中，仅仅是 ISN 就不能保证这一点了：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    |- 2**32       ISN               ISN</span><br><span class="line">    |              *                 *</span><br><span class="line">    |             *                 *</span><br><span class="line">    |            *                 *</span><br><span class="line">    |           *                 *</span><br><span class="line">    |          *                 *</span><br><span class="line">^   |         *                 *</span><br><span class="line">|   |        *                 *</span><br><span class="line">    |       *                 *</span><br><span class="line">S   |      *                 *</span><br><span class="line">e   |     *                x*</span><br><span class="line">q   |    *           o     *</span><br><span class="line">    |   *      o          *</span><br><span class="line">#   |  *o                *</span><br><span class="line">    | *                 *</span><br><span class="line">    |*_________________*____________</span><br><span class="line">                       ^         Time --&gt;</span><br><span class="line">                      4.55hrs</span><br><span class="line"></span><br><span class="line">    Figure 6.  Slow, Long-Lived Connection</span><br></pre></td></tr></table></figure>

<p>如图 <code>Figure 6</code> ,一个长连接且慢速传输的情况，如果 ISN 回绕到与 seq 相同的值时，连接关闭又随即重新打开，那么正在传输中的老的连接的报文段就很可能会进入新连接的窗口中。</p>
<p>在一个高性能的快速的网络环境中，问题更显复杂。因为这时有两种情况使得老的报文段可能造成问题，先看第一种：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    |- 2**32       ISN               ISN</span><br><span class="line">    |              *                 *</span><br><span class="line">    |       x   o *                 *</span><br><span class="line">    |            *                 *</span><br><span class="line">    |      o--&gt;o*                 *</span><br><span class="line">    |          *                 *</span><br><span class="line">^   |     o   o                 *</span><br><span class="line">|   |        *                 *</span><br><span class="line">    |    o  *                 *</span><br><span class="line">S   |      *                 *</span><br><span class="line">e   |   o *                 *</span><br><span class="line">q   |    *                 *</span><br><span class="line">    |  o*                 *</span><br><span class="line">#   |  *                 *</span><br><span class="line">    | o                 *</span><br><span class="line">    |*_________________*____________</span><br><span class="line">                       ^         Time --&gt;</span><br><span class="line">                      4.55hrs</span><br><span class="line"></span><br><span class="line"> Figure 7.  Duplication on Fast Connection: Nc &lt; 2**32 bytes</span><br></pre></td></tr></table></figure>

<p>如图 <code>Figure 7</code> 所示是连接传输的字节小于 <code>4GB</code> 的情况，并在序列号 <code>x</code> 处连接关闭或者崩溃，紧接着一个新的化身被建立，而此时的 ISN 尚远远小于 <code>x</code> 的值。这样前一个化身的老的重复的报文段很轻易的就侵入到当前的连接。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    |- 2**32       ISN               ISN</span><br><span class="line">    |      o       *                 *</span><br><span class="line">    |           x *                 *</span><br><span class="line">    |            *                 *</span><br><span class="line">    |     o     *                 *</span><br><span class="line">    |          o                 *</span><br><span class="line">^   |         *                 *</span><br><span class="line">|   |    o   *                 *</span><br><span class="line">    |       * o               *</span><br><span class="line">S   |      *                *</span><br><span class="line">e   |   o *                 *</span><br><span class="line">q   |    *   o             *</span><br><span class="line">    |   *                 *</span><br><span class="line">#   |  o                 *</span><br><span class="line">    | *     o           *</span><br><span class="line">    |*_________________*____________</span><br><span class="line">                       ^         Time --&gt;</span><br><span class="line">                      4.55hrs</span><br><span class="line"> Figure 8.  Duplication on Fast Connection: Nc &gt; 2**32 bytes</span><br></pre></td></tr></table></figure>

<p>图 <code>Figure 8</code> 所示是连接传输的字节大于 <code>4GB</code> 的情况，且序列号已经回绕（wrap around），原本已经分离的曲线，在序列号回绕到 <code>x</code> 处时又相交了。一旦窗口有重合，老的延迟报文段就会造成问题。</p>
<p>通过上面的图例，我们能得出一个结论：<strong>只要新连接的 ISN 大于前一个化身的最终序列号，那么问题便会迎刃而解</strong>。果不其然，Garlick, Rom, and Postel 在 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExODUjcGFnZS0xOQ==">RFC1185<i class="fa fa-external-link-alt"></i></span> 中提出了这样的想法：<strong>由 TCP 维护每一个连接的最终序列号，当新的连接被打开的时候，保证 ISN 的值永远大于上一个化身的最终使用序列号</strong>。</p>
<p>但是，貌似这个方案没有被最终采用，TCP 选择了 <code>ISN</code> 以及 <code>TIME_WAIT</code>。</p>
<h2 id="TIME-WAIT-造成的影响"><a href="#TIME-WAIT-造成的影响" class="headerlink" title="TIME_WAIT 造成的影响"></a>TIME_WAIT 造成的影响</h2><p><code>TIME_WAIT</code> 主要造成的影响有两个方面：</p>
<ol>
<li><code>TIME_WAIT</code> 会长时间占用（<code>2*MSL</code>）一个四元组连接，这可能导致后续相同元组的连接创建失败。</li>
<li><code>2*MSL</code> 期间内核需要维持该 SOCKET 的数据结构，因此数量过多的话会消耗内存、并且增加内核遍历有关 hash table 的时间（更消耗CPU），从而导致性能问题。</li>
</ol>
<p>因为处于 <code>TIME_WAIT</code> 等待状态的连接可能要花费 1 ~ 4 分钟才能进入 <code>CLOSED</code> 的状态并释放相应的四元组，所以在 <code>TIME_WAIT</code> 等待期间具有相同四元组的连接便不能建立。这是很多人对 <code>TIME_WAIT</code> 深恶而痛绝之的根源。</p>
<p>资源不能重用算是一个痛恨的理由，但第二个理由却值得细细推敲一番。多少 <code>TIME_WAIT</code> 算多呢？一千个？一万个？其实这个量级根本不用在乎，<code>TIME_WAIT</code> 所占用的内存很少，主要涉及到两个内核结构：</p>
<ol>
<li><p>内核里有保存所有连接的一个 hash table，这个 hash table 里面既包含 TIME_WAIT 状态的连接，也包含其他状态的连接。主要用于有新的数据到来的时候，从这个 hash table 里快速找到这条连接。不同的内核对这个 hash table 的大小设置不同，你可以通过 dmesg 命令去找到你的内核设置的大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# dmesg |grep &quot;TCP established hash table&quot;</span><br><span class="line">[    0.204805] TCP established hash table entries: 16384 (order: 5, 131072 bytes)</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一个 hash table 用来保存所有的 bound ports，主要用于可以快速的找到一个可用的端口或者随机端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# dmesg |grep &quot;TCP bind hash table&quot;</span><br><span class="line">[    0.207227] TCP bind hash table entries: 16384 (order: 6, 262144 bytes)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>由于内核要保存这些数据，所以会占用一部分内存。<strong>那么会消耗 CPU 么？</strong></p>
<p><strong>当然！</strong>每次找到一个随机端口，还是需要遍历一遍  bound ports 的吧，这必然需要一些 CPU 时间。</p>
<p>TIME_WAIT 很多，既占内存又消耗 CPU，这也是为什么很多人，看到 TIME_WAIT 很多，就蠢蠢欲动的想去干掉他们。其实，如果你再进一步去研究，1 万条 TIME_WAIT 的连接，也就多消耗1M左右的内存，对现代的很多服务器，已经不算什么了。至于 CPU，能减少它当然更好，但是不至于因为 1 万多个 hash item 就担忧。</p>
<p>各种操作系统实现也提供了绕过 TIME_WAIT 的方法，如果你去 google 解决方法，网上十有八九会让你设置 <strong>net.ipv4.tcp_tw_reuse</strong> 和 <strong>net.ipv4.tcp_tw_recycle</strong> 这两个参数。如果你不深入了解 TIME_WAIT 的机制以及这两个参数的内在原理而贸然使用，那么结果可能会更加糟糕。</p>
<h2 id="与-TIME-WAIT-有关的几个参数"><a href="#与-TIME-WAIT-有关的几个参数" class="headerlink" title="与 TIME_WAIT 有关的几个参数"></a>与 TIME_WAIT 有关的几个参数</h2><ul>
<li><strong>net.ipv4.tcp_timestamps</strong></li>
<li><strong>net.ipv4.tcp_tw_reuse</strong></li>
<li><strong>net.ipv4.tcp_tw_recycle</strong></li>
</ul>
<p>需要郑重说明的一点：<strong>net.ipv4.tcp_tw_reuse</strong> 和 <strong>net.ipv4.tcp_tw_recycle</strong> 这两个参数全部依赖于 <strong>net.ipv4.tcp_timestamps</strong>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEzMjMjcGFnZS0xMg==">RFC1323<i class="fa fa-external-link-alt"></i></span> 引入了 <code>timestamp</code> 时间戳选项，主要为了精确计算 <code>RTT（ROUND-TRIP TIME）</code> 。时间戳的另一个功用是为了防止序列号回绕，我们先来介绍这个功能。</p>
<h3 id="PAWS"><a href="#PAWS" class="headerlink" title="PAWS"></a>PAWS</h3><p><code>PAWS（PROTECT AGAINST WRAPPED SEQUENCE NUMBERS）</code>是防序列号回绕的意思。</p>
<p>经过前面的介绍，我们对序列号回绕（wrap around）已经有了清晰的认识。但之前我们都是在讨论新旧连接之间怎么防止延迟的报文段，随着网络性能的提升，同一个连接内也面临着延迟报文的问题。</p>
<p>我们知道序列号是一个 32 位的无符号整型，用它来编码，我们最多编码 4GB 的数据，超过 4GB 后就需要将序列号回绕进行重用。这在以前网速慢的年代不会造成什么问题，但在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。当 <code>wrap around time</code> 小于 MSL 的时候会发生什么呢？TCP 一切的设计都基于假设报文段最大的生存时间不会超过 MSL 的，如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文段抵达后序列号依然有效的问题。这就让 TCP 协议难以自圆其说，试看下面的示例：</p>
<p><img data-src="http://qiniu.liupzmin.com/seq-warp-around.png" alt="Figure 9. TCP 通过时间戳选项消除相同序列号报文段的二义性"></p>
<p>我们假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送者会针对每个发送窗口分配时间戳数值，我们假设每个窗口时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。</p>
<p>32 位的序列号字段在时刻 D 和 E 之间回绕。假设在时刻B有一个报文段丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。而且这段时间小于 MSL ，也就是说回绕时间很短，比 MSL 还要小，之前的报文段还没有在网络中消逝，并且还及时绕了回来。</p>
<p>如果 TCP 无法识别这个“乔装”的报文段，那么数据完整性就会遭到破坏。使用时间戳选项能够有效的防止上述问题。接收者可以将时间戳看作一个 32 位的扩展序列号。丢失的报文段会在时刻 F 重新出现，由于它的时间戳为 2，小于最近的有效时间戳（5 或 6），因此防回绕序列号算法会将其丢弃。</p>
<p>需要注意的是，防回绕序列号算法并不要求在发送者与接受者之间有任何形式的时钟同步，接受者所需要的是保证时间戳数值单调增长。</p>
<h3 id="net-ipv4-tcp-tw-reuse"><a href="#net-ipv4-tcp-tw-reuse" class="headerlink" title="net.ipv4.tcp_tw_reuse"></a>net.ipv4.tcp_tw_reuse</h3><p>我们先看看这个参数的定义：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tcp_tw_reuse - INTEGER</span><br><span class="line">	Enable reuse of TIME-WAIT sockets for new connections when it is</span><br><span class="line">	safe from protocol viewpoint.</span><br><span class="line">	0 - disable</span><br><span class="line">	1 - global enable</span><br><span class="line">	2 - enable for loopback traffic only</span><br><span class="line">	It should not be changed without advice/request of technical</span><br><span class="line">	experts.</span><br><span class="line">	Default: 2</span><br></pre></td></tr></table></figure>

<p>其含义是对处于 <code>TIME_WAIT</code> 的 sockets 启动重用功能，使得新建连接时可以重用 <code>TIME_WAIT</code> 状态的四元组。定义中声称这是协议安全的，默认只对回环网卡启用。</p>
<p>这里面有一句很鲜明的话：<strong>It should not be changed without advice&#x2F;request of technical</strong>。</p>
<p><strong>意思是如果没有专业指导就请不要修改它！</strong> 我们回顾一下 TCP 的四次挥手，只有主动断开连接的一方才会进入 <code>TIME_WAIT</code> 状态，并且只有重新发起连接的时候才会重用具有相同四元组的处于 <code>TIME_WAIT</code> 状态的 socket。这也就是说： <strong>tcp_tw_reuse 这个参数只对主动发起连接的客户端才奏效，只适用于 outbound 连接！</strong></p>
<p>那么使用 <code>tcp_tw_reuse</code> 跳过了 <code>TIME_WAIT</code> 阶段后，如何防止旧连接的延迟报文段呢？这就要依靠<code>timestamp</code> 时间戳选项提供的功能了。当新连接建立后，时间戳更新为最新的时间，当延迟的报文段到达后，其时间戳是小于当前连接的最近有效时间戳的。这个时候 TCP 就可以将这个报文段直接丢弃了。</p>
<p>再次强调，这个参数只适用于发起连接的一方，只影响出站连接，也就是作为客户端的情况。</p>
<h3 id="net-ipv4-tcp-tw-recycle"><a href="#net-ipv4-tcp-tw-recycle" class="headerlink" title="net.ipv4.tcp_tw_recycle"></a>net.ipv4.tcp_tw_recycle</h3><blockquote>
<p>这个参数在 Linux 内核 4.12 中已经被废弃，但这里还是值得拿出来说一说</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEzMjMjcGFnZS0yOQ==">RFC1323<i class="fa fa-external-link-alt"></i></span> 中有下面一段话：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">An additional mechanism could be added to the TCP, a per-host</span><br><span class="line">cache of the last timestamp received from any connection.</span><br><span class="line">This value could then be used in the PAWS mechanism to reject</span><br><span class="line">old duplicate segments from earlier incarnations of the</span><br><span class="line">connection, if the timestamp clock can be guaranteed to have</span><br><span class="line">ticked at least once since the old connection was open.  This</span><br><span class="line">would require that the TIME-WAIT delay plus the RTT together</span><br><span class="line">must be at least one tick of the sender&#x27;s timestamp clock.</span><br><span class="line">Such an extension is not part of the proposal of this RFC.</span><br></pre></td></tr></table></figure>

<p>意思是有了时间戳选项，我们可以在 TCP 中用 cache 针对每个 host 记录任何连接最后的接收时间戳。这个值可以像 PAWS 机制那样工作，以防止前一个连接的延迟报文段，也就是用来解决 <code>TIME_WAIT</code> 要解决的问题。我们可以看出来这就是 <code>Garlick, Rom, and Postel</code> 在 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExODUjcGFnZS0xOQ==">RFC1185<i class="fa fa-external-link-alt"></i></span> 中提出<strong>记录最终序列号</strong>方案的一种变体。Linux 将其实现了，这就是 <strong>net.ipv4.tcp_tw_recycle</strong> 参数（网上都这么说，但我没有查到官方的说法）。</p>
<p>官方定义是：<strong>Enable fast recycling TIME-WAIT sockets. Default value is 0. It should not be changed without advice&#x2F;request of technical experts.</strong></p>
<p>这个配置同样依赖于双方对 timestamps 的支持，当开启了这个配置后，内核会快速的回收处于 TIME_WAIT 状态的socket 连接。多快？不再是 <code>2*MSL</code>，而是一个<code>RTO（retransmission timeout，数据包重传的timeout时间）</code>的时间，这个时间根据 <code>RTT</code> 动态计算出来，但是远小于<code>2*MSL</code>。</p>
<p>它对出站连接和入站连接均有影响，但主要是影响入站连接的重用。所以，之前网上的文章大部分都是使用它来解决服务端 <code>TIME_WAIT</code> 的情况，也就是服务端主动断开了连接。</p>
<p><code>net.ipv4.tcp_tw_recycle</code> 这个选项特别激进。简单来说就是，Linux 会丢弃所有来自远端的 timestramp 时间戳小于上次记录的时间戳(由同一个远端发送的)的任何数据包。也就是说要使用该选项，则必须保证数据包的时间戳是单调递增的。</p>
<p>但是，如果对端是一个 NAT 网络的话（如：一个公司只用一个 IP 出公网）或是对端的 IP 被另一台重用了，这个事就复杂了。建连接的 SYN 可能就被直接丢掉了（你可能会看到 connection time out 的错误）。所以 NAT 就是 <code>net.ipv4.tcp_tw_recycle</code> 的死穴。</p>
<p><em><strong>其实我认为理论上在正常的 NAT 网络中也会出现此问题。假设 NAT 网络中一个客户端主动关闭了连接，在收到服务端的 FIN 报文后向对端发送了最后的 ACK，之后进入了 TIME_WAIT 状态。这个报文在 RTT&#x2F;2 时间到达了服务端，服务端进入了 CLOSED 状态，此时 NAT 网络中的另一个客户机发起了连接，注意原客户机此时仍在 TIME_WAIT 状态，那么服务端的四元组已经可以重用了，但是如果此时发起新连接的客户机携带的时间戳没有保证递增，那么还是会出现 SYN 被丢弃的情况。（之所以有此疑问，是因为我不清楚中间路由是否会记录连接信息，如果中间路由能阻止连接的发起那么就不会出现这种情况，希望懂的朋友给以指正。）</strong></em></p>
<p><em><strong>更新：<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzODIjcGFnZS0xMSUyMiUzRWh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzgyI3BhZ2UtMTE=">RFC5382<i class="fa fa-external-link-alt"></i></span> 中针对 <code>RST</code> 和 <code>TIME_WAIT</code> 情况下的 NAT 行为并未给予明确规定，仅仅阐述了一下利弊。所以由实现者自行处理：</strong></em></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAT behavior for handling RST packets, or connections in TIME_WAIT</span><br><span class="line">state is left unspecified.  A NAT MAY hold state for a connection in</span><br><span class="line">TIME_WAIT state to accommodate retransmissions of the last ACK.</span><br><span class="line">However, since the TIME_WAIT state is commonly encountered by</span><br><span class="line">internal endpoints properly closing the TCP connection, holding state</span><br><span class="line">for a closed connection may limit the throughput of connections</span><br><span class="line">through a NAT with limited resources.</span><br></pre></td></tr></table></figure>

<p><em><strong><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc4NTcjc2VjdGlvbi0yLjI=">RFC7857<i class="fa fa-external-link-alt"></i></span> 中又对 <code>RST</code> 的情况做了修正，建议在删除连接信息之前保存 <code>4</code> 分钟的时间：</strong></em></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Concretely, when the NAT receives a TCP RST matching</span><br><span class="line">an existing mapping, it MUST translate the packet according to the</span><br><span class="line">NAT mapping entry.  Moreover, the NAT SHOULD wait for 4 minutes</span><br><span class="line">before deleting the session and removing any state associated with</span><br><span class="line">it if no packets are received during that 4-minute timeout.</span><br></pre></td></tr></table></figure>

<p><em><strong>我并不清楚主流的路由器是如何处理这两种情况的，而且要研究其究竟超越了我目前的能力范围。因此，鉴于 RFC 中的相关描述，我暂时先从协议角度理解为上述担心的情况不会发生。</strong></em></p>
<p>但有一点我不是很明白，为什么 Linux 可以实现 tcp_tw_recycle，却不去实现<strong>记录前一个化身的最终使用序列号</strong>？这样完全可以避免 NAT 网络不同客户端时间戳无法保证单调递增的问题。不管这个连接是从 NAT 网络中哪台客户机发起的，始终为新连接选择一个大于前一个化身最终序列号的 ISN 就不会有任何问题。</p>
<h3 id="其它参数"><a href="#其它参数" class="headerlink" title="其它参数"></a>其它参数</h3><p>Linux 有个内核参数 <code>tcp_max_tw_buckets</code>控制并发的 TIME_WAIT 的数量，在我的 Linux 上的默认值是 <code>262144</code>，如果超限，那么，系统会把多的给 destory 掉，然后在日志里打一个警告（如：time wait bucket table overflow），这相当于跳过了 TIME_WAIT 直接将连接销毁。如果对端（被动关闭方）没有收到最后的 ACK，那么会重发 FIN 报文，因为主动端服务器已没有相关的连接信息，服务器收到 FIN 后会回一个 RST 报文将连接重置，到这里还没有什么大问题，只是 TCP 连接没有优雅的关闭而已。</p>
<p>问题在于这个连接跳过了 <code>TIME_WAIT</code> 阶段，如果一个相同四元组的连接随即被创建，而此时恰好前一个连接的迷途的报文又到达了，这会让当前的连接发生数据错乱。</p>
<p>这个值该设置为多少还是有待考量的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>围绕着 TIME_WAIT 的概念已经说的很多了，但其实仍然难以回答大家最关心的问题：<strong>如何去避免 TIME_WAIT ？</strong></p>
<p>其实我翻译的 <a href="http://liupzmin.com/2020/01/09/theory/time-wait-system-design/">TIME_WAIT及其对协议和可伸缩客户端服务器系统的设计实现</a> 这篇文章中已经给出了完美的答案，我再简单总结一下：</p>
<ol>
<li>永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT。</li>
<li>如果你非要在服务端断开连接，且你的服务不会有出站连接，那么服务器除了承受维护 TIME_WAIT 状态所带来的性能影响和资源占用之外，不需要对其有过多的担心。</li>
<li>如果你的服务端既要建立出站连接又要建立入站连接，黄金法则依然是：如果 TIME_WAIT 注定要发生，那么就让它发生在对端。如果对端超时了，直接使用 RST 终止连接。但你服务端也要避免发起频繁的短时连接，尽量使用长连接或者连接池。</li>
<li>如果你是客户端，尽量使用长连接和连接池，并发扬风格主动断开连接。</li>
<li>如果你非要写那种快速打开关闭，分分钟干出一堆 TIME_WAIT 的客户端，或许你可以设计一个应用层的关闭机制，你在客户端发送“我干完了”，服务端接收之后返回一个“再见”，之后客户端便可以发送 RST 终止连接。注意，这虽然解决了 TIME_WAIT 和数据完整性问题，但是延时报文仍然可能成为问题，而 timestamps 选项无法完全解决不同“化身”之间的报文延时，比如 NAT 网络。如果你使用这种方式与服务端断开连接，那么在你的 NAT 网络中恰好另一台机器使用相同的客户端程序连接同一个服务端的时候就有可能遭遇时间戳无法保证单调递增的情况。</li>
<li>作为客户端请合理的设置 <code>net.ipv4.ip_local_port_range</code>。</li>
</ol>
<p><em><strong>参考文章：</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5M2w=">RFC-0793<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExODU=">RFC-1185<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEzMjM=">RFC-1323<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzczMjM=">RFC-7323<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8xMDg4MDU0Lw==">TCP&#x2F;IP详解 卷1：协议<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8xNTAwMTQ5Lw==">UNIX网络编程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDI4MDAwMS8=">计算机网络自顶向下方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly92aW5jZW50LmJlcm5hdC5jaC9lbi9ibG9nLzIwMTQtdGNwLXRpbWUtd2FpdC1zdGF0ZS1saW51eA==">Coping with the TCP TIME-WAIT state on busy Linux servers<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5zZXJ2ZXJmcmFtZXdvcmsuY29tL2FzeW5jaHJvbm91c2V2ZW50cy8yMDExLzAxL3RpbWUtd2FpdC1hbmQtaXRzLWRlc2lnbi1pbXBsaWNhdGlvbnMtZm9yLXByb3RvY29scy1hbmQtc2NhbGFibGUtc2VydmVycy5odG1s">TIME_WAIT and its design implications for protocols and scalable client server systems<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGF2aWR2YXNzYWxsby5tZS8yMDEwLzA3LzEzL3RpbWVfd2FpdC1hbmQtcG9ydC1yZXVzZS8=">TIME_WAIT and “port reuse”<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTE1NjQuaHRtbA==">TCP 的那些事儿（上）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTE2MDkuaHRtbA==">TCP 的那些事儿（下）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm9sZGJveWVkdS5jb20vdGNwLXdhaXQv">你所不知道的TIME_WAIT和CLOSE_WAIT<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly94aWFvY2hhaS5naXRodWIuaW8vMjAxOS8wMy8xNi90Y3Atc3lzY3RsLW9wdHMv">那些与TIME_WAIT有关的参数<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cucWl1c3VvLmltL2Jsb2cvMjAxNC8wNi8xMS90Y3AtdGltZS13YWl0Lw==">深入理解TCP的TIME-WAIT<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3BlcnRoY2hhcmxlcy5naXRodWIuaW8vMjAxNS8wOC8yNy90aW1lc3RhbXAtaW50cm8v">TCP timestamp<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3BlcnRoY2hhcmxlcy5naXRodWIuaW8vMjAxNS8wOC8yNy90aW1lc3RhbXAtTkFULw==">一个NAT问题引起的思考<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzA2NDJlNjUxODgyNTFhODI2NjI5MTI=">被抛弃的tcp_recycle<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/01/09/theory/time-wait-system-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/09/theory/time-wait-system-design/" class="post-title-link" itemprop="url">译:TIME_WAIT及其对协议和可伸缩客户端服务器系统的设计实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-09 16:23:47" itemprop="dateCreated datePublished" datetime="2020-01-09T16:23:47+08:00">2020-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/computer-theory/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>看了左耳朵耗子推荐的这篇 <span class="exturl" data-url="aHR0cDovL3d3dy5zZXJ2ZXJmcmFtZXdvcmsuY29tL2FzeW5jaHJvbm91c2V2ZW50cy8yMDExLzAxL3RpbWUtd2FpdC1hbmQtaXRzLWRlc2lnbi1pbXBsaWNhdGlvbnMtZm9yLXByb3RvY29scy1hbmQtc2NhbGFibGUtc2VydmVycy5odG1s">TIME_WAIT and its design implications for protocols and scalable client server systems<i class="fa fa-external-link-alt"></i></span>　讲 TIME_WAIT 的文章，感觉比较清晰，就翻译出来，在这里记录了一下，其实其中内容在《TCP&#x2F;IP详解》和《UNIX网络编程》中有更详细的讲解。但是文章仍然值得一读，它从程序设计角度描述了应该如何避免 TIME_WAIT 的困扰，但对 TCP 本身着墨不是很多，比如要理解 TIME_WAIT 绕不开 ISN 和 MSL，以及在消除了 TIME_WAIT 之后如何解决延迟报文的问题也未予以详述，我会在我的下一篇文章中就 TIME_WAIT 问题再展开论述，增加自己对 TCP 掌握的熟练度，并结合 ISN、MSL、TIMESTAMP 等概念进行说明。</strong></p>
<p><em><strong>注：才疏学浅，翻译如有错漏之处，还望斧正。</strong></em></p>
<blockquote>
<p>When building TCP client server systems it&#39;s easy to make simple mistakes which can severely limit scalability. One of these mistakes is failing to take into account the TIME_WAIT state. In this blog post I&#39;ll explain why TIME_WAIT exists, the problems that it can cause, how you can work around it, and when you shouldn&#39;t.</p>
</blockquote>
<p>当构建基于 TCP 的 C&#x2F;S系统的时候，非常容易犯一些简单的错误，这些错误会严重限制系统的可伸缩性。其中之一就是对 TIME_WAIT 状态疏于考虑。在此博客文章中，我将说明 TIME_WAIT 存在的原因、它可能引起的问题、该如何解决它以及何时不应该考虑解决它。</p>
<blockquote>
<p>TIME_WAIT is an often misunderstood state in the TCP state transition diagram. It&#39;s a state that some sockets can enter and remain in for a relatively long length of time, if you have enough socket&#39;s in TIME_WAIT then your ability to create new socket connections may be affected and this can affect the scalability of your client server system. There is often some misunderstanding about how and why a socket ends up in TIME_WAIT in the first place, there shouldn&#39;t be, it&#39;s not magical. As can be seen from the TCP state transition diagram below, TIME_WAIT is the final state that TCP clients usually end up in.</p>
</blockquote>
<p>TIME_WAIT 是 TCP 协议状态转换图中一个经常被误解的状态。一些 socket 会进入这个状态并且保持这个状态相当长的一段时间，如果你有相当多的 socket 处于 TIME_WAIT 状态，那么你创建新连接的能力可能会受到影响，这进而会影响到你 C&#x2F;S 系统的伸缩性。通常，对于套接字如何以及为什么最终以 TIME_WAIT 结尾的情况经常会产生一些误解，不应该是这样，它不是魔术。如你将在下面的转换图中看到的那样，TIME_WAIT 通常是 TCP 客户端的最终状态（指通常情况下都是客户端主动断开连接）。</p>
<p><img data-src="http://qiniu.liupzmin.com/TCP-StateTransitionDiagram-NormalTransitions.png" alt="TCP StateTransitionDiagram NormalTransitions"></p>
<blockquote>
<p>Although the state transition diagram shows TIME_WAIT as the final state for clients it doesn&#39;t have to be the client that ends up in TIME_WAIT. In fact, it&#39;s the final state that the peer that initiates the &quot;active close&quot; ends up in and this can be either the client or the server. So, what does it mean to issue the &quot;active close&quot;?</p>
</blockquote>
<p>虽然状态转换图中展示的 TIME_WAIT 是客户端的最终状态，但是以 TIME_WAIT状态结束并不要求一定是客户端。事实上，TIME_WAIT 是发出 “主动关闭” 一端的最终状态，它既可以是客户端，也可以是服务端。那么问题来了，什么是“主动关闭”？</p>
<blockquote>
<p>A TCP peer initiates an &quot;active close&quot; if it is the first peer to call Close() on the connection. In many protocols and client&#x2F;server designs this is the client. In HTTP and FTP servers this is often the server. The actual sequence of events that leads to a peer ending up in TIME_WAIT is as follows.</p>
</blockquote>
<p>在 TCP 连接中，率先调用 close() 的一方就是 “主动关闭” 的发起方。在很多协议实现和C&#x2F;S系统中通常是 client 主动断开连接。HTTP（只在 HTTP 1.0 ） 和 FTP 里是 server 主动关闭。主动端走向 TIME_WAIT 的时序图如下：</p>
<p><img data-src="http://qiniu.liupzmin.com/TCP-StateTransitionDiagram-ClosureTransitions.png" alt="TCP StateTransitionDiagram Closure Transitions"></p>
<blockquote>
<p>Now that we know how a socket ends up in TIME_WAIT it&#39;s useful to understand why this state exists and why it can be a potential problem.</p>
</blockquote>
<p>现在我们知道了一个socket 是如何以 TIME_WAIT 状态结束的，这对我们理解 TIME_WAIT 状态存在的意义以及为何它可能成为潜在的问题非常有益。</p>
<blockquote>
<p>TIME_WAIT is often also known as the 2MSL wait state. This is because the socket that transitions to TIME_WAIT stays there for a period that is 2 x Maximum Segment Lifetime in duration. The MSL is the maximum amount of time that any segment, for all intents and purposes a datagram that forms part of the TCP protocol, can remain valid on the network before being discarded. This time limit is ultimately bounded by the TTL field in the IP datagram that is used to transmit the TCP segment. Different implementations select different values for MSL and common values are 30 seconds, 1 minute or 2 minutes. RFC 793 specifies MSL as 2 minutes and Windows systems default to this value but can be tuned using the TcpTimedWaitDelay registry setting.</p>
</blockquote>
<p>TIME_WAIT state 也称 2MSL wait state。这是因为转换为 TIME_WAIT 的套接字在此停留的时间为 2 个最大报文生存时间（MSL）。MSL 是 TCP 协议中任何报文在网络上最大的生存时间，任何超过这个时间的数据都将被丢弃。MSL 是由网络层的 IP 包中的 TTL来保证的（MSL 不与TTL 绝对相等，事实上 MSL 是 TCP 协议的假设基础）。不同的协议实现规定的 MSL 都不相同，通常为 30 seconds, 1 minute or 2 minutes。RFC 793 规定 MSL 为 2 minutes，Linux 默认为 30 seconds，windows 默认为 2 minutes，但是可以通过修改注册表 TcpTimedWaitDelay 的值来自定义。</p>
<blockquote>
<p>The reason that TIME_WAIT can affect system scalability is that one socket in a TCP connection that is shutdown cleanly will stay in the TIME_WAIT state for around 4 minutes. If many connections are being opened and closed quickly then socket&#39;s in TIME_WAIT may begin to accumulate on a system; you can view sockets in TIME_WAIT using netstat. There are a finite number of socket connections that can be established at one time and one of the things that limits this number is the number of available local ports. If too many sockets are in TIME_WAIT you will find it difficult to establish new outbound connections due to there being a lack of local ports that can be used for the new connections. But why does TIME_WAIT exist at all?</p>
</blockquote>
<p>TIME_WAIT 之所以会影响系统的伸缩性是因为连接正常关闭下进入这个状态的 socket 会持续 4 minutes 的时间（根据不同的实现，TIME_WAIT 时间在1 ~ 4 minutes之间）。如果有大量的连接被打开然后随即关闭的话，那么停留在 TIME_WAIT 状态的 socket 就会在操作系统上积累；你可以通过 netstat 来观察 TIME_WAIT 状态的 socket。一次只能建立有限数量的套接字连接，而限制此数量的因素之一是就可用的本地端口数。如果太多的 socket 处于 TIME_WAIT 状态，你会发现很难再建立新的出站连接，原因是缺少可用于新连接的本地端口。但是，为什么 TIME_WAIT 会存在呢？</p>
<blockquote>
<p>There are two reasons for the TIME_WAIT state. The first is to prevent delayed segments from one connection being misinterpreted as being part of a subsequent connection. Any segments that arrive whilst a connection is in the 2MSL wait state are discarded.</p>
</blockquote>
<p>TIME_WAIT 的存在主要有两个原因，第一个就是阻止前一个连接的延时报文被后续的连接错误接收（相同的五元组，不同的实例称为“化身”，这里指要阻止之前“化身”的报文被当前的连接错误接收）。一个连接处于 2 MSL 等待状态时，任何抵达的报文都将被丢弃（这里应该主要指数据报文，对于 FIN 报文还是要接收的，以便重新发送 ACK ，重新开始 2MSL 计时）。</p>
<p><img data-src="http://qiniu.liupzmin.com/TIME_WAIT-why.png" alt="TIME_WAIT why"></p>
<blockquote>
<p>In the diagram above we have two connections from end point 1 to end point 2. The address and port of each end point is the same in each connection. The first connection terminates with the active close initiated by end point 2. If end point 2 wasn&#39;t kept in TIME_WAIT for long enough to ensure that all segments from the previous connection had been invalidated then a delayed segment (with appropriate sequence numbers) could be mistaken for part of the second connection...</p>
</blockquote>
<p>上图有两个从 end point 1 到 end point 2 的连接，这两个连接的五元组相同（双方地址和端口相同）。第一个连接因 end point 2 主动关闭而终止，如果 end point 2 不在 TIME_WAIT 保持足够的时间以确保所有的报文在网络上失效的话，一个延迟的报文（拥有合适的 sequence number，意即对第二个连接来说是有效报文）会被第二个连接错误接收。</p>
<blockquote>
<p>Note that it is very unlikely that delayed segments will cause problems like this. Firstly the address and port of each end point needs to be the same; which is normally unlikely as the client&#39;s port is usually selected for you by the operating system from the ephemeral port range and thus changes between connections. Secondly, the sequence numbers for the delayed segments need to be valid in the new connection which is also unlikely. However, should both of these things occur then TIME_WAIT will prevent the new connection&#39;s data from being corrupted.</p>
</blockquote>
<p>需要注意的是，像这样延迟的报文造成问题的情况是非常不太可能的。首先，地址和端口号就不太可能相同，因为客户端的端口号是由操作系统临时分配的。其次，报文的 sequence 号必须是有效的，这个也不太可能发生（涉及到 ISN 的循环 和 sequence number 的 warp around）。然而，如果这两种情况都发生，则 TIME_WAIT 将防止新连接的数据被破坏。</p>
<blockquote>
<p>The second reason for the TIME_WAIT state is to implement TCP&#39;s full-duplex connection termination reliably. If the final ACK from end point 2 is dropped then the end point 1 will resend the final FIN. If the connection had transitioned to CLOSED on end point 2 then the only response possible would be to send an RST as the retransmitted FIN would be unexpected. This would cause end point 1 to receive an error even though all data was transmitted correctly.</p>
</blockquote>
<p>TIME_WAIT 存在的第二个原因就是：实现 TCP 的全双工连接可靠终止。如果 end point 2 最后发出的 ACK 丢失，依照 TCP 协议规则，end point 1 会重发 FIN。如果 end point 2 此时转为 CLOSED 状态，end point 2 的协议栈会响应一个 RST 报文，因为 这个重传的 FIN 并未被认可。 这将导致 end point 1 收获一个 error，即使所有的数据都已正确传输。</p>
<blockquote>
<p>Unfortunately the way some operating systems implement TIME_WAIT appears to be slightly naive. Only a connection which exactly matches the socket that&#39;s in TIME_WAIT need by blocked to give the protection that TIME_WAIT affords. This means a connection that is identified by client address, client port, server address and server port. However, some operating systems impose a more stringent restriction and prevent the local port number being reused whilst that port number is included in a connection that is in TIME_WAIT. If enough sockets end up in TIME_WAIT then new outbound connections cannot be established as there are no local ports left to allocate to the new connection.</p>
</blockquote>
<p>不幸的是，某些操作系统实现 TIME_WAIT 的方式似乎有些幼稚。只有阻塞在 TIME_WAIT 中的套接字连接，才需要给予 TIME_WAIT 提供的保护。这意味着由客户端地址，客户端端口，服务器地址和服务器端口标识的连接。但是，某些操作系统施加了更严格的限制，并阻止了本地端口号被重用，而该端口号包含在 TIME_WAIT 的连接中（这句不是很明白，感觉意思是处于 TIME_WAIT 的 socket 涉及到的所有端口号都不能重用）。如果以 TIME_WAIT 结束的套接字足够多，那么将无法建立新的出站连接，因为没有剩余的本地端口可分配给新连接。</p>
<blockquote>
<p>Windows does not do this and only prevents outbound connections from being established which exactly match the connections in TIME_WAIT.</p>
</blockquote>
<p>Windows 不会这样做，它仅阻止建立与 TIME_WAIT 中的连接完全匹配的出站连接。</p>
<blockquote>
<p>Inbound connections are less affected by TIME_WAIT. Whilst the a connection that is actively closed by a server goes into TIME_WAIT exactly as a client connection does the local port that the server is listening on is not prevented from being part of a new inbound connection. On Windows the well known port that the server is listening on can form part of subsequently accepted connections and if a new connection is established from a remote address and port that currently form part of a connection that is in TIME_WAIT for this local address and port then the connection is allowed as long as the new sequence number is larger than the final sequence number from the connection that is currently in TIME_WAIT. However, TIME_WAIT accumulation on a server may affect performance and resource usage as the connections that are in TIME_WAIT need to be timed out eventually, doing so requires some work and until the TIME_WAIT state ends the connection is still taking up (a small amount) of resources on the server.</p>
</blockquote>
<p>入站的连接很少会受到 TIME_WAIT 的影响。服务端主动关闭连接进入 TIME_WAIT 的过程与客户端类似，但是不会阻止服务器正在侦听的本地端口成为新的入站连接的一部分。在 Windows 操作系统上，那些服务端侦听的知名端口可以用于创建新的入站连接，只要新的连接的 ISN （初始序列号）大于处于 TIME_WAIT 的那个连接的最终序列号，那么即使远端地址和远端端口也是当前 TIME_WAIT 连接的一部分， 这个连接也会创建成功（<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExMjIjcGFnZS04Nw==">RFC 1122<i class="fa fa-external-link-alt"></i></span>中有相关描述，但是新“化身”的 ISN 号不敢保证一定会比老“化身”最后的序列号大，特别是中间在 NAT 网络的情况下）。但是，服务器上 TIME_WAIT 的累积可能会影响性能和资源使用，因为 TIME_WAIT 中的连接最终需要超时，这需要做一些工作，直到TIME_WAIT状态结束，连接仍会占用（少量）服务器上的资源。</p>
<blockquote>
<p>Given that TIME_WAIT affects outbound connection establishment due to the depletion of local port numbers and that these connections usually use local ports that are assigned automatically by the operating system from the ephemeral port range the first thing that you can do to improve the situation is make sure that you&#39;re using a decent sized ephemeral port range. On Windows you do this by adjusting the MaxUserPort registry setting; see here for details. Note that by default many Windows systems have an ephemeral port range of around 4000 which is likely too low for many client server systems.</p>
</blockquote>
<p>鉴于 TIME_WAIT 会因本地端口号的耗尽而影响到出站连接的建立，并且这些连接通常使用由操作系统从临时端口范围自动分配的本地端口，因此，你可以做的第一件事就是确保正在使用适当大小的临时端口范围。在 Windows 上你可以通过修改注册表选项 MaxUserPort 来自定义。请注意，默认情况下，许多 Windows 系统的临时端口范围约为 4000，这对于许多 C&#x2F;S 系统而言可能太低了。</p>
<blockquote>
<p>Whilst it&#39;s possible to reduce the length of time that socket&#39;s spend in TIME_WAIT this often doesn&#39;t actually help. Given that TIME_WAIT is only a problem when many connections are being established and actively closed, adjusting the 2MSL wait period often simply leads to a situation where more connections can be established and closed in a given time and so you have to continually adjust the 2MSL down until it&#39;s so low that you could begin to get problems due to delayed segments appearing to be part of later connections; this would only become likely if you were connecting to the same remote address and port and were using all of the local port range very quickly or if you connecting to the same remote address and port and were binding your local port to a fixed value.</p>
</blockquote>
<p>尽管可以减少 socket 在 TIME_WAIT 中花费的时间，但这实际上并没有帮助。鉴于 TIME_WAIT 成为问题仅仅出现在有大量连接主动关闭的情况下，因此调整 2MSL 时间值只会让更多的连接不断的被建立和关闭，从而你会陷入不断的调小 2MSL 的恶性循环中，直到这个值小到让你开始遭遇延迟报文干扰后续连接的情况。这经常出现在你作为客户端对同一个服务端发起大量短连接的情况下，本地端口被快速申请，却慢速的释放，或者是作为客户端你使用了本地固定端口。</p>
<blockquote>
<p>Changing the 2MSL delay is usually a machine wide configuration change. You can instead attempt to work around TIME_WAIT at the socket level with the SO_REUSEADDR socket option. This allows a socket to be created whilst an existing socket with the same address and port already exists. The new socket essentially hijacks the old socket. You can use SO_REUSEADDR to allow sockets to be created whilst a socket with the same port is already in TIME_WAIT but this can also cause problems such as denial of service attacks or data theft. On Windows platforms another socket option, SO_EXCLUSIVEADDRUSE can help prevent some of the downsides of SO_REUSEADDR, see here, but in my opinion it&#39;s better to avoid these attempts at working around TIME_WAIT and instead design your system so that TIME_WAIT isn&#39;t a problem.</p>
</blockquote>
<p>更改 2MSL 延时通常是操作系统级别的配置改动。你可以改为在 socket 层面使用 SO_REUSEADDR 选项针对 TIME_WAIT 问题做一些工作。这个选项允许你在相同的正在使用的地址和端口上创建 socket，新的 socket 本质上是劫持了老的socket。你可以使用此选项来创建新的 socket，即便它正处在 TIME_WAIT 状态，但是这样做有可能造成问题，例如拒绝服务攻击或者数据丢失。在 Windows 平台上，另一个 socket 选项 SO_EXCLUSIVEADDRUSE 可以帮助弥补 SO_REUSEADDR 的某些缺点。但我认为最好避免这些尝试来解决 TIME_WAIT 的问题，而应精心设计系统从而使 TIME_WAIT 不会成为问题。</p>
<blockquote>
<p>The TCP state transition diagrams above both show orderly connection termination. There&#39;s another way to terminate a TCP connection and that&#39;s by aborting the connection and sending an RST rather than a FIN. This is usually achieved by setting the SO_LINGER socket option to 0. This causes pending data to be discarded and the connection to be aborted with an RST rather than for the pending data to be transmitted and the connection closed cleanly with a FIN. It&#39;s important to realise that when a connection is aborted any data that might be in flow between the peers is discarded and the RST is delivered straight away; usually as an error which represents the fact that the &quot;connection has been reset by the peer&quot;. The remote peer knows that the connection was aborted and neither peer enters TIME_WAIT.</p>
</blockquote>
<p>上面的 TCP 转换图均展示的是有序连接终止。然而还有一种终止连接的方式，就是发送一个 RST 报文而不是 FIN 报文。一般是通过将 SO_LINGER 套接字选项设置为0来实现的。发送 RST 将导致待传输的数据（尚在发送缓冲区中）被丢弃，它不像发送 FIN 进行有序终止那样会等待数据被传送完成（一个 RST 报文会立即被送出，而 FIN 需要在缓冲区排队）。连接被终止时连接两端任何尚在流中的数据都将被丢弃，认识到这一点非常重要，因为 RST 报文会立即被传输；应用通常会收到“connection has been reset by the peer”的错误。这样远端就会意识到连接已经终止了，而且不会有任何一方进入 TIME_WAIT 状态。</p>
<blockquote>
<p>Of course a new incarnation of a connection that has been aborted using RST could become a victim of the delayed segment problem that TIME_WAIT prevents, but the conditions required for this to become a problem are highly unlikely anyway, see above for more details. To prevent a connection that has been aborted from causing the delayed segment problem both peers would have to transition to TIME_WAIT as the connection closure could potentially be caused by an intermediary, such as a router. However, this doesn&#39;t happen and both ends of the connection are simply closed.</p>
</blockquote>
<p>如此一来，没有了 TIME_WAIT 的保护，一个被 RST 终止的连接的新“化身”可能会成为延迟报文的受害者，但是无论如何，出现这种情况的可能性微乎其微，请参阅上文以了解更多详细信息。</p>
<blockquote>
<p>There are several things that you can do to avoid TIME_WAIT being a problem for you. Some of these assume that you have the ability to change the protocol that is spoken between your client and server but often, for custom server designs, you do.</p>
</blockquote>
<p>当然，要避免 TIME_WAIT 造成的困扰，我们尚有可为。前提是你可以控制客户端和服务端之间的设计实现，对于自定义的服务端来说，通常都需要这样做。</p>
<blockquote>
<p>For a server that never establishes outbound connections of its own, apart from the resources and performance implication of maintaining connections in TIME_WAIT, you need not worry unduly.</p>
</blockquote>
<p>对于一个不会建立出站连接的服务端来说，除了承受维护 TIME_WAIT 状态所带来的性能影响和资源占用之外，不需要对其有过多的担心。</p>
<blockquote>
<p>For a server that does establish outbound connections as well as accepting inbound connections then the golden rule is to always ensure that if a TIME_WAIT needs to occur that it ends up on the other peer and not the server. The best way to do this is to never initiate an active close from the server, no matter what the reason. If your peer times out, abort the connection with an RST rather than closing it. If your peer sends invalid data, abort the connection, etc. The idea being that if your server never initiates an active close it can never accumulate TIME_WAIT sockets and therefore will never suffer from the scalability problems that they cause. Although it&#39;s easy to see how you can abort connections when error situations occur what about normal connection termination? Ideally you should design into your protocol a way for the server to tell the client that it should disconnect, rather than simply having the server instigate an active close. So if the server needs to terminate a connection the server sends an application level &quot;we&#39;re done&quot; message which the client takes as a reason to close the connection. If the client fails to close the connection in a reasonable time then the server aborts the connection.</p>
</blockquote>
<p>如果你的服务端既要建立出站连接又要建立入站连接，那么设计的黄金法则就是：如果 TIME_WAIT 注定要发生，那么就让它发生在对端。简单来说就是不管什么原因，永远不要在服务端主动关闭连接。如果对端超时，请使用 RST 中止连接，而不要关闭它。如果对端发送了无效的数据，使用 RST 终止连接等等。其中诀窍就是如果服务端永远不主动关闭连接，那么服务器上就不会积累 TIME_WAIT 的 socket，因此便不会遭受可伸缩性问题。我们看到在发生异常的情况下如果发送 RST 终止连接，那么正常情况下的终止又该如何避免呢？理想情况下，你应该在应用层设计一种协议方式，让服务端告知客户端可以断开连接，而不是由服务端主动发起关闭。所以，服务端如果想断开连接了，那么发送一个应用层的消息“我们分手吧”，客户端收到后再主动发起连接关闭，如果客户端在预定时间内没有成功关闭，那么服务端可以主动终止连接。</p>
<blockquote>
<p>On the client things are slightly more complicated, after all, someone has to initiate an active close to terminate a TCP connection cleanly, and if it&#39;s the client then that&#39;s where the TIME_WAIT will end up. However, having the TIME_WAIT end up on the client has several advantages. Firstly if, for some reason, the client ends up with connectivity issues due to the accumulation of sockets in TIME_WAIT it&#39;s just one client. Other clients will not be affected. Secondly, it&#39;s inefficient to rapidly open and close TCP connections to the same server so it makes sense beyond the issue of TIME_WAIT to try and maintain connections for longer periods of time rather than shorter periods of time. Don&#39;t design a protocol whereby a client connects to the server every minute and does so by opening a new connection. Instead use a persistent connection design and only reconnect when the connection fails, if intermediary routers refuse to keep the connection open without data flow then you could either implement an application level ping, use TCP keep alive or just accept that the router is resetting your connection; the good thing being that you&#39;re not accumulating TIME_WAIT sockets. If the work that you do on a connection is naturally short lived then consider some form of &quot;connection pooling&quot; design whereby the connection is kept open and reused. Finally, if you absolutely must open and close connections rapidly from a client to the same server then perhaps you could design an application level shutdown sequence that you can use and then follow this with an abortive close. Your client could send an &quot;I&#39;m done&quot; message, your server could then send a &quot;goodbye&quot; message and the client could then abort the connection.</p>
</blockquote>
<p>客户端这头就略有复杂，正所谓“我不入地狱，谁入地狱”，毕竟总要有人主动发起关闭使 TCP 正常结束，也总要有人去承受 TIME_WAIT。然而，将 TIME_WAIT 终止在客户端还具有几个好处呢！首先，如果出于某种原因，客户端由于 TIME_WAIT 中 socket 的累积而导致连接问题话，只是它一个客户端的问题，其它的客户端不会受其影响。其次，快速打开和关闭与同一服务器的 TCP 连接的效率很低，因此 TIME_WAIT 的维持维持一个更长的等待时间反而有比较有意义。不要设计那种每分钟都要通过新建连接来连接到服务端的客户端。相反，使用长连接来替代，只有在连接失败的时候才去重连，如果中间路由不愿意维护长时间的空闲连接，可以在应用层添加心跳机制，或者打开 TCP 的 keep alive 保活机制，再或者就主动接受连接被重置。这样做的好处就是你不会积累 TIME_WAIT 了，如果你做的工作就是短期任务，那么考虑使用连接池吧。如果你非要写那种快速打开关闭，分分钟干出一堆 TIME_WAIT 的客户端，或许你可以设计一个应用层的关闭机制，你在客户端发送“我干完了”，服务端接收之后返回一个“再见”，之后客户端便可以发送 RST 终止连接了（注意，虽然解决了 TIME_WAIT 和数据完整性问题，但是延时报文仍然可能成为问题，而 per-host PAWS 无法完全解决不同“化身”之间的报文延时）。</p>
<blockquote>
<p>TIME_WAIT exists for a reason and working around it by shortening the 2MSL period or allowing address reuse using SO_REUSEADDR are not always a good idea. If you&#39;re able to design your protocol with TIME_WAIT avoidance in mind then you can often avoid the problem entirely.</p>
</blockquote>
<p>存在即合理，一味的通过 TCP 选项来重用地址或是盲目的减少 MSL 的值的做法都是不可取的。</p>
<p>念念不忘，必有回响，若你在设计协议时一直考虑 TIME_WAIT 的问题，那么你终将会完全避开。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/11/26/linux/how-do-we-run-programs-on-unix-systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/26/linux/how-do-we-run-programs-on-unix-systems/" class="post-title-link" itemprop="url">在 Linux 上有哪些运行程序的方式？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-26 10:47:48" itemprop="dateCreated datePublished" datetime="2019-11-26T10:47:48+08:00">2019-11-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Have-you-ever-thought"><a href="#Have-you-ever-thought" class="headerlink" title="Have you ever thought ?"></a>Have you ever thought ?</h2><p>有一次，我在编写一个 <code>Go</code> 程序，这个程序要做的一件事是在操作系统上执行一个命令（可执行文件或者可执行脚本），程序大概像下面这样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cmdSlice := strings.Fields(strings.TrimSpace(cmdString))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cmdSlice) == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;index out of range [0] with length 0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// search for an executable named file in the</span></span><br><span class="line"><span class="comment">// directories named by the PATH environment variable.</span></span><br><span class="line"><span class="comment">// If file contains a slash, it is tried directly and the PATH is not consulted.</span></span><br><span class="line"><span class="comment">// The result may be an absolute path or a path relative to the current directory.</span></span><br><span class="line">executableFile, err := exec.LookPath(cmdSlice[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.WithStack(NewPathError(cmdSlice[<span class="number">0</span>], err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(executableFile, cmdSlice[<span class="number">1</span>:]...)</span><br></pre></td></tr></table></figure>

<p>当我让程序去执行一个 shell 脚本的时候，收到了 <code>fork/exec: exec format error</code> 的错误，然而我在 shell 下执行这个脚本却是正常的，这让我很迷惑。</p>
<p>当我弄清楚原因是我没有在脚本里加 <code>Shebang</code>（<code>#!</code>） 的时候，疑惑愈深：<code>为什么操作系统会容忍我的过错呢？</code>对此，我会在稍后的章节中进行解释。当搞清楚问题的始末的之后，我突然对操作系统执行程序的方式产生了极大的兴趣，在好奇心的驱使下，我试图去搞清楚它，这也是我写这篇文章的初衷。</p>
<p>你是否想过，除了在 <code>shell</code> 下启动一个程序，是否还有其它的方式？ 我们是不是永远无法摆脱 <code>shell</code>？ 你是否曾经对 <code>shell</code> 下各种的执行方式感到困惑？比如，<code>“source xxx.sh”</code>、<code>“. xxx.sh”</code>、<code>“./xxx.sh”</code>、<code>“. ./xxx.sh”</code>、<code>“sh ./xxx.sh”</code>。 没关系，这篇文章会带你走出迷雾。</p>
<p>本文会涉及到一点 <code>Sysvinit</code> 和 <code>Systemd</code> 的内容， 但不会过多的去介绍他们，只是简单说明，这是一种能让你的程序运行起来的方式，我最后的重点会放在 <code>shell</code> 上面。</p>
<h2 id="让程序跑起来有多少种可能的方法？"><a href="#让程序跑起来有多少种可能的方法？" class="headerlink" title="让程序跑起来有多少种可能的方法？"></a>让程序跑起来有多少种可能的方法？</h2><p>当我产生这个疑问之后，我努力的思考，并去寻找答案，最后总结了如下几种：</p>
<ol>
<li>传统的 Sysvinit 方式</li>
<li>Systemd</li>
<li><code>crontab</code> 或者 <code>Systemd Timer</code></li>
<li>shell（无论是终端还是 sshd ）</li>
<li>GUI</li>
</ol>
<p>其中 1, 2 两种方式可以算作同一类，虽然他们的工作方式有所不同，但都属于系统管理层面。如果你的程序是一个随系统启动，并托付给系统管理的 <code>Daemon</code> ，那么最好的方式就是通过 <code>Sysvinit</code> 或者 <code>Systemd</code> 来管理，他们都是 Linux 的 init 系统。相似的 init 系统还有 <code>Upstart</code> ，但我并不熟悉它，所以不准备做介绍，当然这并不影响，因为他们属于一类系统。</p>
<p><code>定时任务</code>是另一个可能会拉起一个程序的方式，相信很多朋友都有在 Linux 上使用 <code>crontab</code> 的经历，而它的继任者 <code>Systemd Timer</code> 可能就没那么多人熟悉了。</p>
<p><code>shell</code> 是最常见的启动程序的方式。事实上 <code>shell</code> 的主要作用就是去运行其它的程序，即便是前面 3 种方式，很多时候也是使用 shell 来启动程序的，只不过不是我们手动在 shell 里执行而已。</p>
<p>还有一种方式就是在桌面环境下，使用 GUI 来启动一个前台程序，你可能通过点击一个 <code>.desktop</code> 的快捷方式来启动一个桌面应用，在我的 <code>Manjaro</code> 下桌面应用全部是由 <code>plasmashell</code> 这个进程 <code>fork</code> 出来的子进程。</p>
<h2 id="承前启后的-SysV-init"><a href="#承前启后的-SysV-init" class="headerlink" title="承前启后的 SysV init"></a>承前启后的 SysV init</h2><p>Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。</p>
<p>因为大多数 Linux 发行版的 init 系统是和 Unix System V 是相互兼容的，因此 Linux 上的 init 系统也被成为 <code>Sysvinit</code> 。在 <code>Systemd</code> 出现之前，大多数常见的 Linux 发行版都使用<code>Sysvinit</code>。</p>
<p>在 sysvinit 下有几个 <code>runlevel</code> ，并且有 0~6 七个运行级别，比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启动到图形界面，0 表示关机，6 表示重启。其配置在 &#x2F;etc&#x2F;inittab 文件中。</p>
<p>与此配套的还有 &#x2F;etc&#x2F;init.d&#x2F; 和 &#x2F;etc&#x2F;rc[X].d，前者存放各种进程的启停脚本（需要按照规范支持 start，stop子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：&#x2F;etc&#x2F;rc3.d 是 runlevel&#x3D;3 的。 里面的文件主要是 link 到  &#x2F;etc&#x2F;init.d&#x2F; 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：S01rsyslog，S02ssh。S 表示启动，K表示停止，数字表示执行的顺序。</p>
<p>为了将操作系统带入可操作状态，init 系统通过读取 <code>/etc/inittab</code> 获得 runlevel，然后依次顺序执行对应 level 下的脚本。rc[X].d 下都是些 link， 链接到 rc.d 中的 shell 脚本， 可见系统初始化过程中依然是使用的 <code>shell</code> 来启动相应程序的。</p>
<p>然而这些脚本中需要使用 awk, sed, grep, find, xargs 等等这些操作系统的命令，这些命令需要生成进程（这涉及到 shell 的工作方式，我稍后在 shell 小节详细介绍），生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。这完全是大材小用，操作系统废了九牛二虎之力拉起来一个进程，结果这个进程就干了个把字符串转为小写的活儿，然后丢下一脸懵逼的操作系统就潇洒的退出了。</p>
<p>可以想见，当 rc.d 中有大量的脚本，且脚本中又有成百上千个类似于 awk、sed、grep 这样的命令时，系统的启动过程就会变得漫长。当然对于启停不那么频繁的服务器来说，这依然可以接受，而且这样的系统设计也很符合 Unix 设计哲学：<code>Do one thing and Do it well</code>，所以 sysvinit 可以一统江湖几十年。直到 2006年 Linux 内核进入 2.6 时代，Linux 开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，在这些新的使用场景下，sysvint 开始变得不合时宜了。</p>
<blockquote>
<p>更详细的 sysvint 介绍可以参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC8xNDA3X2xpdW1pbmdfaW5pdDEvaW5kZXguaHRtbA==">浅析 Linux 初始化 init 系统-sysvinit<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="步行夺猛马的-Systemd"><a href="#步行夺猛马的-Systemd" class="headerlink" title="步行夺猛马的 Systemd"></a>步行夺猛马的 Systemd</h2><p><strong>历史上总是会有人站出来对现状说不</strong>，2010 年 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGVubmFydF9Qb2V0dGVyaW5n">Lennart Poettering<i class="fa fa-external-link-alt"></i></span> 和他的小伙伴们开源并发布了一个新的 init 系统——<code>Systemd</code>。</p>
<p><code>Systemd</code> 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度。systemd 和 ubuntu 的 upstart 是竞争对手，而 ubuntu 在 15.04 及后续版本中已将 systemd 设置为默认 init 程序，redhat 和 centos 也从 7.0 之后开始使用 systemd，截止目前 systemd 已经运行在大部分的 Linux发行版中。</p>
<p>在系统启动上 systemd 拥有绝对的优势，有张三方对比图可见分晓：</p>
<p><img data-src="https://qiniu.liupzmin.com/boot.png"></p>
<p>如今 systemd 成为 1 号进程，后续所有的进程都是由它 fork 出来的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">systemd(1)─┬─ModemManager(494)─┬─&#123;ModemManager&#125;(495)</span><br><span class="line">           │                   └─&#123;ModemManager&#125;(498)</span><br><span class="line">           ├─NetworkManager(463)─┬─&#123;NetworkManager&#125;(467)</span><br><span class="line">           │                     └─&#123;NetworkManager&#125;(470)</span><br><span class="line">           ├─agent(1229)─┬─&#123;agent&#125;(1232)</span><br><span class="line">           │             └─&#123;agent&#125;(1236)</span><br><span class="line">           ├─avahi-daemon(465)───avahi-daemon(468)</span><br><span class="line">           ├─baloo_file(655)───&#123;baloo_file&#125;(671)</span><br><span class="line">           ├─bluetoothd(464)</span><br><span class="line">           ├─crond(460)</span><br><span class="line">           ├─cupsd(476)</span><br><span class="line">           ├─dbus-daemon(462)</span><br><span class="line">           ├─dbus-daemon(1458)</span><br><span class="line">           ├─dockerd(557)─┬─containerd(583)─┬─&#123;containerd&#125;(589)</span><br><span class="line">           │              │                 ├─&#123;containerd&#125;(590)</span><br><span class="line">           │              │                 └─&#123;containerd&#125;(13694)</span><br><span class="line">           │              ├─&#123;dockerd&#125;(561)</span><br><span class="line">           │              └─&#123;dockerd&#125;(861)</span><br><span class="line">           └──fcitx(1431)─┬─sh(1576)</span><br><span class="line">                          └─&#123;fcitx&#125;(1478)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>深入了解请参考：<span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTc5OTguaHRtbA==">LINUX PID 1 和 SYSTEMD<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>简单说一下定时任务，当我们使用 crontab 配置了一个定时执行任务之后，Cron 每分钟做一次检查，看看哪个命令可执行，当 Cron 检查到有命令需要执行时则 fork 子进程，再由此子进程 fork-execve 执行真正的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init(1)-+-NetworkManager(1747)</span><br><span class="line">        └-crond(2107)-+-crond(355)---sh(356)---sleep(14329)</span><br><span class="line">                      |-crond(10967)---sh(10968)---sleep(14326)</span><br><span class="line">                      |-crond(12098)---sh(12099)---sleep(14327)</span><br><span class="line">                      `-crond(15114)---sh(15115)---sleep(14328)</span><br></pre></td></tr></table></figure>

<p>这篇 <span class="exturl" data-url="aHR0cDovL3d3dy55dW53ZWlwYWkuY29tL2FyY2hpdmVzLzQ0NzkuaHRtbA==">Linux cron运行原理<i class="fa fa-external-link-alt"></i></span> 有更详细的介绍。</p>
<p>对于 systemd 我测试一个 timer，其进程是挂在 systemd 进程之下的，我猜测也是 systemd 进程去 fork 执行 timer 中的任务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;17:22&#125;~/PycharmProjects ➭ ps -ef|grep udp</span><br><span class="line">root     17002     1  0 17:19 ?        00:00:00 /usr/bin/python3 /home/liupeng/udpClient.py</span><br></pre></td></tr></table></figure>

<h2 id="伟大的造物主——shell"><a href="#伟大的造物主——shell" class="headerlink" title="伟大的造物主——shell"></a>伟大的造物主——shell</h2><p>通过前面的分析，会发现 Linux 上的程序绝大多数情况下是通过 shell 来执行的，所以我们接下来将重点放在 shell 上。</p>
<p>你可能会问： shell 有什么好讲的，它不就是个与内核交互的<code>外壳</code>程序么？</p>
<p>没错，它的功能就是如此纯粹——<code>a shell is a user interface for access to an operating system&#39;s services</code>，但它却无处不在。</p>
<p>传统的 Sysvinit 系统下绝大部分的系统服务都是通过 shell 拉起来的，虽然到了 Systemd 时代，很多工作由 C 语言重新实现了（具体见<span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTc5OTguaHRtbA==">LINUX PID 1 和 SYSTEMD<i class="fa fa-external-link-alt"></i></span>）,但是你依然可以使用 systemd 来管理你的启停脚本，这些脚本用来启停你的程序。而对于非 Daemon 方式的程序。你仍然需要用 shell 来启动它们到前台，或者使用 nohup、setsid 等方式启动到后台。</p>
<p>可见，我们无法逃离 <code>shell</code>，它就像是一个造物主，系统中几乎所有的进程都是或曾是它的子民。</p>
<p>要讲清楚shell是一个十分艰巨的任务，对于只查过几天资料的我来说自然无法胜任，但是择其一两点来讲，以<strong>多少理清一些 Linux 下程序启动与运行的原理</strong>为目的，或可一试。</p>
<blockquote>
<p>文中涉及到关于 shell 的实验或者结论皆以 Bash 作为参考依据。</p>
</blockquote>
<h3 id="What-is-a-shell"><a href="#What-is-a-shell" class="headerlink" title="What is a shell?"></a>What is a shell?</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9iYXNoLmh0bWwjV2hhdC1pcy1hLXNoZWxsXzAwM2Y=">Bash<i class="fa fa-external-link-alt"></i></span> 主页上有关于 shell 的定义：</p>
<blockquote>
<p>At its base, a shell is simply a macro processor that executes commands. The term macro processor means functionality where text and symbols are expanded to create larger expressions.</p>
</blockquote>
<p>这段话真不太好翻译，勉强翻译一下为：<code>从根本上说，shell 只是执行命令的宏处理器。术语宏处理器是指将文本和符号扩展以创建更大的表达式的功能。</code></p>
<p>对于 Unix shell 来说，它既是一个命令行解释器也是一个编程语言。shell 作为命令行解释器为丰富的 GNU 工具集提供了用户接口，而作为编程语言它成功的将这些工具集结合在一起，之后就可以将命令编写进文件，去完成各种各样的任务。</p>
<p>很多人可能傻傻分不清 <code>terminal</code>、<code>tty</code>、<code>console</code> 和 <code>shell</code>，这里第一个高票回答对这些概念做了详细的解释：<span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL2EvNDEzMg==">What is the exact difference between a &#39;terminal&#39;, a &#39;shell&#39;, a &#39;tty&#39; and a &#39;console&#39;?<i class="fa fa-external-link-alt"></i></span>。如果英文阅读不畅，知乎上有人将其翻译了一下：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxNzExMzA3L2Fuc3dlci81NjA1Njk3Mg==">终端、Shell、tty 和控制台（console）有什么区别？<i class="fa fa-external-link-alt"></i></span>，我不再做额外的阐述了，接下来只需要记住 shell 是一个命令行解释器就好，它可以运行在交互模式和非交互模式。</p>
<h3 id="shell-是如何查找命令的"><a href="#shell-是如何查找命令的" class="headerlink" title="shell 是如何查找命令的"></a>shell 是如何查找命令的</h3><p>当我们在交互式 shell 下敲下一个命令时，shell 查找命令文件的规则大概如下：</p>
<ol>
<li><p>执行命令前 shell 会先检查是否有 alias，如果有就会使用 alias 中的内容。</p>
</li>
<li><p>如果 command 名字不包含 <code>&quot;/&quot;</code> ，shell 将尝试寻找它。如果存在同名的函数，则会调用函数。</p>
</li>
<li><p>如果没有匹配到函数，则从 shell 内置命令（<code>builtins</code>）中寻找，如果找到则调用该命令。</p>
</li>
<li><p>如果都没有找到则从 <code>$PATH</code> 中寻找，为了避免每次遍历 <code>$PATH</code> ,shell 维护了一张 <code>HASH</code> 表，记录了每个命令对应的绝对路径（我的 manjaro 在每次安装新软件之后，需要执行一下<code>rehash</code>命令。如此，可执行文件才能在当前 shell 下被找到），如果 HASH 表中没有再去 <code>$PATH</code> 中的目录遍历，如果 PATH 中未找到就执行一个预定义的函数 <code>command_not_found_handle</code> 。如果函数存在，则在<code>子 shell</code> 中调用，如果不存在则打印错误信息并返回 127 状态码。</p>
</li>
<li><p>如果寻找成功或者 command 中含有 <code>“/”</code>， shell 将在新环境中执行它（ fork 一个新进程 ）。</p>
</li>
<li><p>如果 command 不是异步启动的，shell 将等待其完成并收集退出状态码。</p>
</li>
</ol>
<p>如上所述就是 shell 在执行命令式的查找规则。也是时候破解一下我们在文章开头留下的谜题了，先从 <code>./</code> 开始吧。</p>
<p><code>./</code> 在类 Unix 系统中表示相对路径指向某个文件或者目录，因为在 Unix 系统中 PATH 不包含当前路径，也无法包含当前路径。如 <code>./test</code>、<code>touch ./a</code></p>
<p><code>.</code> 是 BASH 的一个内建命令，它继承自 <code>Bourne shell (sh)</code>，并且是 <code>source</code> 同义词，跟 <code>source</code> 功能相同。</p>
<p><code>. filename [arguments]</code> 的功能是在当前 shell 上下文中（ 不会 fork ）读取并执行 <code>filename</code> 中的命令，如果 <code>filename</code> 不包含 <code>“/”</code> ， shell 将从 <code>$PATH</code> 中寻找该文件，如果当前 shell 不是 <code>POSIX</code> 模式，则在 <code>PATH</code> 中寻找失败后，继续从当前目录中寻找。</p>
<p>对于 <code>sh ./test.sh</code> 这种模式，在 bash 的文档中可以找到对应的描述 <code>Invoked with name sh</code>（大多数 Linux 发行版会把 sh 设置成 bash 的软连接，所以这里只针对此种情况）：</p>
<blockquote>
<p>When invoked as sh, Bash enters POSIX mode after the startup files are read.</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9iYXNoLmh0bWwjQmFzaC1QT1NJWC1Nb2Rl">POSIX mode<i class="fa fa-external-link-alt"></i></span> 我会在后面展开介绍，这里暂且略去，开始进入 shell 如何执行一个 command 吧。</p>
<h3 id="shell-是如何执行命令的"><a href="#shell-是如何执行命令的" class="headerlink" title="shell 是如何执行命令的"></a>shell 是如何执行命令的</h3><p>我在介绍 Systemd 和 cron 的时候用了 <code>fork</code> 这个词，而在描述 shell 的时候仅仅说<code>“shell 启动相应程序”</code>。其实，shell 执行一个程序的方式也一样使用了 <code>fork</code>，我只是为了能在本章节重点作介绍才故意没有使用 <code>fork</code> 这个词。</p>
<p>我们知道， Linux 下的可执行文件可以分为 <code>ELF 文件</code>和<code>脚本文件</code>，当我们在 bash 下输入一个命令执行某个 ELF 程序时，Linux 系统是如何装载并执行它的呢？</p>
<p>首先，在用户层面，bash 进程会调用 <code>fork()</code> 系统调用创建一个新的进程。新进程通过调用 <code>execve()</code> 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。</p>
<p>当进入 <code>execve()</code> 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中，<code>execve()</code> 系统调用相应的入口是 <code>sys_execve()</code>。<code>sys_execve()</code> 进行一些参数的检查复制之后，调用 <code>do_execve()</code>，<code>do_execve()</code> 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。</p>
<p>为什么要先读取文件的前 128 个字节？这是因为 Linux 支持的可执行文件不止 ELF 一种，还包括 <code>a.out</code>、<code>Java 程序</code>、以 <code>#!</code> 开头的脚本程序。<code>do_execve()</code> 通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前4个字节，被称为 <code>魔数</code>（Magic Number）。</p>
<p>我们用一段 C 程序来读取一下各种文件的前 4 个字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">		FILE *fp;</span><br><span class="line">		<span class="type">int</span> r;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">		fread(&amp;r, <span class="number">4</span>, <span class="number">1</span>, fp);</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%X \n&quot;</span>, r);</span><br><span class="line">	</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>ELF</p>
<p> 我们编译这段程序，并读取程序自身</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;15:32&#125;~/Learing/c/src:master ✗ ➭ gcc -o read4bytes read4bytes.c </span><br><span class="line">&#123;15:33&#125;~/Learing/c/src:master ✗ ➭ ./read4bytes read4bytes</span><br><span class="line">464C457F</span><br></pre></td></tr></table></figure>

<p> 可以看到输出为 <code>464C457F</code>，我们查看ASCII 表，得出如下的对应关系：<br> <img data-src="https://qiniu.liupzmin.com/elf-header-small.png" alt="ELF Header"></p>
<p> 我的操作系统字节序是小端法排序，因此，<code>ELF的可执行文件格式的头 4 个字节为 0x7F、E、L、F</code>。</p>
</li>
<li><p>shell 脚本</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;15:33&#125;~/Learing/c/src:master ✗ ➭ ./read4bytes ~/meta    </span><br><span class="line">622F2123 </span><br></pre></td></tr></table></figure>

<p> 前 4 个字节为 <code>622F2123</code>，我们再查一下 ASCII 表的对应关系：<br> <img data-src="https://qiniu.liupzmin.com/bash-header-small.png" alt="shell script header"></p>
<p> 翻转一下就是 <code>#!/b</code>,可以猜测如果我们多读 7 个字节，结果肯定是<code>#!/bin/bash</code>.</p>
<p> 对于 <code>python</code>、<code>perl</code>、<code>php</code>脚本处理方式相同。</p>
</li>
<li><p>java class</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;15:51&#125;~/Learing/c/src:master ✗ ➭ ./read4bytes ~/java/HelloWorld.class </span><br><span class="line">BEBAFECA</span><br></pre></td></tr></table></figure>
<p> <code>《程序员的自我修养》</code>一书 6.5 章节介绍 Linux 装载可执行文件时，依次介绍了 <code>ELF</code>、<code>java 可执行文件</code>和 <code>#！</code>三种情况。ELF 的前 4 个字节将 16 进制转换为 ASCII 字符是 <code>E</code>、<code>L</code>、<code>F</code>；但是 java 的 class 文件则不同，由上可知读出的前4个字节的 16 进制表示为 <code>BEBAFECA</code>。因为是小端，所以 16 进制的表示法刚好是 <code>CAFEBABE</code>，并不需要转化成具体的字符，而书中介绍说 <code>“Java的可执行文件格式的头 4 个字节为 c、a、f、e”</code>，我猜可能书中存在前后逻辑不一致的问题，除非真的存在所谓的 <code>java 可执行文件</code>，如果有朋友了解，欢迎联系我，给我批评指正。</p>
<p> 关于 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmF2YV9jbGFzc19maWxl">CAFEBABE<i class="fa fa-external-link-alt"></i></span>的来源可以参见 wiki 上 James Gosling 的自白。</p>
</li>
</ol>
<p>当 <code>do_execve()</code> 读取了 128 个字节的文件头部之后，调用 <code>search_binary_handle()</code> 去搜索和匹配合适的可执行文件装载处理过程。Linux 中所有被支持的可执行文件格式都有相应的装载处理过程，<code>search_binary_handler()</code> 会通过判断头部的魔数确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示.</p>
<ul>
<li>ELF 可执行文件：load_elf_binary()</li>
<li>a.out 可执行文件：load_aout_binary()</li>
<li>可执行脚本程序：load_script()</li>
</ul>
<p>有必要提一下 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQS5vdXQ=">a.out<i class="fa fa-external-link-alt"></i></span>， a.out 本身要追溯到更早的 Unix 时代，并且伴随 Linux 的诞生至今在 Linux 中有将近 ~28 年的历史。从 内核 5.1 开始， Linux 移除 a.out 格式的消息，因为 ELF 自 1994 年进入 Linux 1.0 以来，已经 ~25 年了，a.out 早已年久失修，而且现在基本上找不到能产生 a.out 格式的编译器了。</p>
<p>你可能会说，gcc 默认编译生成的不就是 a.out 么？非也，此 a.out 非彼 a.out。gcc 默认生成的 a.out 的实际格式也是 ELF，如果你按照刚才的方式读取 a.out 的前四个字节，你会发现同样是 <code>464C457F</code>，a.out 这个名字很大意义上属于计算机历史文化的沿袭，想了解更多可以参考<span class="exturl" data-url="aHR0cHM6Ly90aW55bGFiLm9yZy9nb29kYnllLWEub3V0Lw==">为 a.out 举行一个特殊的告别仪式<i class="fa fa-external-link-alt"></i></span>。</p>
<p>我在这里省去 <code>load_elf_binary()</code> 的过程，只需提一下其中一步会修改系统调用的返回地址为 ELF 文件的入口地址，细节可以去参考<code>《程序员的自我修养》</code> 6.5 节。当 <code>load_elf_binary()</code> 执行完毕之后，返回至 <code>do_execve()</code> 再返回至 <code>sys_execve()</code> 时，因为 <code>load_elf_binary()</code> 已经修改了返回地址，所以当 <code>sys_execve()</code> 系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了 ELF 程序的入口地址，于是开始执行新程序的代码指令， ELF 可执行文件装载完成。</p>
<p>是时候去破解我在文章开头留下的问题了，我用 Go 程序通过 <code>fork</code> 和 <code>exec</code> 去执行脚本的时候收获到 <code>fork/exec: exec format error</code> 的错误。现在来看是 <code>search_binary_handle()</code> 的过程出了问题，内核并没有识别到脚本文件格式，经查确认是我脚本中没有加入 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU2hlYmFuZw==">Shebang<i class="fa fa-external-link-alt"></i></span>，当我在首行增加了 <code>#!/bin/bash</code> 之后，程序便可以正确运行了。</p>
<p>我还没有解释为什么在交互式的 shell 下执行不带 <code>Shebang</code> 的脚本不会触发错误，因为说起我寻找答案的过程总让我喟叹不已，我是从一篇几近 30 年前的文章中找到答案的。这让我想到了多年前我学习 Oracle 调优时从一本 10 多年前出版的书中获益的经历。我难以想象，我今天写就的一篇博文，有可能会在 30 年后帮助到另一个人，这会让我永葆写作的热情......</p>
<p>就是这篇 （<span class="exturl" data-url="aHR0cDovL3d3dy5mYXFzLm9yZy9mYXFzL3VuaXgtZmFxL2ZhcS9wYXJ0My9zZWN0aW9uLTE2Lmh0bWw=">Why do some scripts start with #! ... ?<i class="fa fa-external-link-alt"></i></span>）写于 1992 年的文章帮助我找到事实的真相。</p>
<p>简单概括一下就是早在 Unix 时代，为了不让内核什么东西都拿来执行，程序员们发明了 <code>“magic number”</code>，通过 magic number 内核可以辨别出哪些是可执行程序，在文件不可执行时抛出 <code>ENOEXEC</code> 错误，但是 shell 代码扩充了这项功能，在收到 <code>ENOEXEC</code> 失败后会去使用 <code>“/bin/sh”</code> 尝试将其作为 shell 脚本去执行，所以脚本执行是由 shell 来完成的，而不是内核，代码逻辑大概像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* try to run the program */</span></span><br><span class="line">execl(program, basename(program), (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the exec failed -- maybe it is a shell script? */</span></span><br><span class="line"><span class="keyword">if</span> (errno == ENOEXEC)</span><br><span class="line">    execl (<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, program, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* oh no mr bill!! */</span></span><br><span class="line">perror(program);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>后来，伯克利的一些 guys 扩充了内核的功能，使其可以识别魔数 <code>“#！”</code>，如果内核读到 <code>#！</code> 则将继续读取该行的剩余部分，并将其作为命令去解释运行文件中的内容。</p>
<p>试想，当你执行一个没有正确填写 <code>Shebang</code> 的脚本文件的时候，shell 很可能会给你报一个没有执行权限的错误，当你依照错误提示给予 <code>+x</code> 权限的时候，你很可能收到更多的错误，原因很可能是你正在编写一个 python 脚本。</p>
<p>乖乖的写 <code>Shebang</code> 吧 ！ </p>
<p>事实上，后来我在 Bash 的文档中也找到了相关描述：</p>
<blockquote>
<p>this execution fails because the file is not in executable format, and the file is not a directory, it is assumed to be a shell script and the shell executes it as described in Shell Scripts.</p>
</blockquote>
<p>也许这一节描述没有燃起你的兴奋点，因为我假设你对 <code>fork</code> 和 <code>exec</code> 函数族以及<code>虚拟内存</code>有所了解，如果你不了解的话可以参考下面我给出的链接：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBd01EVXdORGd4T0E9PSZtaWQ9MjY1MjY2NjIyMSZpZHg9MSZzbj1lYmRiNDU1MzVlYWRkZTk0N2E0ZjEyMDZjMTk1NDQ3ZiZzY2VuZT0yMSN3ZWNoYXRfcmVkaXJlY3Q=">Unix&#x2F;Linux fork前传<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBd01EVXdORGd4T0E9PSZtaWQ9MjY1MjY2NjIwMCZpZHg9MSZzbj1jY2U3YWI4NmY3YTU3ZGQ0Y2I5ZTM3MmE0OWJmZGNmYSZzY2VuZT0yMSN3ZWNoYXRfcmVkaXJlY3Q=">Linux fork那些隐藏的开销<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3Mva2ViZnJTeWV5dk1WLS1YcXpCTlJTQQ==">Fork三部曲之clone的诞生<i class="fa fa-external-link-alt"></i></span></li>
<li>深入理解计算机系统 第9章 Virtual Memory</li>
</ul>
<h3 id="login、non-login、interactive-、non-interactive-与-Startup-Files"><a href="#login、non-login、interactive-、non-interactive-与-Startup-Files" class="headerlink" title="login、non-login、interactive 、non-interactive 与 Startup Files"></a>login、non-login、interactive 、non-interactive 与 Startup Files</h3><p>因为 shell 可以运行在交互模式和非交互模式下，并且有 login 和 non-login 的情况，所以每一种组合他们读取并执行的 Startup Files 都有所不同，下面我给出一幅图来展示各种不同的情况：</p>
<p><img data-src="https://qiniu.liupzmin.com/bash.png" alt="bash and startup files"></p>
<p>所谓的 <code>login &amp; interactive</code> 模式我举两个例子，一个是我们登录 Linux 字符界面的时候，输入用户名密码进入的那个 shell 就是登录交互式的，另一个就是我们使用 <code>sshd</code> 服务远程登录，在输入用户名密码后获得的 shell 也是登录交互式的。</p>
<p>对于非交互式的 shell 典型的情况就是执行脚本啦，而在执行脚本的时候可以通过添加 <code>--login</code> 或者 <code>-l</code> 的选项来使这个 shell 去读取 <code>Startup Files</code>，因为它没有输入口令的登录动作，只有读取和执行 Startup Files 。</p>
<p>另外，你在 X Windows 下运行 <code>terminal</code> 软件打开的 shell 是 <code>non-login &amp; interactive</code> 模式的。如果你曾有<strong>在视窗下打开 shell 却无法获取 <code>～/bash_profile</code> 中定义的变量</strong>的疑惑的话，现在你可以释然了（尤其是使用图形界面安装过 Oracle 的 DBA 们，你们是否也好奇：明明设置好了环境变量，为何每次在图形界面下执行<code>dbca</code>都会找不到命令，还必须手动执行以下<code>source ~/.bash_profile</code>）。</p>
<p>来做个实验吧，我事先在 <code>/etc/profile</code>、<code>/etc/bashrc</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code> 中增加了 <code>echo “Hello from xxxx”</code> 的语句，让我们来看看各种情况下我们得到的 shell 到底执行了哪些文件：</p>
<ol>
<li><p>sshd</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;11:07&#125;~ ➭ ssh root@192.168.1.41</span><br><span class="line">Last login: Wed Dec  4 10:44:06 2019 from 192.168.1.183</span><br><span class="line">Hello from /etc/profile</span><br><span class="line">Hello from /etc/bashrc</span><br><span class="line">Hello from ~/.bashrc</span><br><span class="line">Hello from ~/.bash_profile</span><br></pre></td></tr></table></figure>

<blockquote>
<p>~&#x2F;.bash_profile 调用了 ~&#x2F;.bashrc， ~&#x2F;.bashrc 调用了 &#x2F;etc&#x2F;bashrc，所以 shell 调用的是&#x2F;etc&#x2F;profile 和 ~&#x2F;.bash_profile</p>
</blockquote>
</li>
<li><p>GUI Terminal</p>
<p> <img data-src="https://qiniu.liupzmin.com/terminal-bash.bmp" alt="terminal bash"></p>
<p> GUI 下打开 shell 只运行了 <code>~/.bashrc</code>。</p>
</li>
<li><p>运行 bash</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@afis-db ~]# bash</span><br><span class="line">Hello from /etc/bashrc</span><br><span class="line">Hello from ~/.bashrc</span><br><span class="line">[root@afis-db ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@afis-db ~]# bash -l</span><br><span class="line">Hello from /etc/profile</span><br><span class="line">Hello from /etc/bashrc</span><br><span class="line">Hello from ~/.bashrc</span><br><span class="line">Hello from ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p> 默认情况下，bash 命令进入的是一个非登录的交互式子 shell，当使用 <code>-l</code> 或 <code>--login</code> 选项后进入的是登录的交互式子 shell 。</p>
</li>
<li><p>su</p>
<p> <code>su</code> 的功能是切换用户，其中 <code>-</code> 选项表示登录，一个登录的 shell 在 ps 中显示为<code>-bash</code>，非登录的显示为 <code>bash</code>。</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@afis-db ~]# su - oracle</span><br><span class="line">Hello from /etc/profile</span><br><span class="line">Hello from /etc/bashrc</span><br><span class="line">Hello from ~/.bashrc</span><br><span class="line">Hello from ~/.bash_profile</span><br><span class="line">[oracle@afis-db ~]$ echo $$</span><br><span class="line">11935</span><br><span class="line">[oracle@afis-db ~]$ ps -ef|grep 11935</span><br><span class="line">oracle   11935 11934  0 13:22 pts/1    00:00:00 -bash</span><br><span class="line">oracle   11960 11935  0 13:22 pts/1    00:00:00 ps -ef</span><br><span class="line">oracle   11961 11935  0 13:22 pts/1    00:00:00 grep 11935</span><br><span class="line">[oracle@afis-db ~]$ exit</span><br><span class="line">logout</span><br><span class="line">[root@afis-db ~]# su oracle</span><br><span class="line">Hello from /etc/bashrc</span><br><span class="line">Hello from ~/.bashrc</span><br><span class="line">[oracle@afis-db root]$ echo $$</span><br><span class="line">11965</span><br><span class="line">[oracle@afis-db root]$ ps -ef|grep 11965</span><br><span class="line">oracle   11965 11964  0 13:22 pts/1    00:00:00 bash</span><br><span class="line">oracle   11982 11965  4 13:22 pts/1    00:00:00 ps -ef</span><br><span class="line">oracle   11983 11965  0 13:22 pts/1    00:00:00 grep 11965</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行脚本—非交互模式</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@afis-db ~]# ./script.sh </span><br><span class="line">I am script!</span><br><span class="line">[root@afis-db ~]# bash script.sh </span><br><span class="line">I am script!</span><br><span class="line">[root@afis-db ~]# bash -l script.sh </span><br><span class="line">Hello from /etc/profile</span><br><span class="line">Hello from /etc/bashrc</span><br><span class="line">Hello from ~/.bashrc</span><br><span class="line">Hello from ~/.bash_profile</span><br><span class="line">I am script!</span><br></pre></td></tr></table></figure>

<p> 可见在非交互模式下不会读取任何文件，增加了登录选项则会依次读取 Startup Files。</p>
</li>
</ol>
<p>我们很少以 <code>bash script.sh</code> 这种方式执行脚本，更多的是以 <code>./script.sh</code>运行，当以后一种方式执行时，真正执行脚本的解释器依赖于具体的 <code>Shebang</code>。而我们经常看到使用 <code>sh script.sh</code> 这样的方式执行，那 <code>sh</code> 究竟是什么呢？</p>
<p>在大多数 Linux 发行版中，<code>sh 通常是 bash 的软连接</code>，但是 bash 文章中有如下描述：</p>
<blockquote>
<p>If Bash is invoked with the name sh, it tries to mimic the startup behavior of historical versions of sh as closely as possible, while conforming to the POSIX standard as well.</p>
</blockquote>
<blockquote>
<p>When invoked as sh, Bash enters POSIX mode after the startup files are read.</p>
</blockquote>
<p>意思是<code>当你用 sh 来启动 shell 的时候，bash 会以 posix 标准模式运行</code>，就如同调用了 <code>bash --posix</code>。需要注意的是：**<code>sh</code> 并不是一个具体的 shell 实现，而是一种规格标准，bash 在这种模式下运行的时候，将遵循 posix 的标准去读取执行文件**。如下图所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/sh.png" alt="sh and startup files"></p>
<p>来实地验证一下：</p>
<ol>
<li><p>运行 sh</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@afis-db ~]# sh</span><br><span class="line">sh-4.1# exit</span><br><span class="line">exit</span><br><span class="line">[root@afis-db ~]# sh -l</span><br><span class="line">Hello from /etc/profile</span><br><span class="line">Hello from ~/.profile.(this file is touched by me)</span><br></pre></td></tr></table></figure></li>
<li><p>执行脚本</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@afis-db ~]# sh script.sh </span><br><span class="line">I am script!</span><br><span class="line">[root@afis-db ~]# sh -l script.sh </span><br><span class="line">Hello from /etc/profile</span><br><span class="line">Hello from ~/.profile.(this file is touched by me)</span><br><span class="line">I am script!</span><br></pre></td></tr></table></figure></li>
</ol>
<p>因为生产服务器上使用 Bash 居多，而线上服务多少都依托于 shell 去调用，因为不同的调用方式下 shell 读取执行文件的规则不同，这样就可能对应用造成一定程度的困扰。我曾经维护一个线上的 java 项目，这个项目有上百个 java 服务需要每天定时重启，项目上线时反复检查验证了 cron 服务的配置以确保万无一失，而没有想到启停脚本对环境变量 <code>JAVA_HOME</code> 的依赖会在 cron 调用的时候失效。如今看来，只要使用登录非交互模式即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本片文章细节太过零散，去验证以及查阅资料花了不少时间，其实写作的最初兴奋点是想从 <code>fork &amp; exec</code> 的角度去理解 Linux 上各种执行程序的方式，但是回头一看，关于 fork 和 exec 的介绍只有寥寥几笔，剩下的都是关于细节的追求与验证，但是 <code>Done is better than perfect</code>～</p>
<p>因能力有限，行文或有疏漏与错误之处，望阅读本文的朋友给予斧正，也希望了解其它启动方式的朋友不吝赐教。</p>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5mYXFzLm9yZy9mYXFzL3VuaXgtZmFxL2ZhcS9wYXJ0My9zZWN0aW9uLTE2Lmh0bWw=">Why do some scripts start with #! ... ?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9iYXNoLmh0bWw=">Bash Reference Manual<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC8xNDA3X2xpdW1pbmdfaW5pdDEvaW5kZXguaHRtbA==">浅析 Linux 初始化 init 系统——sysvinit<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC8xNDA3X2xpdW1pbmdfaW5pdDMvaW5kZXguaHRtbA==">浅析 Linux 初始化 init 系统——Systemd<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDEzLzA4L2xpbnV4X2Jvb3RfcHJvY2Vzcy5odG1s">Linux 的启动流程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTc5OTguaHRtbA==">LINUX PID 1 和 SYSTEMD<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80MTI2L3doYXQtaXMtdGhlLWV4YWN0LWRpZmZlcmVuY2UtYmV0d2Vlbi1hLXRlcm1pbmFsLWEtc2hlbGwtYS10dHktYW5kLWEtY29uP2Fuc3dlcnRhYj1hY3RpdmUjdGFiLXRvcA==">Difference between a &#39;terminal&#39;, a &#39;shell&#39;, a &#39;tty&#39; and a &#39;console&#39;?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueWFuYmluZ2h1LmNvbS8yMDE5LzEwLzA3LzE0NDQyLmh0bWw=">为什么执行自己的程序时需要加上点斜杠<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU2hlYmFuZw==">Shebang<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmF2YV9jbGFzc19maWxl">Java class file<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW55bGFiLm9yZy9nb29kYnllLWEub3V0Lw==">为 a.out 举行一个特殊的告别仪式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy55dW53ZWlwYWkuY29tL2FyY2hpdmVzLzQ0NzkuaHRtbA==">Linux cron运行原理<i class="fa fa-external-link-alt"></i></span></li>
<li><code>《程序员的自我修养》</code></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/11/06/docker/container-chat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/06/docker/container-chat/" class="post-title-link" itemprop="url">漫谈容器发展史</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-06 10:10:51" itemprop="dateCreated datePublished" datetime="2019-11-06T10:10:51+08:00">2019-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/container/" itemprop="url" rel="index"><span itemprop="name">container</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong><code>左耳朵耗子</code>说过一段话，我深以为然。</strong></p>
<blockquote>
<p>技术的发展过程非常重要，要尽可能早的进入时下的新技术，而不应等待这些技术成熟之后再进入。我进入 Go 和 Docker 的技术不能算早，但也不算晚，从 2012 年学习 Go，到 2013 年学习 Docker 到今天，我清楚地看到了这两种技术的生态圈发展过程。让我收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。从中，我看到了非常具体的各种思潮和思路，这些东西比起 Go 和 Docker 来说更有价值。因为，这不但让我重新思考我已掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。</p>
</blockquote>
<h2 id="改变世界的“箱子”"><a href="#改变世界的“箱子”" class="headerlink" title="改变世界的“箱子”"></a>改变世界的“箱子”</h2><p>1956 年 4 月 26 号，<code>麦克莱恩</code>的第一艘集装箱货船<code>理性X号</code>从纽约港起航，他无从预想，这个简陋的发明，在未来几十年内会彻底改变人类的命运，将人类的航运业带入了一个巨大的新时代。</p>
<p>集装箱的发明，极大地推动了全球化的协作浪潮，使得制造业的产业链条发生了翻天覆地的变化。从集装箱规模化应用的那一刻，地球变成了一座巨大的工厂，开始轰鸣了起来。</p>
<p>因为集装箱，商品以及原材料可以以极低的运输成本送往世界各地，从而使得全球的资源都卷入到了分工链条当中，经济学家讲：<code>分工产生效能</code>，因为生产效能的极大提升，人类创造了不可胜数的财富。而集装箱的影响依然在持续，依然在不断的改变着我们每一个人的生活。</p>
<p>到了 80 年代，突然大门一开，进来一个胖子，就是我们中国人。我们啥都没有，我们没有资金没有技术，但是我们有勤劳的双手，我们有庞大的人口存量，所以我们用这个优势进入到了全球化的分工当中。</p>
<p>结果呢，中国用 35 年的时间完成了西方 300 多年的工业革命进程，而这已经是中国<code>第四次进行工业化革命的尝试</code>了，你能说集装箱没有功劳么。</p>
<p>可是，像这样具有伟大意义的发明，在其问世的前十年可谓历尽坎坷，并没有让<code>麦克莱恩</code>占据领航者的地位。甚至最早的集装箱都不是<code>麦克莱恩</code>发明的，但他却是集装箱真正意义上的践行者。因此，人类最终将<code>集装箱之父</code>的荣誉授予他。</p>
<p>《经济学家》这样评价：<strong>如果没有集装箱，就不会有全球化!</strong></p>
<p>如果你打开 <code>Google 翻译</code>翻译一下“集装箱”这个词，你会得到如下的答案：</p>
<p><strong>Container</strong></p>
<p>在英文中一词多义可能表示<code>多义</code>之间具有<code>意义的延伸</code>。</p>
<p><strong>容器</strong> 不正是如此么？</p>
<h2 id="第一道灵光"><a href="#第一道灵光" class="headerlink" title="第一道灵光"></a>第一道灵光</h2><p>让我们将历史拨回到 1979 年，贝尔实验室的一群大男孩亦或是老男孩正在开发 <code>unix v7（Version 7 Unix）</code> 操作系统。项目进行到了最后的开发和测试阶段，即便是对于这些天才般的程序员来说，系统级别的软件构建和测试仍然是一个繁复且无比棘手的难题。你可以想象：当一次测试开始，源代码编译和安装完成之后，整个测试环境就被<code>“污染”</code>了。要想进行下一次测试，就需要重新搭建，并且再编译安装测试。那有没有办法来避免重复的环境搭建，快速的销毁和重建所需的基础设施环境呢？</p>
<p>我们今天有虚拟化和云计算，这个问题听起来好像不难解决。但是，在那个计算机软件刚刚萌芽的蛮荒时代，这样的想法近乎是异想天开。一块 <code>64K</code> 的内存条要卖 <code>419 美元</code>的年代，<code>“快速销毁和重建基础设施”</code>的想法还是有点“科幻”了。</p>
<p>但天才毕竟是天才，这些黑客程序员们就想，能不能在现有的操作系统环境下<code>“隔离”</code>出一个新环境用于软件的构建和测试呢？</p>
<p>于是，一个叫做 <code>chroot（Change Root）</code> 的系统调用就此诞生了！</p>
<p><code>chroot</code> 会重定向进程及其子进程的<code>根目录</code>到操作系统上的一个新位置，使得该进程的文件<code>“视图”</code>与外面的<code>“世界”</code>完全隔离，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p>
<p>这是容器史上第一道乍现的灵光，在 <code>unix v7</code> 上面被孕育出来。</p>
<p>但令人叹息的是，unix v7 是贝尔实验室发布的最后一个可自由分发的版本，之后 AT&amp;T 开始收回 Unix 的版权，倾情弹奏 Unix 商业化的序曲。也正因为此， <code>Richard Matthew Stallman</code> 在 1983 年发起 <code>GUN（GNU&#39;s Not UNIX）</code> 计划和<code>自由软件运动</code>，几十年后垂垂老矣的 Unix 最终被商业的 Linux 击溃。</p>
<p>然而，chroot 毕竟打开了进程隔离的大门，虽然孕育它的 Unix 在后续的发展中逐渐式微，但容器化的思想却如同奔流不息的河流一般，跨越了重重艰难险阻，不断地在历史的精彩处漫延。</p>
<h2 id="百家争鸣"><a href="#百家争鸣" class="headerlink" title="百家争鸣"></a>百家争鸣</h2><p>2000 年，Unix伯克利大学分发版 <code>FreeBSD</code> 操作系统发布了 <code>jail</code> 命令。<code>jail</code> 是从 chroot 得到的启发，并从中进一步发展而来，它将隔离扩展到了整个用户环境，使得进程在一个<code>沙盒</code>内运行。在进程看来，跟实际的操作系统几乎是一样的，对于进程来说就像被关进了<code>监狱</code>，这也是 <code>jail</code> 名称的由来，<code>jail</code> 中的进程甚至可以拥有自己的 IP 地址，可以对环境进行各种定制。我们可以说， <code>chroot 开创了进程隔离的思想</code>，但 <code>FreeBSD Jails 才真正实现了进程的沙箱化</code>。</p>
<p>2004年，Solaris Containers 发布，它也是秉承了 <code>jail</code> 的思想，为进程提供一个隔离的<code>沙盒</code>，进程在其中独立运行。它也被称为<code>“吃了类固醇的 chroot ”（chroot on steroids）</code>。</p>
<p>不过，无论是 <code>FreeBSD Jails</code> ，还是紧接着出现的 <code>Solaris Containers</code> ，都没有能在更广泛的软件开发和交付场景中扮演到更重要的角色。在这段属于 <code>Jails</code> 们的时代，进程沙箱技术因为“云”的概念尚未普及，始终被局限在了小众而有限的世界里。就如同集装箱刚刚出现的那十年，所有和集装箱配套的设施都还没有，整个社会都还没有为集装箱做好准备。你看，他们两者不仅意义上相近，就连命运也如出一辙。</p>
<p><strong>可见，任何一种新技术，即便问世很早，可要整个社会系统去适应它，却需要一个无比漫长的过程。</strong></p>
<p>让我们回到容器技术上来，事实上，在 <code>Jails</code> 大行其道的这几年间，同样在迅速发展的 Linux 阵营上也陆续出现多个类似的沙箱技术比如 <code>Linux VServer</code> 和 <code>Open VZ</code> （未进入内核主干）。但如同那些 <code>jail</code> 的前辈一样，受当时计算机环境的制约，被局限在一个小众的圈子里。</p>
<p>早在 2002 年，<code>Plan 9 from Bell Labs</code>（Go语言的运行时就是使用的该操作系统的汇编器语法）操作系统对 <code>Namespace</code> 的广泛运用为 Linux 带来了灵感， Linux 在其内核 2.4.19 版本上加入了 Namesapce 功能（可以实现对应资源的隔离）。最初只有<code>mount namespace</code>，后续的<code>pid</code>、<code>net</code>、<code>ipc</code>、<code>UTS</code>、<code>user</code>等一直到内核3.8版本才实现完成。内核<code>4.6</code>中又添加了<code>Cgroup namespace</code>。</p>
<p>要知道 <code>Namespace</code> 是现代容器技术最底层的技术支撑。它虽然解决了虚拟化和资源环境隔离的问题，但是我们还希望对隔离的进程在资源使用上加以限制，namespace并没有提供解决方案。</p>
<p>2007年，一种名叫 <code>Process Container</code> 技术的发布。它是由 Google 的工程师 <code>Paul Menage</code> 和 <code>Rohit Seth</code> 发起并实现的，旨在对一组进程进行资源上的隔离、限制。在合并入 Linux 内核的时候，由于 Linux 中存在 <code>Container</code> 的概念，故被重命名为 <code>Cgroups</code> 。</p>
<p><code>Cgroups</code> 有两个版本，<code>v1</code> 版本由 <code>Paul Menage</code> 和<code> Rohit Seth</code> 维护。<code>v2</code> 版本首次出现在 2016 年 3 月发布的内核 <code>4.5</code> 中，<code>Tejun Heo</code> 重新设计并重写了Cgroups，主要解决 v1 在用户体验上的问题。</p>
<p>2008 年，通过将 <code>Cgroups</code> 的资源管理能力和 <code>Linux Namespace</code> 的视图隔离能力组合在一起， <code>LXC（Linux Container）</code> 这样的完整的容器技术出现在了 Linux 内核当中。它是第一个完善的容器管理方案，你可以通过 LXC 来创建和启动容器了。 <code>LXC</code> 跟之前出现的沙盒技术非常类似，但其赶上了 Linux 大规模商用的浪潮，境遇要比那些前辈们要好一些。伴随着公有云市场的崛起，很快催生了一个全新的、名为 <code>PaaS</code> 的产业。</p>
<p>2011 年，由 Vmware 主导的 Cloud Foundry 开发了一个新项目：<code>Warden</code>，它最开始是一个 <code>LXC</code> 的封装，后来重构成了直接对 <code>Cgroups</code> 以及 <code>Linux Namespace</code> 操作的架构。</p>
<p>Cloud Foundry 项目的诞生，第一次对 <code>PaaS</code> 的概念完成了清晰而完整的定义。这其中，“<code>PaaS 项目通过对应用的直接管理、编排和调度让开发者专注于业务逻辑而非基础设施</code>”，以及<code>“PaaS 项目通过容器技术来封装和启动应用”</code>等理念，也第一次出现在云计算产业当中并得到认可。</p>
<p>按照这个剧本，容器技术以及云计算的发展，理应向着 PaaS 的和以应用为中心的方向继续演进下去。</p>
<p>如果不是有一家叫做 <code>Docker</code> 的公司出现的话。</p>
<h2 id="另一只”箱子“"><a href="#另一只”箱子“" class="headerlink" title="另一只”箱子“"></a>另一只”箱子“</h2><p>时间来到了 2013 年，<code>Docker</code> 的第一个版本发布，它是基于 LXC 的，但它创建和使用应用容器的逻辑跟 <code>Warden</code> 等没有本质不同。只不过是把 LXC 复杂的创建和使用方式简化成了自己的一套命令体系。但是 Docker 作为 PaaS 行业的搅局者，其真正的杀手锏是<code>容器镜像</code>。Docker 通过镜像技术，提出了<code>build</code>、<code>ship</code>、<code>run</code>的概念，创造了<code>一次构建、处处运行</code>的新思想，将容器技术向IT产业链条的上游和下游进行了延伸。</p>
<p>关于如何封装应用，这本身不是开发者所关心的事情，所以 <code>PaaS</code> 项目有着无数的发挥空间。但到这如何定义应用这个问题，就是跟每一位技术人员息息相关了。在那个时候，<code>Cloud Foundry</code> 给出的方法是 <code>Buildpack</code> ，它是一个应用可运行文件（比如 <code>WAR</code> 包）的封装，然后在里面内置了 <code>Cloud Foundry</code> 可以识别的启动和停止脚本，以及配置信息。</p>
<p>然而，Docker 项目通过容器镜像，直接将一个应用运行所需的完整环境，即：整个操作系统的文件系统也打包了进去。这种思路，可算是解决了困扰 PaaS 用户已久的一致性问题，制作一个<code>“一次构建、处处运行”</code>的 Docker 镜像的意义，一下子就比制作一个连开发和测试环境都无法统一的 <code>Buildpack</code> 高明了太多。</p>
<p>更为重要的是，Docker 项目还在容器镜像的制作上引入了“层”的概念，这种基于“层”（也就是<code>“commit”</code> ) 进行 <code>build</code>，<code>push</code>，<code>update</code> 的思路，显然是借鉴了 <code>Git</code> 的思想。所以这个做法的好处也跟 <code>Github</code> 如出一辙：制作 Docker 镜像不再是一个枯燥而乏味的事情，因为通过 <code>DockerHub</code> 这样的镜像托管仓库，你和你的软件立刻就可以参与到全世界软件分发的流程当中了。</p>
<p>至此，你就应该明白，Docker 项目实际上解决的确实是一个更高维度的问题：<code>软件究竟应该通过什么样的方式进行交付？</code></p>
<p>更重要的是，一旦当软件的交付方式定义的如此清晰并且完备的时候，利用这个定义在去做一个托管软件的平台比如 PaaS，就变得非常简单而明了了。这也是为什么 Docker 项目会多次表示自己只是“站在巨人肩膀上”的根本原因：没有最近十年 Linux 容器等技术的提出与完善，要通过一个开源项目来定义并且统一软件的交付历程，恐怕如痴人说梦。</p>
<p>然而，这并没有使 Docker 站在领导者的位置上。<code>CoreOS</code> 是一个专注于容器的操作系统，一度与 Docker 打的很火热，但是 CoreOS 渐渐的发现 Docker 野心很大，甚至动了 CoreOS 的市场。至于 Docker 有什么野心，我后面会讲。 CoreOS 不肯坐以待毙，于是在 2014 年推出了新的容器引擎 <code>rocket</code> 。后来谷歌开始支持 CoreOS ，容器就此分化成了 Docker 阵营和 Google 阵营。也就在同一年，Docker 0.9 发布，用 <code>libcontainer</code> 库代替了原来的 LXC 。</p>
<p>到了 2015 年，容器圈太乱了，大家觉得长此以往不利于发展，于是就组织起来，在 Linux 基金会的支持下成立了 <code>OCI（Open Constitution Initiative）</code> 。<code>OCI</code> 致力于围绕<code>容器镜像格式</code>和<code>容器运行时</code>建立开发的行业标准，让容器可以在各种兼容性的操作系统和平台上移植，没有人为的技术屏障。大家并不希望这个工业标准由 Docker 一家说了算。</p>
<p>2016 年 Docker 发布了 1.11 版本，做了一些架构调整，里面新出现了符合 OCI 标准的 <code>runC</code> 。runC 其实就是对 libcontainer 的调用，是一种符合开放式容器格式标准的一种实现，后来 Docker 就把 runC 贡献出来了。</p>
<p>下图是 2018 年容器市场份额统计：</p>
<p><img data-src="http://qiniu.liupzmin.com/2018-container.png" alt="Container Market Shares"></p>
<p>可见 2018 年的容器市场 Docker 占了 83% ，这个数据乍看之下相当可观，可是你要知道在 2017 年这个份额还是99%。位居第二的就是占比12%的 rocket ，第三是 mesos ，占比4%，第四是我们介绍过的 LXC 占比仅有1%。</p>
<p>现在，我们可以得出一个结论，**<code>Docker 并不等于容器</code>**。如果你想用容器，其实你有很多选择，Docker 仅仅是你的首选而已。如今<code>下一代容器架构</code>的呼声言犹在耳（ <code>Podman + Skopeo + Buildah</code> ），我们不禁要问了：既然 Docker 这么优秀，为什么会落到如此众叛亲离的地步呢？</p>
<h2 id="编排大战"><a href="#编排大战" class="headerlink" title="编排大战"></a>编排大战</h2><p> 如今我们知道，现代容器的底层技术为 <code>Namespace</code> 和 <code>Cgroups</code> ，Docker 因为带来了革命性的容器镜像思想而异军突起，在容器领域大张挞伐，并在短时间内挤占市场。虽然表面上风光无限，却终究难掩容器技术门槛偏低的事实，也就是说任何公司和组织都可以利用 <code>Namespace</code> 和 <code>Cgroups</code> 进入容器市场（比如 CoreOS 的 <code>rocket</code> ）， Docker 更是深谙此道，因此它必须寻求突破。</p>
<p> 试想一下， Docker 容器发端之后，感觉一下子拥有了可以施展黑科技的魔法棒，但为什么只能搞搞开发、测试这种小打小闹的活儿呢？根本没有生产力大爆发啊？好像也没有改变整个行业的协作方式啊？你看，这是不是和集装箱刚刚问世的前十年非常像呢？那个时候整个社会协作体系还没有为集装箱做好准备，配套的道路、桥梁、码头、吊车等设备和基础设施全都没有就绪。</p>
<p>回到 Docker 上，我们不禁要问：我们的码头和吊车，乃至相应的货轮、桥梁准备好了么？全产业界已经接受了以容器镜像为主要形态的软件发布模式了吗？应用的执行都基于容器了吗？分布式以及微服务架构已经非常普及了吗？</p>
<p>显然还没有。</p>
<p>这里我们不得不提一个观点：<code>容器本身并没有价值</code>。就像集装箱一样，本身就是个大铁盒子，它没有太多价值，单单靠它提高不了社会协作的效能。它只有流动起来，才会产生价值，把货物从一个车间运到另一个车间，这种连接才是其价值所在。容器也一样，本身没有太多商业价值，你弄得再完美，你也只能在一个服务器上折腾，翻不出多大的浪花，那怎么样才能产生价值呢？</p>
<p>那就是真正价值所在——<code>容器编排</code>！</p>
<p>在既有硬件资源的基础上，启动容器不需要关注具体运行的节点，各个容器之间仍能保持通信，信息在容器之间依然可以流动。这样就拥有了商业价值，容器技术便可以付诸商用，整个软件的开发交付流程就会变得高效和颠覆。所以我们需要的是一个分布式的调度器，其主要功能就是容器编排。</p>
<p>Docker 也深知这一点，当它不顾一切于 2015 年带着 <code>Swarm</code> 挤进编排领域的时候，发现面前立着一座大山： <code>Kubernetes</code>！</p>
<p><code>Kubernetes</code> 源于 Google 内部的 <code>Borg</code> 项目，经 Google 使用 Go 语言重写后，被命名为 Kubernetes，并于 2014 年 6 月开源。Kubernetes 希腊语意思是<code>“舵手”</code>，致力于管理数以万计的容器集群。你看舵手不正是隐喻了<code>方向</code>和<code>流动</code>么。因其开头字母和结尾字母之间共有 8 个字，所以简短的称其为<code>k8s</code>。</p>
<p>2014 年 k8s 开源之后，同年底 Docker 就设计了 <code>machine+swarm+compose</code> 的组合方案。2015 年 7 月 k8s 发布了第一个商用版本 1.0 ，同一年 Docker 的 Swarm 发布，编排大战已经开始上演了。</p>
<p>2016 年 2 月 Docker 发布了 1.12 版本，它不顾众怒，将 <code>Swarm</code> 强行内置到 Docker 的容器引擎里面，企图利用 Docker 项目在容器领域的领导地位推动 <code>Swarm</code> 的发展。这有点像什么？举个不恰当的例子，我订购了一个集装箱，你却附赠了一个不太好用的货轮。这一下一石惊起千层浪，业界都纷纷谴责 Docker 。同年的 7 月 <code>Apache mesos</code> 发布了 1.0 ，也是一个容器编排框架，至此，<code>Kubernetes</code>、<code>Docker Swarm</code> 和 <code>Apache Mesos</code> 已成三足鼎立之势。</p>
<p>然而，2017 年 9 月，<code>Mesosphere</code> 宣布支持 Kubernetes，这也是迫于用户压力，在对抗和妥协面前，不得不选择后者。</p>
<p>2017 年 10 月，在欧洲的 <code>DockerCon</code> 大会上，Docker 公司 CTO <code>Solomon Hykes</code> 宣布，Docker 的下个版本将支持 Kubernetes，台下观众响起热烈掌声，因为这是容器圈等待已久的消息。</p>
<p>Kubernetes 在众多厂商和开源爱好者的共同努力下迅速崛起，时至今日已成长为容器管理领域的事实标准。Kubernetes 极大推动了云原生领域的发展，被称为影响云计算未来 10 年的技术。</p>
<p>毫无疑问，Kubernetes 已经赢得了容器编排的大战。</p>
<h2 id="Docker-会是改变世界的那只“箱子”吗？"><a href="#Docker-会是改变世界的那只“箱子”吗？" class="headerlink" title="Docker 会是改变世界的那只“箱子”吗？"></a>Docker 会是改变世界的那只“箱子”吗？</h2><p>2001 年 5 月 30 号，集装箱之父麦克莱恩去世。全世界所有的集装箱船，不管在哪个港口，不管在全球的哪个角落，都拉响了汽笛，向这位老人致敬，我想这是一个创新者得到的最高荣誉。</p>
<p>那么， <code>Docker 会是改变世界的那只“箱子”吗？</code></p>
<p>这要看你怎么理解 Docker ，如果我们把它理解为<code>容器技术</code>和 <code>build</code>、<code>ship</code>、<code>run</code> 这样<code>一次构建，处处运行</code>的理念，那么我相信它是改变世界的箱子。当我们软件发布模式已经切换到容器镜像形态的时候，当我们应用的运行都是基于容器的时候，当分布式的操作系统或者平台已经整装待发的时候，它有什么理由不改变世界呢？我们没法想象那时 IT 世界会是什么样子的，但有一点可以肯定，IT 世界的分工协作方式以及产业链条肯定是一个全新的面貌。</p>
<p>反观 Docker 作为一家公司，它会是改变世界的箱子么？我觉得很大可能不会。</p>
<p>上个世纪 80 年代，在集装箱刚刚发力的时候，麦克莱恩破产了。那他犯了什么错误吗？没有，他就是跑慢了，没有什么实质性的错误。Docker 很可能步他的后尘，但是那又怎么样呢？ Docker 已经完成了它的历史使命，在让 IT 的世界工厂运转起来的路上，它已经推了一把，这本身就已经足够了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>早在 2014 年，RedHat 就与 Kubernetes 达成了战略合作关系，宣布全面投入 Kubernetes。在当时的一份官宣中， RedHat 以非常自信的姿态表达了对容器的“颠覆性”创新的认可，并大胆预言 Kubernetes 会在 2015 年后取得应用编排与管理领域的统治地位。</p>
<p>当时业界对这个论断大多不以为然，甚至嗤之以鼻，但今天回过头来再看，预言已经成为事实。</p>
<p><code>Rancher</code> 的创始人梁胜博士有过一句评论，非常在理：时至今日，在容器技术领域依然有许多创新，只不过这些创新大多发生在 Kubernetes 以及 CNCF 生态系统中了。</p>
<p>是的，比如最近很火的 <code>Service Mesh</code> 的实现 <code>istio</code> ， 它就是基于 kubernetes 进行的创新啊。</p>
<p>这有点像以前在单片机上玩汇编，汇编说白了就是单片机上运行的应用程序，但是后来有人写了个超级大的应用程序，那就是操作系统，然后大家就都在操作系统上玩了。而 Kubernetes 不正是云时代分布式的操作系统么？</p>
<p>回到文章开头的主题上，我们应该及早的进入到一个新兴的技术领域，即使 Docker 会在不久的将来被下一代容器取代，我们也仍然有必要去学习它。因为你最终得到的并不是这项技术本身，而是整个技术领域的发展脉络与思潮演变，这才是无比珍贵的东西。因为一旦你对技术的发展有所感知，它就可能会影响到你未来的人生选择。</p>
<p><strong>我们仍然身处在容器化变革的浪潮当中，你无法想象它将来会对你的命运产生什么样的影响。我们每一个人都像是这个湍流中行进的小船，方向决定了你驶向远方还是抵触暗礁。我们唯一能做的，就是拿一根竹篙，根据水流的情况和环境的变化随时的轻轻点那么一下，微微的改变一下我们的航迹。</strong></p>
<blockquote>
<p> 注：本文很多段落，大段引用了<code>张磊</code>老师的文章，我读过他的<code>《Docker 容器与容器云》</code>，订阅过他的极客时间专栏<code>《深入剖析Kubernetes》</code>，深深佩服其学识之渊博。在有些关于容器发展史的描述中，我基本上引用了原话，因为自知不能写的更好。</p>
</blockquote>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGludXhfbmFtZXNwYWNlcw==">Linux namespaces<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2dyb3Vwcw==">cgroups<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTcwNDkuaHRtbA==">DOCKER基础技术：LINUX CGROUP<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS93aWxsLWRvY2tlci1iZS10aGUtYm94LXRoYXQtY2hhbmdlLXRoZS13b3JsZA==">Docker 会是改变世界的那只“箱子”吗？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9SMXAzSDNfMjlmNFRZSW1FeHN5dw==">为什么说 2019，是属于容器技术的时代？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTY5NzUtMS5odG1s">Linux 容器技术史话：从 chroot 到未来<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTcwMTAuaHRtbA==">DOCKER基础技术：LINUX NAMESPACE（上）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3BhcmtkZXYvcC85MzY1NDA1Lmh0bWw=">Linux Namespace : 简介<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYnMuaHVhd2VpY2xvdWQuY29tL2Jsb2dzLzEyOTM3MQ==">下一代容器架构已出，Docker何去何处？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9kb2NrZXItc3RhbmRhcmQtY29udGFpbmVyLWV4ZWN1dGlvbi1lbmdpbmUtcnVuYw==">Docker 背后的标准化容器执行引擎——runC<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"liupzmin","repo":"liupzmin.github.io","client_id":"77654195445087c01c56","client_secret":"eda09eecd05b86f0ef995d8067ec751abeb753d9","admin_user":"liupzmin","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","ClientID":"ae0756501dfc5de89d35","ClientSecret":"26befb359f7a466031bb96b4b7e0715c41c63fb8","owner":"liupzmin","adminUser":"['liupzmin']","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","createIssueManually":true,"distractionFreeMode":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"9d8d3da09189165dcde8f1d3e109ad78"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
