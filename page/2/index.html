<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liupzmin.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="左手人文 | 右手科技">
<meta property="og:type" content="website">
<meta property="og:title" content="兔子先生">
<meta property="og:url" content="http://liupzmin.com/page/2/index.html">
<meta property="og:site_name" content="兔子先生">
<meta property="og:description" content="左手人文 | 右手科技">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="巴流">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://liupzmin.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>兔子先生 - 探寻计算机的历史与哲学密码</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="兔子先生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">兔子先生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探寻计算机的历史与哲学密码</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">63</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="巴流"
      src="/images/gzh.jpg">
  <p class="site-author-name" itemprop="name">巴流</p>
  <div class="site-description" itemprop="description">左手人文 | 右手科技</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liupzmin"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdXB6bWluQGdtYWlsLmNvbQ==" title="E-Mail → mailto:liupzmin@gmail.com"><i class="envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2023/04/01/network/running-grpc-service-in-production/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/01/network/running-grpc-service-in-production/" class="post-title-link" itemprop="url">在生产环境中运行 grpc 服务所面临的挑战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-01 15:18:20" itemprop="dateCreated datePublished" datetime="2023-04-01T15:18:20+08:00">2023-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/computer-theory/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文链接:<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2luY29nbmlhLXRlY2gvY2hhbGxlbmdlcy1vZi1ydW5uaW5nLWdycGMtc2VydmljZXMtaW4tcHJvZHVjdGlvbi1iM2ExMTNkZjI1NDI=">Challenges of running gRPC services in production<i class="fa fa-external-link-alt"></i></span></p>
<p>实现服务间通信的方式有若干种，这通常涉及到 TCP&#x2F;IP 协议族中的传输层。我们的应用程序经常依靠它来提供若干抽象和功能，例如负载均衡、重试和高可用性等。</p>
<p>然而，当我们在生产环境中运行服务时，我们会遇到更多网络相关的错误，这无疑超乎我们的想象。本文旨在阐释在使用 gRPC 进行服务间通信时，如何来缓解这些错误。</p>
<h1 id="Why-gRPC"><a href="#Why-gRPC" class="headerlink" title="Why gRPC?"></a>Why gRPC?</h1><p>回溯至 2016 年 ，彼时 Incognia 的服务几乎都在使用 HTTP1.1 &#x2F; JSON 技术栈进行通信。它在很长一段时间内运行良好，但随着公司的发展，一些高流量服务开始需要一种更高效的方式与内部客户端通信。</p>
<p>JSON API 的文档维护也很麻烦，因为它们没有与代码本身绑定，这意味着某人可以部署更改 API 的代码，却没有修改对应的文档。</p>
<p>为了寻找一个足够优秀的替代方案，我们调研了 grpc，它通过以下特性完美解决了性能问题以及上述模式定义问题：</p>
<ul>
<li>API 平面直接在 protobuf 文件中定义，其中每个方法都描述了自己的请求&#x2F;响应类型</li>
<li>自动生成多语言的客户端和服务端代码</li>
<li>与 Protobuf 结合，使用 HTTP&#x2F;2 协议，HTTP&#x2F;2 和 Protobuf 都是二进制协议，这意味着请求&#x2F;响应的有效载荷更加紧凑</li>
<li>而且，HTTP&#x2F;2 使用持久化连接，无需像 HTTP&#x2F;1.1 那样频繁地创建和销毁连接</li>
</ul>
<p>但是，运行 grpc 服务也给我们带来很多挑战，主要归因于 HTTP&#x2F;2 使用持久化连接这一事实。</p>
<h1 id="生产环境使用-gRPC-的挑战"><a href="#生产环境使用-gRPC-的挑战" class="headerlink" title="生产环境使用 gRPC 的挑战"></a>生产环境使用 gRPC 的挑战</h1><p>我们是 Kubernetes 的重度用户，因此我们的 grpc 服务全部运行在由 Amazon EKS 提供的 Kubernetes 集群之上。</p>
<p><strong>确保在 server 上负载均衡</strong>是面临的挑战之一。因为服务的数量是动态变化的，这是由（k8s的）自动伸缩功能决定的，所以客户端必须有能力识别新的 server，并剔除不可用的连接。与此同时还要保证所有的请求以某种负载均衡策略均衡地分布到这些 server 上。</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>对此， <span class="exturl" data-url="aHR0cHM6Ly9ncnBjLmlvL2Jsb2cvZ3JwYy1sb2FkLWJhbGFuY2luZy8=">The gRPC blog<i class="fa fa-external-link-alt"></i></span> 阐述了几种解决方案，大致可分为<strong>代理负载均衡</strong>（或服务端负载均衡）和<strong>客户端负载均衡</strong>。在下面的章节中，我将按时间线来讲述我们的实现方式。</p>
<h2 id="方式-1-使用-Linkerd-1-x-作为负载均衡代理"><a href="#方式-1-使用-Linkerd-1-x-作为负载均衡代理" class="headerlink" title="方式 1: 使用 Linkerd 1.x 作为负载均衡代理"></a>方式 1: 使用 Linkerd 1.x 作为负载均衡代理</h2><p>如图1所示，我们实现的第一种方式是使用一个名为 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpbmtlcmQvbGlua2VyZA==">Linkerd 1.x<i class="fa fa-external-link-alt"></i></span> 的代理负载均衡器。这种方式在一段时间内工作的很好，它在服务端解决了负载均衡问题，但没解决从客户端到代理的负载均衡问题，这意味某些 Linkerd 实例要处理比其它实例更多的请求。</p>
<p>这种不均衡后来被证实是有问题的，过载的实例可能会增加太多延迟，甚至有时会耗尽内存，变的越来越难以维护。</p>
<p>除此之外，我们在 Kubernetes 集群中将 Linkerd 部署为守护进程，这意味着 Linkerd pod 在集群中的每个工作节点上运行。因此，这种解决方案被证明会增加相当大的开销（因为它需要额外的网络跳跃），并且还会消耗大量资源。</p>
<p><img data-src="https://qiniu.liupzmin.com/proxy.png" alt="img"></p>
<p>Figure 1: Proxy load balancer approach</p>
<h2 id="方式-2-胖-gRPC-客户端"><a href="#方式-2-胖-gRPC-客户端" class="headerlink" title="方式 2: 胖 gRPC 客户端"></a>方式 2: 胖 gRPC 客户端</h2><p>将处理负载均衡的职责放到客户端代码，我们试图淘汰代理层，以此来尝试解决第一种方式带来的问题。</p>
<p>通过结合使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1nbw==">grpc-go<i class="fa fa-external-link-alt"></i></span> 的<code>naming.NewDNSResolverWithFreq(time.Duration)</code> 和 Kubernetes 的 <code>headless services</code>（处理 server pod的发现），我们在客户端处理负载均衡。使用这种方式，客户端需要每隔几秒钟轮询目标 service 的 DNS，以此来刷新可供连接的主机池。</p>
<p>与使用代理层相比，此处客户端与服务的pod直连，降低了调用延迟。下图展示了该方式所涉及到的组件。</p>
<p><img data-src="https://qiniu.liupzmin.com/thick-client.png" alt="img"></p>
<p>Figure 2: Thick client approach</p>
<p>然而，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1nby9pc3N1ZXMvMjMwNiNpc3N1ZWNvbW1lbnQtNDIxNDE2NjI2">Go gRPC 实现<i class="fa fa-external-link-alt"></i></span>不再支持使用 DNS 进行动态服务发现，而是推荐使用 xDS 等其他协议。而且，在其他语言中，DNS 动态服务发现从未被实现过。</p>
<p>我们知道，尽管这种方式带来了稳定和高性能的通信，但是由于 gRPC 实现的多样化，依赖客户端实现负载均衡终归是脆弱和难以维护的。这一点也同样适用于其它功能，比如限流和认证。</p>
<p>当尝试过这些不同的方法之后，我们清楚的认识到，我们需要一种通用、低成本、语言无关的方式来实现服务发现和负载均衡。</p>
<h2 id="方式-3-使用-Envoy-边车代理"><a href="#方式-3-使用-Envoy-边车代理" class="headerlink" title="方式 3: 使用 Envoy 边车代理"></a>方式 3: 使用 Envoy 边车代理</h2><p>经过一番调研，我们选择使用<strong>边车模式</strong>——在客户端 pod 中增加一个容器，由它来负责服务发现，负载均衡，以及一些针对连接的监测功能。从性能和部署简便性出发，我们选择了 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZW52b3lwcm94eS5pby8=">Envoy<i class="fa fa-external-link-alt"></i></span>。</p>
<p><img data-src="https://qiniu.liupzmin.com/sidecar-proxy.png" alt="img"></p>
<p>Figure 3: Sidecar proxy approach</p>
<p>在这种方式下，客户端容器与 Envoy 边车连接，由边车负责维护和目标 service 的连接。</p>
<p>采用这种方式，我们终于得偿所愿：</p>
<ul>
<li>与Linkerd 1.x相比，Envoy的开销很小，延迟低。</li>
<li>对客户端代码没有侵入性</li>
<li>可观测性，因为 Envoy 暴露了兼容 Prometheus 格式的 metrics</li>
<li>丰富了网络层，支持认证和限流等特性</li>
</ul>
<h1 id="服务发现与优雅关闭"><a href="#服务发现与优雅关闭" class="headerlink" title="服务发现与优雅关闭"></a>服务发现与优雅关闭</h1><p>正确配置了负载均衡之后，我们仍然需要一种方法来让 Envoy 发现新的目标并更新其主机池。</p>
<p>Envoy 中的服务发现有几个选项，如 DNS、EDS（基于  <span class="exturl" data-url="aHR0cHM6Ly93d3cuZW52b3lwcm94eS5pby9kb2NzL2Vudm95L2xhdGVzdC9jb25maWd1cmF0aW9uL292ZXJ2aWV3L3hkc19hcGkjY29uZmlnLW92ZXJ2aWV3LW1hbmFnZW1lbnQtc2VydmVy">xDS<i class="fa fa-external-link-alt"></i></span> ）。因为简单和熟悉的缘故，我们选择了 DNS。</p>
<p>使用 DNS 作为服务发现机制有个潜在的复杂性，即<strong>传播需要一定的时间</strong>，因此，在一个正在终止的后端服务真正停止接受连接之前，我们需要为 gRPC 客户端留有更新主机列表的余地。因为有一个 TLL 时间与 DNS 记录相关联，也就是说 Envoy 会在这段时间内缓存主机列表，所以使用 DNS 时，优雅关闭流程需要一点技巧</p>
<p>下图展示了一个基本流程，它以一个失败的请求结束：</p>
<p><img data-src="https://qiniu.liupzmin.com/request-failed-dueto-dns-cache.png" alt="img"></p>
<p>Figure 4: Terminating host makes request fail due to DNS caching</p>
<p>在这个场景中，因为服务端 pod 不再可用，但 Envoy 缓存依然持有其 IP，所以第二次客户端请求以失败告终。</p>
<p>要解决这个问题，我们有必要看一下 Kubernetes 是如何销毁 pod 的，<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMvcG9kLyN0ZXJtaW5hdGlvbi1vZi1wb2Rz">这篇文章<i class="fa fa-external-link-alt"></i></span>对此有详细的论述。它包含两个同时进行的步骤：<strong>在 Kubernetes service endpoints 中移除 pod（在我们的案例中，同时也会移除 DNS 记录列表中该 pod 的 IP）</strong> 和 <strong>向容器发送 TERM 信号，启动优雅关闭</strong>。</p>
<p>有鉴于此，我们使用 Kubernetes 的 pre-stop 钩子来阻止 TERM 信号的立即发送：</p>
<p><img data-src="https://qiniu.liupzmin.com/pre-stop.png" alt="img"></p>
<p>Figure 5: preStop hook</p>
<p>配置好 preStop 钩子之后，我们的流程就变成下面这样：</p>
<p><img data-src="https://qiniu.liupzmin.com/successful-server-pod-shutdown-flow.png" alt="img"></p>
<p>Figure 6: successful server pod shutdown flow</p>
<p>通过这种解决方式，我们为 Envoy 的 DNS 缓存留出足够的时间，使其过期并且重新刷新，从而剔除已经死亡的 pod IP。</p>
<h1 id="未来改进"><a href="#未来改进" class="headerlink" title="未来改进"></a>未来改进</h1><p>尽管 Envoy 为我们带来了性能提升和整体的简洁，但是基于 DNS 的服务发现依旧不是很理想。因为它是基于轮询的，在 TTL 过期之后，由客户端负责刷新主机池，所以不够健壮。</p>
<p>一种更加稳健的方式是使用 Envoy 的 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZW52b3lwcm94eS5pby9kb2NzL2Vudm95L2xhdGVzdC9pbnRyby9hcmNoX292ZXJ2aWV3L3Vwc3RyZWFtL3NlcnZpY2VfZGlzY292ZXJ5I2FyY2gtb3ZlcnZpZXctc2VydmljZS1kaXNjb3ZlcnktdHlwZXMtZWRz">EDS<i class="fa fa-external-link-alt"></i></span>，它拓展了一些功能，诸如金丝雀发布和更加精密的负载均衡策略等，因此是一种更加灵活的方案，不过我们仍然需要一些时间来评估这种方案并在生产环境上进行验证。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2022/05/27/theory/schedule/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/27/theory/schedule/" class="post-title-link" itemprop="url">在 CPU 上起舞，聊一聊 Linux 调度和 Go 的 Runtime 调度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-27 15:01:51" itemprop="dateCreated datePublished" datetime="2022-05-27T15:01:51+08:00">2022-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>CPU是一个舞台，操作系统内核是位技艺精湛的指挥家，形形色色的进程就是舞者，它们在内核的指挥下轮番上台表演，演奏一场生命的赞歌！</p>
</blockquote>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>调度是件很神奇的事，一直以来我都对它无比着迷，并不断地钻营个中奥妙。几年下来，略有心得，于是思索着记录下来，以备将来优哉游哉忘乎所以后回来检索之用。</p>
<p>然而吸引我的并不是调度算法，而是调度的时机和原理。因此这篇文章只讨论调度时机和 Linux 内核的调度原理，与调度算法无涉，本文将调度算法当成一个黑盒，优先了解调度行为本身。</p>
<p>计算机操作系统进入多道程序后，需要支持多个程序并发运行，这就需要操作系统必须有能力管理多个程序的运行，必要的时候进行程序切换，使得多个程序轮流获得CPU的使用权。当操作系统需要协调多个程序运行时，就有必要做点什么来保证各个程序可以无冲突并发运行（并发和并行的区别，此处不予讨论）。我们不妨做个不严谨的类比，如果需要使用文字来描述每个任务，那么把所有的任务写在一个文档里显然不是明智之举，即便是计算机新手，也懂得为每个任务单独建一个文档分别管理；当任务变得复杂，发展出很多支线时，一个文档很快又会捉襟见肘，不利于管理了。此时，聪明的做法就是为这个任务创建一个文件夹，每个文件夹中有若干文档，这些文档描述了任务的主线和若干支线，如果有必要它们可以共享文件夹中的图片、音视频等多媒体。</p>
<p>我想你一眼就能看出来，上面的描述是在说进程和线程。不过我类比的重点并不是进、线程本身，而意在说明：<strong>要管理多个任务，就必然会采取某种结构来分门别类，分而治之！</strong>也就是说，操作系统内核会使用一个结构体来描述进程、线程及其相关的一切。那可以称这个结构体为进程或者线程吗？答案当然是否定的！谈调度自然绕不开进程和线程，因此我们要直面一个难题：你永远无法轻易地说清楚进程是什么！</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>《操作系统导论》将进程定义为：<strong>操作系统为正在运行的程序提供的抽象</strong>！认为进程只是一个正在运行的程序，并且声明机器状态（程序在运行时可以读取或更新的内容）为进程的一部分，机器状态包括内存和寄存器。</p>
<p>无独有偶，《深入理解计算机系统》对进程的定义是：<strong>进程是操作系统对一个正在运行的程序的一种抽象。</strong>这和《操作系统导论》中给出的定义如出一辙，但是它紧接着还给出了线程的定义：<strong>进程往往不只有单一的执行流，进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</strong></p>
<p>《深入理解Linux内核》补充说：<strong>可以把进程看作充分描述程序已经执行到何种程度的数据结构的汇集。</strong>这直接印证了我们之前的类比，从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的实体。这本书更偏爱于将进程描述成拥有多个相对独立的执行流，程序运行的本质就是CPU不断的执行一系列的指令序列，所以看起来就像是不断行进的流。</p>
<p>传统的Unix进程只拥有一个执行流，即便是现代主流语言的编程模式，如果你不采用多线程编程的话，进程也只有一个执行流，我们习惯称之为主线程；一旦使用了多线程的编程范式，进程就会拥有多个独立的执行流，Linux 内核就会为每个执行流分配单独的数据结构来管理资源的使用及其机器状态。实际上，Linux内核中的数据结构并不区分进程和线程，统一都使用<code>task_struct</code>这个结构体来描述一个执行流，程序的调度也是基于这个结构来进行的，而同属于一个进程的线程结构会共享某些资源，比如代码段、虚拟地址空间、打开的文件描述符、信号、堆等，只有堆栈是每个线程私有的。因此，当我们谈论进程时更多的是从资源的角度去思考，而谈到线程时，更多的是从执行流的角度去考虑。</p>
<p>综上，可以给出我心中对于进程的定义：<strong>进程是若干个活动的执行流以及各类相关资源的总称，这些资源包括了内核结构、地址空间（内存），寄存器等，其中进程的地址空间包括了多种类型的资源，代码段、数据段、堆、线程堆栈、文件映射等等；有些资源是线程共享的，比如堆、代码段，有些是线程私有的，比如堆栈。这些资源和若干独立执行流共同组成了进程这个抽象概念！</strong></p>
<p>我们即将要探讨的就是：<strong>内核是如何将一个执行流从 CPU 上换下，代之以另一个执行流的！</strong></p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><blockquote>
<p>这一章节中出现新进程和新建进程两个词语，未免混淆特此说明如下：</p>
<p>新进程：上下文切换时，被选中替换当前进程者</p>
<p>新建进程：使用fork、clone等创建的新进程或新线程</p>
</blockquote>
<p>需要明确的一件事情就是内核调度的粒度，你定然听过<strong>“线程是调度的基本单位”</strong>这样的说法，这种说法固然没有错，但具体每个操作系统的实现却多有不同。以 Linux 为例，其内核角度并不区分进程和线程，用于标识调度单位的结构一律都是<code>task_struct</code>，因此后续的行文不会刻意区分进程和线程。</p>
<p>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换、任务切换、上下文切换。这是从 CPU 的角度来看，如果站在内核的角度，那么这种行为就是在进行进程调度。</p>
<p>进行任务切换或者调度的根本原因在于 CPU 和寄存器是共享的，大家必须轮流使用！</p>
<p>有意思的是，执行任务切换的并不是一个进程或者内核线程，而是一个函数<code>schedule()</code>。内核中有很多精心定义的点来执行<code>schedule()</code>，我们先来观察<code>schedule()</code>如何执行进程切换，至于调度的时机稍后进行讨论。</p>
<p>进程切换只会也只应发生在内核态，这本身就是内核的职责，需要申明的一点是：<strong>执行流进入内核态后，用户态的硬件上下文已经保存在该进程对应的内核态堆栈上了，当该进程从内核态返回用户态时即可恢复原貌，从之前的终止处继续执行。</strong></p>
<p>进程切换由两步组成：</p>
<ol>
<li>切换进程地址空间</li>
<li>切换内核态堆栈和硬件上下文</li>
</ol>
<p><code>schedule</code> 会调用 <code>context_switch</code> 执行上下文切换，我们以 Linux 内核 <strong>5.10</strong> 版本为例，假设此时已经由调度算法挑选出了下一个即将运行的进程<code>next</code>，执行流进入<code>context_switch</code>的代码执行上下文切换：</p>
<p><strong>kernel&#x2F;sched&#x2F;core.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context_switch - switch to the new MM and the new thread&#x27;s register state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rq *</span><br><span class="line"><span class="title function_">context_switch</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev,</span></span><br><span class="line"><span class="params">	       <span class="keyword">struct</span> task_struct *next, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">	prepare_task_switch(rq, prev, next);</span><br><span class="line">	arch_start_context_switch(prev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!next-&gt;mm) &#123;                                <span class="comment">// to kernel</span></span><br><span class="line">		enter_lazy_tlb(prev-&gt;active_mm, next);</span><br><span class="line"></span><br><span class="line">		next-&gt;active_mm = prev-&gt;active_mm;</span><br><span class="line">		<span class="keyword">if</span> (prev-&gt;mm)                           <span class="comment">// from user</span></span><br><span class="line">			mmgrab(prev-&gt;active_mm);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;                                        <span class="comment">// to user</span></span><br><span class="line">		membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);</span><br><span class="line">		switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!prev-&gt;mm) &#123;                        <span class="comment">// from kernel</span></span><br><span class="line">			<span class="comment">/* will mmdrop() in finish_task_switch(). */</span></span><br><span class="line">			rq-&gt;prev_mm = prev-&gt;active_mm;</span><br><span class="line">			prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line"></span><br><span class="line">	prepare_lock_switch(rq, next, rf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Here we just switch the register state and the stack. */</span></span><br><span class="line">	switch_to(prev, next, prev);</span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context_switch</code>的前半部分完成进程地址空间切换，<code>switch_to</code> 完成硬件上下文切换，此处主要关注<code>switch_to</code>如何完成上下文切换，毕竟我们只对执行流的变更感兴趣。</p>
<p><code>switch_to</code> 是个预定义的宏，因其是和硬件体系结构密切相关的，所以主要部分需用汇编语言实现，我们看一下它的内容：</p>
<p><strong>arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;switch_to.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)					\</span></span><br><span class="line"><span class="meta">do &#123;									\</span></span><br><span class="line"><span class="meta">	((last) = __switch_to_asm((prev), (next)));			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><code>__switch_to_asm</code> 即是由汇编实现的程序主体：</p>
<p><strong>arch&#x2F;x86&#x2F;entry&#x2F;entry_64.S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * %rdi: prev task</span><br><span class="line"> * %rsi: next task</span><br><span class="line"> */</span><br><span class="line">.pushsection .text, &quot;ax&quot;</span><br><span class="line">SYM_FUNC_START(__switch_to_asm)</span><br><span class="line">	/*</span><br><span class="line">	 * Save callee-saved registers</span><br><span class="line">	 * This must match the order in inactive_task_frame</span><br><span class="line">	 */</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	pushq	%r12</span><br><span class="line">	pushq	%r13</span><br><span class="line">	pushq	%r14</span><br><span class="line">	pushq	%r15</span><br><span class="line"></span><br><span class="line">	/* switch stack */</span><br><span class="line">	movq	%rsp, TASK_threadsp(%rdi)</span><br><span class="line">	movq	TASK_threadsp(%rsi), %rsp</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_STACKPROTECTOR</span><br><span class="line">	movq	TASK_stack_canary(%rsi), %rbx</span><br><span class="line">	movq	%rbx, PER_CPU_VAR(fixed_percpu_data) + stack_canary_offset</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_RETPOLINE</span><br><span class="line">	/*</span><br><span class="line">	 * When switching from a shallower to a deeper call stack</span><br><span class="line">	 * the RSB may either underflow or use entries populated</span><br><span class="line">	 * with userspace addresses. On CPUs where those concerns</span><br><span class="line">	 * exist, overwrite the RSB with entries which capture</span><br><span class="line">	 * speculative execution to prevent attack.</span><br><span class="line">	 */</span><br><span class="line">	FILL_RETURN_BUFFER %r12, RSB_CLEAR_LOOPS, X86_FEATURE_RSB_CTXSW</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* restore callee-saved registers */</span><br><span class="line">	popq	%r15</span><br><span class="line">	popq	%r14</span><br><span class="line">	popq	%r13</span><br><span class="line">	popq	%r12</span><br><span class="line">	popq	%rbx</span><br><span class="line">	popq	%rbp</span><br><span class="line"></span><br><span class="line">	jmp	__switch_to</span><br><span class="line">SYM_FUNC_END(__switch_to_asm)</span><br></pre></td></tr></table></figure>

<p>首先遵循被调用者原则保存6个寄存器的值，保存的方式就是压入即将被替换进程<code>prev</code>的内核栈，直到此时执行流依然使用<code>prev</code>的内核栈，不过接下来就开始切换内核栈了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* switch stack */</span><br><span class="line">movq	%rsp, TASK_threadsp(%rdi)</span><br><span class="line">movq	TASK_threadsp(%rsi), %rsp</span><br></pre></td></tr></table></figure>

<p>依照内核函数的调用惯例，<code>%rdi</code>和<code>%rsi</code>两个寄存器分别存放调用时传入的第一和第二个参数：<code>__switch_to_asm((prev), (next)))</code>。</p>
<p><code>movq	%rsp, TASK_threadsp(%rdi)</code> 的结果是将当前内核栈的栈顶指针寄存器内容保存至<code>prev</code>进程（也就是当前进程）的<code>thread-&gt;sp</code>中，<code>thread</code> 是进程描述符<code>task_struct</code> 中一个类型为<code>thread_struct</code>的字段，里面会保存大部分 CPU 寄存器（但不包括 rax、rbx 等通用寄存器，它们的值保存至内核堆栈中）。而<code>movq	TASK_threadsp(%rsi), %rsp</code>这一句将被选中进程<code>next</code>中之前被保存的栈顶指针恢复至<code>rsp</code>寄存器，执行完这一条之后执行流的内核堆栈就切换到新进程了。</p>
<p>严格来讲，从上面一条指令之后就是新进程的执行流了，可以说<strong>改变内核堆栈就意味着改变当前进程。</strong>这归因于和内核堆栈一起存放的一个名为<code>thread_info</code>的结构，内核都是通过它来寻找当前进程的描述符（参考《深入理解Linux内核》88页-<strong>标识一个进程</strong>）。</p>
<p>接下来，从新进程的内核堆栈中弹出之前保存的6个寄存器的值，然后 <code>jmp</code> 到 <code>__switch_to</code> 函数，<code>__switch_to</code> 函数依然做一些保存老进程上下文和加载新进程上下文的工作，此处不再深入展开，我们仅将注意力集中到<code>jmp</code>这条指令上。</p>
<p>如果你熟悉 <strong>2.6</strong> 版本的内核，读过《深入理解Linux内核》，你就会奇怪：为何此处切换了新进程的<code>rsp</code>，却没有<code>rip</code>的切换呢？2.6 版本是会将新进程 thread 字段中的<code>ip</code>推入内核堆栈作为返回地址（该指令地址就位于<code>switch_to</code>中），这样在 <code>__switch_to</code> 中<code>ret</code>时就会跳转到<code>thread-&gt;ip</code>指向的代码指令了，这也是为什么用<code>jmp</code> 不用 <code>call</code>的原因（<code>call</code> 会将<code>ip</code> 压栈，而<code>jmp</code>只是简单的跳转，不会压栈）。当我读到此处时，禁不住废书而叹，惊讶其设计的巧妙，但同时也生出疑问：既然新进程保存的地址就在附近，为何非要到<code>thread-&gt;ip</code>中绕一圈呢？直接把该地址推入内核堆栈效果不也一样吗？可能是内核的设计者也意识到这一点，在 2.6 版本 64 位内核直到最新的<code>5.x</code>版本就放弃了这种做法，不再去刻意的保存和恢复进程的<code>rip</code> 了，因为新进程的起点总是在<code>switch_to</code>函数中。</p>
<p>所以，此处在<code>__switch_to</code> 返回时会跳到开始的<code>switch_to</code>处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)					\</span></span><br><span class="line"><span class="meta">do &#123;									\</span></span><br><span class="line"><span class="meta">	((last) = __switch_to_asm((prev), (next)));			\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>栈帧一层层解开，会返回到 <code>context_switch</code> 函数调用，继而回到<code>schedule()</code>。可见，任何一个进入内核态调用<code>schedule()</code>执行任务切换的进程，最终都会等到<code>schedule()</code>调用的返回。我们稍后会讲到 <code>Go</code> 运行时的协程调度，其<code>schedule</code>函数是不会返回的，所以它看起来并不像一个函数，这是区别于操作系统调度函数一个重要的点。</p>
<p>分析到此处，我们可能会以手舞之，以足蹈之，感觉终于在指令级别“看到”进程切换的本质了！不过还没到欢欣鼓舞的时候，我们似乎忘掉了一种情形：如果被选中的新进程是新创建的，从来没有被运行过，该又如何呢？<code>__switch_to</code>中<code>ret</code>时执行流又将流向何方呢？毕竟新进程是没有执行过<code>schedule()</code>的。</p>
<p>依然是内核堆栈救了我们！</p>
<p>要意识到的一点是：新建进程的内核堆栈并不是空的，它 copy 自父进程并经过精心的构造。</p>
<p>以 <code>clone</code>系统调用为例，<code>copy_thread</code>用发出<code>clone()</code>系统调用时的CPU寄存器的值（此时都在父进程的内核堆栈中）来初始化子进程或者线程的内核堆栈。不过<code>copy_thread</code>会把<code>rax</code>寄存器对应字段的值（这是fork和clone系统调用在子进程或线程中的返回值）强行置为0，这就是为何我们使用fork时要通过返回值来判断此时执行的是子进程还是父进程。既然说到这里，就聊一下clone系统调用的封装接口吧！线程创建的接口是由标准库 glibc 中的包装函数实现的，它处理了返回值的问题，如果是主线程则返回到调用处，如果是新建线程则跳转到任务函数调用处，这是 glibc 封装函数通过推入新线程的堆栈实现的。我们可以观察一下glibc 的 clone 封装代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/* The userland implementation is:</span><br><span class="line">   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),</span><br><span class="line">   the kernel entry is:</span><br><span class="line">   int clone (long flags, void *child_stack).</span><br><span class="line">   The parameters are passed in register and on the stack from userland:</span><br><span class="line">   rdi: fn</span><br><span class="line">   rsi: child_stack</span><br><span class="line">   rdx:	flags</span><br><span class="line">   rcx: arg</span><br><span class="line">   r8d:	TID field in parent</span><br><span class="line">   r9d: thread pointer</span><br><span class="line">%esp+8:	TID field in child</span><br><span class="line">   The kernel expects:</span><br><span class="line">   rax: system call number</span><br><span class="line">   rdi: flags</span><br><span class="line">   rsi: child_stack</span><br><span class="line">   rdx: TID field in parent</span><br><span class="line">   r10: TID field in child</span><br><span class="line">   r8:	thread pointer  */</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">ENTRY (__clone)</span><br><span class="line">	/* Sanity check arguments.  */</span><br><span class="line">	movq	$-EINVAL,%rax</span><br><span class="line">	testq	%rdi,%rdi		/* no NULL function pointers */</span><br><span class="line">	jz	SYSCALL_ERROR_LABEL</span><br><span class="line">	testq	%rsi,%rsi		/* no NULL stack pointers */</span><br><span class="line">	jz	SYSCALL_ERROR_LABEL</span><br><span class="line"></span><br><span class="line">	/* Insert the argument onto the new stack.  */</span><br><span class="line">	subq	$16,%rsi</span><br><span class="line">	movq	%rcx,8(%rsi)</span><br><span class="line"></span><br><span class="line">	/* Save the function pointer.  It will be popped off in the</span><br><span class="line">	   child in the ebx frobbing below.  </span><br><span class="line">	   这里把线程要运行的函数fn压入新建线程的用户态堆栈中*/</span><br><span class="line">	movq	%rdi,0(%rsi)</span><br><span class="line"></span><br><span class="line">	/* Do the system call.  */</span><br><span class="line">	movq	%rdx, %rdi</span><br><span class="line">	movq	%r8, %rdx</span><br><span class="line">	movq	%r9, %r8</span><br><span class="line">	mov	8(%rsp), %R10_LP</span><br><span class="line">	movl	$SYS_ify(clone),%eax</span><br><span class="line"></span><br><span class="line">	/* End FDE now, because in the child the unwind info will be</span><br><span class="line">	   wrong.  */</span><br><span class="line">	cfi_endproc;</span><br><span class="line">	syscall</span><br><span class="line"></span><br><span class="line">	/* 比较返回值 */</span><br><span class="line">	testq	%rax,%rax</span><br><span class="line">	jl	SYSCALL_ERROR_LABEL</span><br><span class="line">	/* 等于零则跳转到 L，否则直接返回 */</span><br><span class="line">	jz	L(thread_start)</span><br><span class="line"></span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">L(thread_start):</span><br><span class="line">	cfi_startproc;</span><br><span class="line">	/* Clearing frame pointer is insufficient, use CFI.  */</span><br><span class="line">	cfi_undefined (rip);</span><br><span class="line">	/* Clear the frame pointer.  The ABI suggests this be done, to mark</span><br><span class="line">	   the outermost frame obviously.  */</span><br><span class="line">	xorl	%ebp, %ebp</span><br><span class="line"></span><br><span class="line">	/* Set up arguments for the function call.  */</span><br><span class="line">	popq	%rax		/* Function to call. 弹出函数地址 */</span><br><span class="line">	popq	%rdi		/* Argument.  */</span><br><span class="line">	call	*%rax       /* 开始调用执行 */</span><br><span class="line">	/* Call exit with return value from function call. */</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	movl	$SYS_ify(exit), %eax</span><br><span class="line">	syscall</span><br><span class="line">	cfi_endproc;</span><br></pre></td></tr></table></figure>

<p> 开头的注释部分很好地揭示了用户态代码和内核态代码对于传参的不同要求，即寄存器的使用规则。关键点是<code>movq	%rdi,0(%rsi)</code>这一句，它将线程要执行的<code>fn</code>地址推入了新进程的堆栈，并在<code>L(thread_start):</code>部分通过下面三条指令启动新线程执行流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq	%rax		/* Function to call. 弹出函数地址 */</span><br><span class="line">popq	%rdi		/* Argument.  */</span><br><span class="line">call	*%rax       /* 开始调用执行 */</span><br></pre></td></tr></table></figure>

<p>Go 并不使用标准的 C 库，其 runtime 重写了所有的系统调用封装函数，从 Go 的 clone 实现来看，也是相似的逻辑。不过，Go 使用 plan9 汇编，在阅读上会有一些不便：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));</span><br><span class="line">TEXT runtime·clone(SB),NOSPLIT,$0</span><br><span class="line">	MOVL	flags+0(FP), DI</span><br><span class="line">	MOVQ	stk+8(FP), SI</span><br><span class="line">	MOVQ	$0, DX</span><br><span class="line">	MOVQ	$0, R10</span><br><span class="line">	MOVQ    $0, R8</span><br><span class="line">	// Copy mp, gp, fn off parent stack for use by child.</span><br><span class="line">	// Careful: Linux system call clobbers CX and R11.</span><br><span class="line">	MOVQ	mp+16(FP), R13</span><br><span class="line">	MOVQ	gp+24(FP), R9</span><br><span class="line">	MOVQ	fn+32(FP), R12 // fn 被放入R12寄存器</span><br><span class="line">	CMPQ	R13, $0    // m</span><br><span class="line">	JEQ	nog1</span><br><span class="line">	CMPQ	R9, $0    // g</span><br><span class="line">	JEQ	nog1</span><br><span class="line">	LEAQ	m_tls(R13), R8</span><br><span class="line">#ifdef GOOS_android</span><br><span class="line">	// Android stores the TLS offset in runtime·tls_g.</span><br><span class="line">	SUBQ	runtime·tls_g(SB), R8</span><br><span class="line">#else</span><br><span class="line">	ADDQ	$8, R8	// ELF wants to use -8(FS)</span><br><span class="line">#endif</span><br><span class="line">	ORQ 	$0x00080000, DI //add flag CLONE_SETTLS(0x00080000) to call clone</span><br><span class="line">nog1:</span><br><span class="line">	MOVL	$SYS_clone, AX  // 放入系统调用号，准备进入系统调用</span><br><span class="line">	SYSCALL</span><br><span class="line">	// 系统调用返回</span><br><span class="line">	// In parent, return. 父进程则返回</span><br><span class="line">	CMPQ	AX, $0</span><br><span class="line">	JEQ	3(PC) // 若返回值为0，则跳跃3条指令</span><br><span class="line">	MOVL	AX, ret+40(FP)</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">	// In child, on new stack.</span><br><span class="line">	// 如果是子进程则切换堆栈</span><br><span class="line">	MOVQ	SI, SP</span><br><span class="line"></span><br><span class="line">	// If g or m are nil, skip Go-related setup.</span><br><span class="line">	CMPQ	R13, $0    // m</span><br><span class="line">	JEQ	nog2</span><br><span class="line">	CMPQ	R9, $0    // g</span><br><span class="line">	JEQ	nog2</span><br><span class="line"></span><br><span class="line">	// Initialize m-&gt;procid to Linux tid</span><br><span class="line">	MOVL	$SYS_gettid, AX</span><br><span class="line">	SYSCALL</span><br><span class="line">	MOVQ	AX, m_procid(R13)</span><br><span class="line"></span><br><span class="line">	// In child, set up new stack</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	R13, g_m(R9)</span><br><span class="line">	MOVQ	R9, g(CX)</span><br><span class="line">	MOVQ	R9, R14 // set g register</span><br><span class="line">	CALL	runtime·stackcheck(SB)</span><br><span class="line"></span><br><span class="line">nog2:</span><br><span class="line">	// Call fn. This is the PC of an ABI0 function.</span><br><span class="line">	// 调用 fn</span><br><span class="line">	CALL	R12</span><br><span class="line"></span><br><span class="line">	// It shouldn&#x27;t return. If it does, exit that thread.</span><br><span class="line">	MOVL	$111, DI</span><br><span class="line">	MOVL	$SYS_exit, AX</span><br><span class="line">	SYSCALL</span><br><span class="line">	JMP	-3(PC)	// keep exiting</span><br></pre></td></tr></table></figure>

<p>回到操作系统内核新建进程的话题上来，前面讲过，在内核 3.0 到最新的 5.x 版本不再去刻意的保存和恢复进程的<code>rip</code> 了，因为新进程（被选中的进程）的起点总是在<code>switch_to</code>函数中。那么在新建进程初次运行的问题上，新旧版本虽然看上去不同，但殊途同归，最终都会把执行流引向<code>ret_from_fork()</code>，我们先看看 2.6 版本 32 位内核的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define switch_to(prev,next,last) do &#123;					\</span><br><span class="line">	unsigned long esi,edi;						\</span><br><span class="line">	asm volatile(&quot;pushfl\n\t&quot;		/* Save flags */	\</span><br><span class="line">		     &quot;pushl %%ebp\n\t&quot;					\</span><br><span class="line">		     &quot;movl %%esp,%0\n\t&quot;	/* save ESP */		\</span><br><span class="line">		     &quot;movl %5,%%esp\n\t&quot;	/* restore ESP */	\</span><br><span class="line">		     &quot;movl $1f,%1\n\t&quot;		/* save EIP */		\</span><br><span class="line">		     &quot;pushl %6\n\t&quot;		/* restore EIP */	\</span><br><span class="line">		     &quot;jmp __switch_to\n&quot;				\</span><br><span class="line">		     &quot;1:\t&quot;						\</span><br><span class="line">		     &quot;popl %%ebp\n\t&quot;					\</span><br><span class="line">		     &quot;popfl&quot;						\</span><br><span class="line">		     :&quot;=m&quot; (prev-&gt;thread.esp),&quot;=m&quot; (prev-&gt;thread.eip),	\</span><br><span class="line">		      &quot;=a&quot; (last),&quot;=S&quot; (esi),&quot;=D&quot; (edi)			\</span><br><span class="line">		     :&quot;m&quot; (next-&gt;thread.esp),&quot;m&quot; (next-&gt;thread.eip),	\</span><br><span class="line">		      &quot;2&quot; (prev), &quot;d&quot; (next));				\</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure>

<p>从注释可以看出，在切换了内核堆栈之后，开始保存旧进程的<code>EIP</code>恢复新进程的<code>EIP</code>，恢复新进程的<code>EIP</code>是通过<code>pushl %6</code>来完成的，这句话的意思是将<code>next-&gt;thread.eip</code>的值压入内核堆栈，以便后面的C函数<code>__switch_to</code>返回时跳转。这是比较巧妙的一个地方，对于一个曾经被调度过的进程，其<code>thread.eip</code>中保存的就是<code>1:</code>标号处的指令，这是通过<code>movl $1f,%1</code>指令实现的（此处即上文提到的跳转地址本身就位于<code>switch_to</code>函数中）。问题是对于一个未曾运行过的新进程来说，是没有执行过<code>switch_to</code>代码的，所以此处<code>pushl %6</code>入栈的并不是标号<code>1:</code>处的代码，而是在创建进程时设置的<code>ret_from_fork()</code>，当<code>__switch_to</code>执行到<code>ret</code> 时，从内核堆栈弹出要跳转的地址，这个地址就是<code>ret_from_fork()</code>，新建进程的旅程便由此开始！</p>
<p>64 位的 2.6 内核版本稍微有些区别，但结果都是一样的，这里不再赘述，感兴趣的可以参考<span class="exturl" data-url="aHR0cDovL3d3dy5tYWl6dXJlLm9yZy9wcm9qZWN0cy9ldm9sdXRpb25feDg2X2NvbnRleHRfc3dpdGNoX2xpbnV4Lw==">Evolution of the x86 context switch in Linux<i class="fa fa-external-link-alt"></i></span> 这篇文章，其详细描述了从内核1.0版本到4.14版本上下文切换部分的设计变更。</p>
<p>回到我们开始讨论的 5.10 版本的<code>__switch_to_asm</code>，当被选中的新进程是一个新建进程时，<code>jmp	__switch_to</code>返回后会跳转到哪里呢？答案当然是<code>ret_from_fork()</code>，新进程没有调用过<code>schedule()</code>，故不会回到其调用栈，此时只需搞清楚新进程的内核栈内容就能明白执行流的走向了，新建进程时执行完<code>copy_thread()</code>之后，进程的内核堆栈示意图如下：</p>
<p><img data-src="https://qiniu.liupzmin.com/stack_layout_fork.png" alt="图 3-1 新进程的内核堆栈"></p>
<p>​	如图 3-1 所示，弹出6个寄存器之后，就只剩<code>ret_from_fork()</code>的地址了。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>虽然<code>ret_from_fork()</code>是新建进程的开始，但在真正返回到用户空间之前仍然横着一道关卡，那就是检查是否需要进行再调度。这是有可能的，如果有一个优先级更高的进程需要运行，那么时钟中断处理程序兴许已经在<code>thread_info</code>中做好了标记，等待着<code>schedule()</code>被调用。在真正回到用户空间之前，<code>ret_from_fork()</code>会检查这些标记，如果有必要，就调用<code>schedule()</code>。所以，我们就可以发问了，<code>schedule()</code>返回之后，执行流会去向哪里？</p>
<p>于<code>ret_from_fork()</code>而言很简单，如果它真的调用了<code>schedule()</code>，当调度函数返回时，进程会以一个“老程序”的身份初次进入用户空间。因此问题的本质是何时会调用<code>schedule()</code>，换句话说，内核的调度时机有哪些？</p>
<p>Linux 调度时机主要有：</p>
<ol>
<li>进程状态转换时刻：进程终止、进程睡眠；</li>
<li>当前进程的时间片用完；</li>
<li>进程主动调用</li>
<li>进程从中断、异常及系统调用返回到用户态时。</li>
</ol>
<p>时机1，进程要调用sleep()或exit()等函数进行状态转换时，这些系统调用会主动调用调度函数进行进程调度。</p>
<p>时机2，由于进程的时间片是由时钟中断来更新的，因此，这种情况和时机4是密不可分的。</p>
<p>时机3，当进程某些资源无法获取，或者设备驱动程序执行长而重复的任务时，进程主动调用调度函数主动放弃CPU，比如锁、缺页等场景。</p>
<p>时机4，调度的绝大多数占比应属于此种情况，CPU 会在每次执行完一条指令之后检查是否有中断产生，如有则进入中断处理程序。当从中断、异常及系统调用返回到用户态时都会检查调度标志，如果检测为真则进入调度函数。</p>
<p>《操作系统导论》中说道：一旦时钟开始运行，操作系统就感到安全了，因为控制权最终会还给它，因此操作系统可以自由运行用户程序。</p>
<p>可见，在中断返回之前进行调度是一个绝妙的方法。因此，我们可以说：<code>schedule()</code>返回之后的去向并不唯一，有可能是中断、异常和系统调用返回用户空间之前，也有可能是在系统调用进行之中。这也是为何进程切换只会发生在内核态。</p>
<p>我用一幅图来描绘一下，进程的执行流在用户态和内核态之间变换以及进程切换的场景，让我们以指令的视角在进程的用户态和内核态之间，在进程与进程之间进行一场穿梭之旅。</p>
<p><img data-src="https://qiniu.liupzmin.com/exec-stream.png" alt="图 4-1 进程执行流"></p>
<p>图 4-1 描述了3个进程在两颗CPU上的执行情况，注意这并不是以进程的视角来展现的，<strong>各种颜色的执行流仅表示进程处于用户态，灰色的执行流代表内核态</strong>，不同的是内核态的前半部分代表当前进程，后半部分则是经过进程切换后代表下一个进程。图中进程B切换为进程A，当执行流进入内核态执行切换时，切换之前内核代表进程B执行，切换之后内核代表新进程A执行。</p>
<blockquote>
<p>图 4-1 仅仅展示了进程切换的场景，并不是指进程的执行流进入内核态后一定会发生进程切换</p>
</blockquote>
<p>要理解“代表”的含义，就需要解释一下<code>thread_info</code>这个数据结构，我们前面曾提到过它，但未加以详述，此处有必要略作说明。</p>
<p><code>thread_info</code>被称为线程描述符（不应纠结于概念，把线程理解为一个执行流即可），这个结构包含了指向进程描述符<code>task_struct</code>的指针，因此，内核若想确定当前运行的进程，只需要找到<code>thread_info</code>即可。但问题是如何确定其位置呢？内核的处理方法依然非常巧妙——将<code>thread_info</code>和进程内核堆栈一起存放！放一幅图即可一目了然：</p>
<p><img data-src="https://qiniu.liupzmin.com/thread_info.png" alt="图 4-2 thread_info 结构和内核堆栈存放在两个连续的页框中"></p>
<p>图 4-2 所示，这是一块 8k 大小的内存，内核堆栈由高地址向低地址增长，thread_info 存放在最底部，其大小通常是 52 字节，因此，内核堆栈能扩展到8140字节。这个大小看上去很小，至少远远小于进程的用户态堆栈的默认大小（Linux 上用户态堆栈的大小为8M）。这是因为内核控制路径用到的堆栈很少，只需几千字节足矣！</p>
<p>《深入理解Linux内核》说道，<em><strong>从效率的观点来看，<code>thread_info</code>结构与内核态堆栈之间的紧密结合提供的主要好处是：内核很容易从<code>esp</code>寄存器（栈顶指针寄存器）的值获得当前在CPU上正在运行进程的<code>thread_info</code>结构的地址。</strong></em>假设<code>thread_info</code>和内核堆栈的结合体大小就是 8K，那么内核屏蔽掉 esp 的低 13 位有效位就可以获得<code>thread_info</code>结构的基地址。由此可知：<strong>切换了内核堆栈就等于切换了当前进程。</strong></p>
<p>还可以从资源使用统计上来理解“代表”的含义。<strong>当进程进入内核态时，其对CPU的时间的消耗则记录在进程的sys、hiq、siq 等指标上，由此可以想见一个内核的流氓特征：与我无关的中断处理对于CPU的消耗都算在了我的头上！</strong></p>
<p>之所以强调“代表”，是为了说明进程是相对执行流而言的，而不是相对程序而言。这里的程序指的是躺在硬盘上的二进制数据，或者说用户态的指令集，其实用户态的指令集囊括了磁盘上的二进制数据。换句话说，如果程序是完全静态链接的，程序的二进制就完全包括了用户态指令集，反之，用户态指令集是大于二进制数据中的指令集的，这是由动态链接决定的。</p>
<p>我曾在论坛上与人争论过一个问题：向 redis 发出一个删除大量key的命令，redis 的主线程是否可以说被阻塞了？</p>
<p>很多人的观点是主线程要释放内存会进入系统调用，因释放内存耗时较长故主线程被阻塞。而我的观点是：在删除大量key时，redis 主线程并没有阻塞，阻塞的是发出指令的客户端以及排队发送指令的其它客户端！经过上面的论证，我们知道内核态的执行流一部分代表当前进程，一部分代表切换后的新进程，所以，在被调度之前，不管是用户态还是内核态，都表示这个进程仍在CPU上运行。不能说 redis 线程发起系统调用后陷入了内核，这个线程就被阻塞了，这是不正确的。此时CPU上的执行流依然属于 redis 主线程，其对资源的消耗仍会被记录在该线程名下。redis 主线程一直在努力干活，没有被阻塞，只是这个线程进入到内核态后干的时间比较长，阻塞了发出指令的客户端，同样也阻塞了后续发指令的客户端，而这是由 redis 处理网络请求是单线程模型决定的！</p>
<p>线程是操作系统为用户提供的最轻便的并发模型，它的轻便来自于和进程的对比，二者在资源的使用上不可同日而语。即便如此，线程的资源占用仍然相当可观。从资源的有限性出发，不可能为了并发而创建任意数量的线程。除去堆栈资源累加产生的内存占用之外，过多的线程数量也会加重内核调度的负担，这种负担体现在过多指令浪费在进程切换上，而没有为真正的程序逻辑所用。</p>
<p>对高并发的执着追求，诞生了编程语言世界里五花八门的协程，或者说用户态线程，概念并不重要，重要的是，它们只能在用户态做文章。像Python、Java、C++、Go、Rust 等语言都提供了基于协程的并发模型，这里面由于 Go 是相对比较新生的语言，没有任何历史包袱，从而提供了完美的用户态线程，且将此并发模型内置于语言自身。这样做的好处是，开发并发程序变得异常简单，一个简简单单的<code>go</code>关键字就可以创建一个独立的任务，即<strong>一个独立的执行流</strong>，如果换做其它语言，想要创建一个独立的执行流只有线程或者进程这种由操作系统提供的原生方式（当然，很多语言也有对应的协程库，因本人未做过详细研究，故只考虑原生的并发模型）；然而，为了并发体系的自洽，Go 为其用户屏蔽了操作系统提供的线程模型，虽然用起来简单了，但理解上却多了些许障碍。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>《操作系统概念》4.3节简单讨论了<strong>线程模型</strong>，书中说有两种不同的方法来提供线程支持，<strong>用户层的用户线程</strong>和<strong>内核层的内核线程</strong>，大致有如下三种模型</p>
<ol>
<li><p>多对一模型</p>
<p><img data-src="https://qiniu.liupzmin.com/many-to-one.png" alt="图 5-1 多对一模型"></p>
<p>这种模型将用户态的多个线程映射到一个内核线程上，这种方式最大缺点就是任何一个用户线程发生阻塞调用时，整个内核线程就会被调离 CPU ，致使其它的用户线程失去执行机会。</p>
</li>
<li><p>一对一模型</p>
<p><img data-src="https://qiniu.liupzmin.com/one-to-one.png" alt="图 5-2 一对一模型"></p>
<p>一对一模型将每个用户线程映射到一个内核线程，如果一个线程阻塞在系统调用上时，剩余的仍然可以运行。这种模型唯一的缺点是创建一个用户线程就需要创建对应的内核线程，可以想见的是，创建内核线程的时间开销和资源开销是相当可观的，换句话说，成本决定了能开启线程的数量。Liunx和windows都实现了一对一的模型。</p>
</li>
<li><p>多对多模型</p>
<p><img data-src="https://qiniu.liupzmin.com/many-to-many.png" alt="图 5-3 多对多模型"></p>
<p>对多对模型多路复用多个用户级线程到多个内核级线程，通常来说用户线程要比内核线程多的多，这种模型没有上述两种模型的缺点，当一个用户线程发出导致内核线程阻塞的系统调用时，其余的用户线程依然可以被其它内核线程调度。同时，因为用户线程无比轻量，时间和资源成本较少，因此可以开启任意数量的用户线程用于并发，当然量变会引起质变，数量过于庞大的用户线程也会加重资源的消耗，因此会出现了各种各样的协程池用于刹车。Go 语言的并发模型就实现了这种 <strong>M:N</strong> 的并发模型，稍后我们会讲到，现在先让我来批判一下《操作系统概念》中的概念模糊问题。</p>
</li>
</ol>
<p>不知道你是否被上面的<strong>用户线程</strong>、<strong>内核线程</strong>、<strong>映射</strong>等概念搅的一头雾水呢？按照其语义，用户线程和内核线程就像是对立的两方，会有某个东西将它们联系起来构成<strong>“映射”</strong>，或许是内核，又或许是C库，但书中没讲，我能够理解《操作系统概念》是讲操作系统的设计与实现原理，会兼顾大部分操作系统，讲解的也是较为抽象的部分，不过现代绝大部分人只接触过Linux，而Linux内核提供的并发模型就只有一对一这一种，所里书里的内容如今看上去多少有些不合时宜。在 Linux 内核当中甚至并不区分进程和线程，它们统一都由<code>task_struct</code>这一种数据结构表示，并且基于其进行调度，也就是说，在内核看来每个<code>task_struct</code>只有一个执行流，至于在用户态这个大的执行流干些什么，内核并不关心。</p>
<p>要正确理解书中所表达的意图，就需要先把概念捋清楚，我以 Linux 为例来进行说明。</p>
<p>首先，需要把这里的<strong>内核线程</strong>拿掉，换成<strong>操作系统线程</strong>，即 Linux 内核提供的线程。我之所以不用内核线程是因为内核线程这个概念在 Linux 中也有对应的存在（参见《深入linux内核架构》2.4.2 内核线程），内核线程是一种只运行在内核地址空间的线程。所有的内核线程共享内核地址空间（对于 32 位系统来说，就是 3-4GB 的虚拟地址空间），所以也共享同一份内核页表，并且没有用户地址空间，这也是为什么叫内核线程，而不叫内核进程的原因。</p>
<p>其次，将用户线程换成协程来表达，这里之所以用协程，完全是因为操作系统线程实在是太耀眼，太深入人心了，以至于人们都忘记了它原本抽象的含义，当需要表达在用户态实现的这个实体时，就有了“用户线程”、“协程”、“go程”等五花八门的名字，特别是“用户线程”，听起来让人如堕五里雾中。</p>
<p>前面讲过，进程是一堆资源和若干执行流的总称，Linux 中的<code>task_struct</code>记录了分配的资源和执行流的状态，是一个勉强能够被称之为进程或者线程的实体，协程也有记录资源和执行流状态的对应实体，从这些“实体”的意义上讲，也可以称协程和操作系统线程之间存在对应关系。现在让我们重新理解一下<strong>“对多对模型多路复用多个用户级线程到多个内核级线程”</strong>这句话，可以换一种表达：<strong>对多对模型指的是在多个Linux操作系统线程之内运行多个协程</strong>。我这里使用了<strong>“之内”</strong>而不是<strong>“之上”</strong>，是想着重表达操作系统进&#x2F;线程是一个罐罐儿，用户态的所有花样都是在罐罐儿里玩，并没有超出操作系统进&#x2F;线程的活动范围。一言以蔽之，<strong>用户态程序永远无法逃脱进程地址空间和执行流的手掌心！</strong></p>
<p>或许，我们可以换个角度，抛开这些定义，站在 CPU 的角度去理解问题。所谓线程就是内核维护的一个数据结构，内核依靠这个结构来控制 CPU 上运行的代码，指令无论在用户态还是内核态，都是这个线程，所有的资源消耗都计入此线程，即便是与此线程无关的中断所消耗的资源也被记在该线程名下。协程就是用户空间代码维护的一个数据结构，用户空间代码可以通过控制 ip、sp 等寄存器来控制用户空间执行流的走向，就可以实现在不同的协程间切换，并把执行流的状态记录在对应的数据结构上，重要的是协程代码本身就属于操作系统用户态执行流中的指令。</p>
<p>协程和操作系统线程 M:N 的这种模型，现实中实现并不多，Go 绝对是最耀眼的那一颗！</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>go runtime 中也有和操作系统内核类似的<code>schedule()</code>，它会在最终调用用汇编代码写成的<code>runtime·gogo(buf *gobuf)</code>，正如<a href="https://liupzmin.com/2022/04/26/theory/stack-insight-03/">《溯源 goroutine 堆栈》</a> 中提到的，它会将新的 goroutine 恢复执行，最后的指令<code>JMP	BX</code>意味着<code>schedule()</code>函数不会返回，<code>schedule()</code>总是会在合适的点被调用，直到选择出可以运行的 goroutine。如果一个 goroutine 自然终止，执行流也会回到事先埋好的点<code>runtime·goexit</code>，而 goexit 最终会调用schedule()。在通往<code>schedule()</code>的调用路径中总会有 <code>runtime·mcall</code>的身影，ip、sp 等寄存器的内容就是在此处被保存，并最终在<code>schedule()</code>中被恢复。</p>
<p>经过上面这些铺垫，我们可以从指令的视角在宏观上来理解一下 go 的协程运作过程：</p>
<p><img data-src="https://qiniu.liupzmin.com/go-cooperative.png" alt="图 6-1 go协作式调度"></p>
<p>仍然以前面展示进程切换时的图作为基础，为了配合 Go 的实际情况，将图中的进程换成线程来讲。现在想象一下，线程 A、B、C 是 go 程序底层的操作系统线程（GMP中的M），g1、g2、g3 为 go 程序在用户空间实现的协程，或者说叫 goroutine。值得注意的是，内核并不知道 goroutine 的存在，它仍然按照自己一贯的行为方式对 A、B、C 三个线程进行调度。</p>
<p>当A线程的时间片用完，或者发出阻塞的系统调用时，就会被内核调度出 CPU，继而把 C 线程调度到 CPU 上来执行。图中显示 A线程被换下 CPU0 的时候，B 线程仍然在 CPU1 上，这意味着其余的 goroutine 依然会得到执行的机会。再看被调度到 CPU0 上的 C 线程，它也是 go 程序底层的线程，这意味着在一个拥有双核的机器上，goroutine 总是有机会运行的，即便有些 goroutine 因为系统调用等某些原因导致其所在的操作系统线程被换下。go 总会保证有两个<strong>“活的”</strong>的线程一直待在 CPU 上轮番寻找 goroutine 来执行，除非操作系统内核看不下去，换其它的程序线程来执行，但 go 总会保证有两个准备好的线程可以随时被内核调度。</p>
<p>再来切一下近景，把 B 线程放大。在内核看来，黄色部分只代表 B 线程的用户态执行流，但就在这个黄色用户态执行流的内部正在轮番上演形形色色的任务，g1、g2、g3 三个 goroutine 正轮流在CPU上执行，绿色执行流代表 go 的 runtime，正是 runtime 居中调度，指挥得当，才让以 goroutine 为单位的任务都获得执行的机会。内核对这些一无所知，CPU也只会觉得奇怪：这个线程的用户态代码怎么老是频繁的切换堆栈？（见<a href="https://liupzmin.com/2022/04/26/theory/stack-insight-03/">《溯源 goroutine 堆栈》</a> 中对 go 协程堆栈的描述)</p>
<p>这种并发模型的优势显而易见，让我们来直观地感受一下。操作系统线程每次上下文切换需要大约 1000ns 的时间，而硬件有望在每纳秒的时间里执行 12 条指令，也就是说，当任务必须等待时，操作系统就会花费 12k 条指令去做线程切换，却不能将这些指令用在有意义的业务上。而 go 在用户态进行协程切换，极大地缓和了这种浪费，go 进行一次协程切换大概需要 200ns 或者 2.4k 条指令。简言之，<strong>go 用尽可能少的 os 级的线程调度来做更多的事情，方式就是在用户空间调度</strong>，这是语言级别的一种能力，可不严谨的说，go 的调度比 os 级调度便宜 5 倍，甚至更多！</p>
<p>操作系统内核之所以可以大胆地把 CPU 的使用权交给用户态程序，是因为时钟中断总会让控制权重归内核。那么，完全运行在用户态的 runtime 是如何获得控制权来调度 goroutine 的呢？go1.14 之前确实没办法做到，控制权的转移完全依靠 goroutine 的主动放弃，通过 <code>runtime.Gosched</code> 调用主动让出执行机会，或者当发生执行栈分段时，检查自身的抢占标记，决定是否继续执行；其中第二种情况是通过编译器编译时在函数调用之前插入指令来实现的，也就是说只有在 goroutine 发生函数调用时，runtime 才会获得短暂的执行权来实施调度。不难想见的是，下面这种无函数调用的代码会导致 goroutine 永远霸占 CPU，runtime 根本得不到执行的机会：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此程序在 Go 1.14 之前的版本不会输出 OK</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换句话说，这种调度方式属于协作式调度，完全依赖执行方的主动弃权；为此，go1.14 基于操作系统信号实现了异步抢占，之所以叫异步，是因为从发送信号到信号被处理这个过程是异步的，并不同步。我这里不准备讲信号的安装、信号的发送逻辑，仅就信号的处理捡扼要处略作说明，感兴趣的朋友可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvemhpeXVuLmNvbS9hcmNoaXZlcy80ODU=">从源码剖析Go语言基于信号抢占式调度<i class="fa fa-external-link-alt"></i></span>这篇文章。</p>
<p>既然 go 的异步抢占处理是基于操作系统信号的，那么在进入go 的处理之前，先来看看操作系统是如何处理信号的吧！</p>
<h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>请允许我略过对信号繁琐的介绍，直接从进&#x2F;线程注意到一个信号到来开始。</p>
<p>每个进程从内核态返回用户态之前都会检查<code>TIF_SIGPENDING</code>标志的值，也就是说，每当内核处理完一个中断或异常后，在返回用户态之前都会检查是否存在挂起信号；为了处理信号，内核会调用<code>do_signal()</code>函数，我们假设这个信号安装了专门的处理程序，<code>do_signal()</code>函数必须强迫该处理程序的执行，这是通过<code>handle_signal()</code>进行的。</p>
<p>难点在于，信号处理程序属于用户空间代码，内核不能直接执行用户代码，要执行用户态的信号处理程序，内核必须返回用户态，而一旦返回用户态，内核栈上的内容就会被清空（内核态堆栈包含了被中断进程的硬件上下文），当信号处理程序执行完毕时，又该如何回到正常的执行流程上呢？另外的复杂性是信号处理函数可以执行系统调用，依然要到内核态逛一圈再回到用户态，并且是回到信号处理程序，而不是回到进程原本的正常执行流。</p>
<p>Linux 采用的解决方案是把保存在内核态堆栈中的硬件上下文拷贝到当前进程的用户态堆栈中（稍后会看到go的信号处理抢占程序是如何利用这一点的）。用户态的堆栈也会被修改，使得信号处理函数执行完毕之后，自动调用<code>sigreturn()</code>系统调用把硬件上下文拷贝回内核态堆栈中，并恢复用户态堆栈中原来的内容。</p>
<p><img data-src="https://qiniu.liupzmin.com/catching-a-signal.png" alt="图 7-1 捕获信号"></p>
<p>图 7-1 说明了进程处理信号时的执行流，当中断或者异常发生的时候，进程陷入内核。在要返回用户态之前，执行了<code>do_signal()</code>函数，并开始处理信号（调用<code>handle_signal()</code>），在用户态堆栈上建立栈帧（调用<code>setup_frame()</code>或<code>setup_rt_frame</code>）。</p>
<p>因为进入内核态时，用户态的寄存器值已被保存到内核态的堆栈上了，所以内核很容易拿到用户态堆栈的地址，并加以修改。建立的栈帧如下图所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/user-mode-frame.png" alt="图 7-2 用户态栈帧"></p>
<p>其中<code>sc</code>中保存了进程的硬件上下文，这是从当前进程的内核堆栈上 copy 来的。<code>precode</code>位于栈顶，是信号处理函数的返回地址，将会发出<code>sigreturn()</code>系统调用。</p>
<p>当栈帧构造完成之后，内核需要修改保存在内核态堆栈上用户态寄存器程序计数器的值，让它指向信号处理程序，这样返回用户态之后就会跳转到信号处理程序处执行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">regs-&gt;esp = (<span class="type">unsigned</span> <span class="type">long</span>) frame;</span><br><span class="line">regs-&gt;eip = (<span class="type">unsigned</span> <span class="type">long</span>) ka-&gt;sa.sa_handler; </span><br><span class="line">regs-&gt;eax = (<span class="type">unsigned</span> <span class="type">long</span>) sig;</span><br><span class="line">regs-&gt;edx = regs-&gt;ecx = <span class="number">0</span>;</span><br><span class="line">regs-&gt;xds = regs-&gt;xes = regs-&gt;xss = __USER_DS; </span><br><span class="line">regs-&gt;xcs = __USER_CS;</span><br></pre></td></tr></table></figure>

<p>这段代码来自《深入理解Linux内核》，大概是 2.6 版本的代码，我找了一下 5.10 版本的内核，其中设置用户栈和寄存器的函数是<code>setup_signal_stack_si</code>，我摘录其中修改内核栈中用户态硬件上下文的内容如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PT_REGS_SP(regs) = (<span class="type">unsigned</span> <span class="type">long</span>) frame;</span><br><span class="line">PT_REGS_DI(regs) = sig;</span><br><span class="line"><span class="comment">/* In case the signal handler was declared without prototypes */</span></span><br><span class="line">PT_REGS_AX(regs) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This also works for non SA_SIGINFO handlers because they expect the</span></span><br><span class="line"><span class="comment"> * next argument after the signal number on the stack.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PT_REGS_SI(regs) = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;frame-&gt;info;</span><br><span class="line">PT_REGS_DX(regs) = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;frame-&gt;uc;</span><br><span class="line">PT_REGS_IP(regs) = (<span class="type">unsigned</span> <span class="type">long</span>) ksig-&gt;ka.sa.sa_handler;</span><br></pre></td></tr></table></figure>

<p>除了设置堆栈、程序计数器之外也设置了 rdi、rsi、rds 这几个寄存器，这是 x86_64 架构下 C 语言的函数调惯例，三个寄存器分别用于存放函数调用时前三个参数。记住这一点，后面介绍 Go 时会用到。</p>
<p>之后，再经过一系列检查，<code>handle_signal()</code>返回到<code>do_signal()</code>，<code>do_signal()</code>返回到用户态，因为程序计数器指向信号处理程序的第一条指令，而栈顶指向已推进用户态堆栈的第一个内存单元。因此，信号处理程序被执行。</p>
<p>信号处理程序结束时，返回栈顶地址，该地址指向栈帧的<code>precode</code>字段所引用的<code>vsyscall</code>页中的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_ _kernel_sigreturn:</span><br><span class="line">popl %eax</span><br><span class="line">movl $__NR_sigreturn, %eax int $0x80</span><br></pre></td></tr></table></figure>

<p>它发出一个系统调用，再次陷入内核，调用<code>restore_ sigcontext( ) </code>函数，将 sc 中记录的硬件上下文恢复到内核态堆栈，并从用户态堆栈删除之前建立的栈帧，之后返回用户态，程序的执行流开始回到中断之处继续执行。</p>
<p>稍后我们会看到，内核从 sc 恢复的内容是被 go 的 runtime 修改过的！</p>
<p>有这些内容做铺垫，就可以聊一聊 go 的信号抢占了！</p>
<h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>go 在 M 上通过<code>initsig()</code>来初始化信号，对于需要安装处理程序的信号，会通过<code>setsig</code>来设置对应的动作，真正执行抢占动作的是<code>doSigPreempt</code>，此时的调用栈为：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sigtramp--&gt;sigtrampgo--&gt;sighandler--&gt;doSigPreempt</span><br></pre></td></tr></table></figure>

<p><code>doSigPreempt</code>有个<code>*sigctxt</code>类型的参数，它表示的是我们上一节介绍过的内核保存在用户态堆栈的<strong>内核态堆栈内容</strong>（比较拗口，需要多读几遍），其中存放的是当前进程用户态的硬件上下文。这个参数是从<code>sigtramp</code>一路传下来的，我们看一下<code>sigtramp</code>的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Called using C ABI.</span><br><span class="line">TEXT runtime·sigtramp(SB),NOSPLIT,$0</span><br><span class="line">	// Transition from C ABI to Go ABI.</span><br><span class="line">	PUSH_REGS_HOST_TO_ABI0()</span><br><span class="line"></span><br><span class="line">	// Call into the Go signal handler</span><br><span class="line">	NOP	SP		// disable vet stack checking</span><br><span class="line">    ADJSP   $24</span><br><span class="line">	MOVQ	DI, 0(SP)	// sig</span><br><span class="line">	MOVQ	SI, 8(SP)	// info</span><br><span class="line">	MOVQ	DX, 16(SP)	// ctx</span><br><span class="line">	CALL	·sigtrampgo(SB)</span><br><span class="line">	ADJSP	$-24</span><br><span class="line"></span><br><span class="line">    POP_REGS_HOST_TO_ABI0()</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p><code>sigtramp</code>实际上是真正的信号处理函数，进程从内核态收到信号回到用户态调用的处理函数就是它，注释中表明这个函数以 C 语言的调用惯例被调用，Go 在这里通过<code>PUSH_REGS_HOST_TO_ABI0</code>保存 go 自己调用惯例用的寄存器后，转换成自己的调用规范，等函数调用完毕之后，再通过<code>POP_REGS_HOST_TO_ABI0</code>恢复这些寄存器的值。</p>
<p>还记得上一节介绍 5.10版本的内核修改用户态寄存器时设置的 rdi、rsi、rdx 的值吗？这三个寄存器的值就是内核模仿调用<code>sigtramp</code>时传入的参数，现在 go 需要以自己的调用规约将其放置到堆栈上，来表示 sig、info、ctx 这三个参数（go1.17 改变了调用规约，已经由堆栈传递参数改为寄存器传递了，不知道为何此处仍然使用堆栈传递，我此处引用的代码是版本 1.18.1）。</p>
<p>当调用到<code>doSigPreempt</code>时，会将<code>ctx</code>这个参数传入，其中包含了进程用户态硬件上下文，希望你还记得这一点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doSigPreempt handles a preemption signal on gp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSigPreempt</span><span class="params">(gp *g, ctxt *sigctxt)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check if this G wants to be preempted and is safe to</span></span><br><span class="line">	<span class="comment">// preempt.</span></span><br><span class="line">	<span class="keyword">if</span> wantAsyncPreempt(gp) &#123;</span><br><span class="line">		<span class="keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;</span><br><span class="line">			<span class="comment">// Adjust the PC and inject a call to asyncPreempt.</span></span><br><span class="line">			ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Acknowledge the preemption.</span></span><br><span class="line">	atomic.Xadd(&amp;gp.m.preemptGen, <span class="number">1</span>)</span><br><span class="line">	atomic.Store(&amp;gp.m.signalPending, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> GOOS == <span class="string">&quot;darwin&quot;</span> || GOOS == <span class="string">&quot;ios&quot;</span> &#123;</span><br><span class="line">		atomic.Xadd(&amp;pendingPreemptSignals, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号处理程序一旦被执行，舞台就交到了 go runtime 手里，<code>ctxt</code>的类型为<code>*sigctxt</code>，指向的是用户态堆栈中存放内核态堆栈内容的地址。然后信号处理程序通过<code>isAsyncSafePoint</code>来判断抢占位置是否安全，并返回安全的抢占地址。如果确认抢占没有问题，接着会调用<code>pushCall</code>方法来修改<code>ctxt</code>中的用户态硬件上下文，用于稍后再一次从内核态返回用户态时模拟出一个用户态程序调用<code>asyncPreempt</code>的假象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *sigctxt)</span></span> pushCall(targetPC, resumePC <span class="type">uintptr</span>) &#123;</span><br><span class="line">	<span class="comment">// Make it look like we called target at resumePC.</span></span><br><span class="line">	sp := <span class="type">uintptr</span>(c.rsp())</span><br><span class="line">	sp -= goarch.PtrSize</span><br><span class="line">	*(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = resumePC</span><br><span class="line">	c.set_rsp(<span class="type">uint64</span>(sp))</span><br><span class="line">	c.set_rip(<span class="type">uint64</span>(targetPC))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pushCall</code>干了两件事：</p>
<ol>
<li>修改程序计数器的指向为<code>asyncPreempt</code>函数的地址。 </li>
<li>修改栈顶指针，将当前 goroutine 的原本中断地址放入堆栈。</li>
</ol>
<p>细心的你可能会问：内核在跳转信号处理程序之前不是已经拓展了堆栈，往里面塞了一个<code>frame</code>么？go runtime 在这里基于原始的栈顶再往里塞一个返回地址，不会引起冲突么？</p>
<p>确实不会引起冲突，因为在 X86-64 调用规范中有一个重要标准——红色区域（Red zone）。它指出：在 rsp 指向的栈顶之后的128 字节被保留，不能被信号和中断处理程序使用，因此我们可以在 Linux 的源码中看到如下处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">......</span><br><span class="line">frame = (<span class="keyword">struct</span> rt_sigframe __user *)</span><br><span class="line">	round_down(stack_top - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rt_sigframe), <span class="number">16</span>);</span><br><span class="line"><span class="comment">/* Subtract 128 for a red zone and 8 for proper alignment */</span></span><br><span class="line">frame = (<span class="keyword">struct</span> rt_sigframe __user *) ((<span class="type">unsigned</span> <span class="type">long</span>) frame - <span class="number">128</span> - <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>内核在构造这个<code>frame</code>的时候留出了 128 字节的空隙，go runtime 见缝插针，将当前 goroutine 被中断时的下一条指令地址放入堆栈。这一套移花接木的功夫打完，信号处理函数执行完毕返回内核态，内核重新恢复原内核态堆栈上的内容，此时的内容是被 go runtime 修改后的。之后，执行流从内核态返回用户态，内核态堆栈被弹出，相关寄存器被恢复，程序计数器指向<code>asyncPreempt</code>，开始运行用户态代码。下面是<code>asyncPreempt</code>的汇编代码，我省略了大部分寄存器的保存和恢复指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TEXT ·asyncPreempt(SB),NOSPLIT|NOFRAME,$0-0</span><br><span class="line">	PUSHQ BP</span><br><span class="line">	MOVQ SP, BP</span><br><span class="line">	// Save flags before clobbering them</span><br><span class="line">	PUSHFQ</span><br><span class="line">	// obj doesn&#x27;t understand ADD/SUB on SP, but does understand ADJSP</span><br><span class="line">	ADJSP $368</span><br><span class="line">	// But vet doesn&#x27;t know ADJSP, so suppress vet stack checking</span><br><span class="line">	NOP SP</span><br><span class="line">	MOVQ AX, 0(SP)</span><br><span class="line">	......</span><br><span class="line">	MOVUPS X15, 352(SP)</span><br><span class="line">	CALL ·asyncPreempt2(SB)</span><br><span class="line">	MOVUPS 352(SP), X15</span><br><span class="line">	MOVUPS 336(SP), X14</span><br><span class="line">    ......</span><br><span class="line">	ADJSP $-368</span><br><span class="line">	POPFQ</span><br><span class="line">	POPQ BP</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p><code>asyncPreempt</code>保存执行现场后，调用了<code>asyncPreempt2</code>，这里要提一下，<code>CALL ·asyncPreempt2(SB)</code> 指令先将下一条指令的地址入栈再进行跳转，这样栈顶的地址就是<code>asyncPreempt2</code>返回时的地址。</p>
<p><code>asyncPreempt2</code>会调用<code>mcall</code>函数，最终会执行调度函数<code>schedule()</code>，还记得吗？<code>schedule()</code>不会返回，执行完<code>runtime·gogo(buf *gobuf)</code>后，新的 goroutine 就在 CPU 上运行了，所以我们要看一下<code>mcall</code>函数保存的现场：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// func mcall(fn func(*g))</span><br><span class="line">// Switch to m-&gt;g0&#x27;s stack, call fn(g).</span><br><span class="line">// Fn must never return. It should gogo(&amp;g-&gt;sched)</span><br><span class="line">// to keep running g.</span><br><span class="line">TEXT runtime·mcall&lt;ABIInternal&gt;(SB), NOSPLIT, $0-8</span><br><span class="line">	MOVQ	AX, DX	// DX = fn</span><br><span class="line"></span><br><span class="line">	// save state in g-&gt;sched</span><br><span class="line">	MOVQ	0(SP), BX	// caller&#x27;s PC</span><br><span class="line">	MOVQ	BX, (g_sched+gobuf_pc)(R14)</span><br><span class="line">	LEAQ	fn+0(FP), BX	// caller&#x27;s SP</span><br><span class="line">	MOVQ	BX, (g_sched+gobuf_sp)(R14)</span><br><span class="line">	MOVQ	BP, (g_sched+gobuf_bp)(R14)</span><br><span class="line"></span><br><span class="line">	// switch to m-&gt;g0 &amp; its stack, call fn</span><br><span class="line">	MOVQ	g_m(R14), BX</span><br><span class="line">	MOVQ	m_g0(BX), SI	// SI = g.m.g0</span><br><span class="line">	CMPQ	SI, R14	// if g == m-&gt;g0 call badmcall</span><br><span class="line">	JNE	goodm</span><br><span class="line">	JMP	runtime·badmcall(SB)</span><br><span class="line">goodm:</span><br><span class="line">	MOVQ	R14, AX		// AX (and arg 0) = g</span><br><span class="line">	MOVQ	SI, R14		// g = g.m.g0</span><br><span class="line">	get_tls(CX)		// Set G in TLS</span><br><span class="line">	MOVQ	R14, g(CX)</span><br><span class="line">	MOVQ	(g_sched+gobuf_sp)(R14), SP	// sp = g0.sched.sp</span><br><span class="line">	PUSHQ	AX	// open up space for fn&#x27;s arg spill slot</span><br><span class="line">	MOVQ	0(DX), R12</span><br><span class="line">	CALL	R12		// fn(g)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	JMP	runtime·badmcall2(SB)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p>这两句是保存程序计数器的值到<code>g-&gt;sched</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVQ	0(SP), BX	// caller&#x27;s PC</span><br><span class="line">MOVQ	BX, (g_sched+gobuf_pc)(R14)</span><br></pre></td></tr></table></figure>

<p>可见，保存的地址是栈顶的内容，而此时栈顶内容是<strong>函数<code>asyncPreempt</code>中<code>CALL ·asyncPreempt2(SB)</code>的下一条指令</strong>，即<code>MOVUPS 352(SP), X15</code>；也就是说，当该 goroutine 再次被调度时，会从<code>asyncPreempt2</code>中继续执行，然后返回到<code>asyncPreempt</code>，<code>asyncPreempt</code>返回时从堆栈弹出将要跳转的地址，而这个地址就是 go 见缝插针塞进来的地址，这看起来就像是 goroutine 调用<code>asyncPreempt</code>一般。执行流走到这里，才真正意义上完成了 goroutine 的恢复执行。</p>
<p>由此观之，<code>asyncPreempt</code>更像是 Linux 内核中的<code>schedule()</code>：<strong>调度发生在函数执行过程中，而函数执行完毕要等到下一次被调度的时候才会发生。</strong> 而 go 借助信号机制所实现的抢占，无非就是依靠信号处理程序这一次控制权埋点，以便在执行流最终从内核态返回时执行<code>asyncPreempt</code>代码，从而再一次收获 CPU 的控制权。</p>
<p>是时候再从指令的视角在宏观上来理解 go 的信号抢占流程了：</p>
<p><img data-src="https://qiniu.liupzmin.com/go-preempt.png" alt="图 8-1 go 异步抢占"></p>
<p>图 8-1 显示了通过异步抢占执行流从 g1 切换到 g2 的过程：</p>
<ol>
<li>g1被时钟中断，从内核返回时发现有抢占信号。</li>
<li>执行流从内核态返回到用户态，执行信号处理程序（第一个绿色的 go runtime 执行流）。</li>
<li>信号处理程序执行完毕返回内核，内核做一些恢复后，再次返回到用户态。</li>
<li>从内核态返回后的执行流被 go runtime 窃取，转而执行调度（第二个绿色的 go runtime 执行流）。</li>
<li>g2 被选择，换上 CPU 执行。</li>
</ol>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>文章写到这里，基本上把我想讲的已经讲完了，也算基本上完成了自己“观其大略，本其脉络”的目标，我曾在<a href="https://liupzmin.com/2021/06/27/theory/stack-insight-01-md/">《从CPU的视角说起》</a> 一文中说道：<strong>我目前所寻求的信息，意在建立计算机系统的世界观与 Go 语言的世界观，是在陷入具体细节之前为自己提供一个大致的轮廓，让自己对计算机运行的脉络有一个关键性的认识。</strong> 即便如此，里面也不可避免的出现很多具体而微的内容。我略过了很多环节，并不是因为它们不重要，是因为它们是细节，是更丰富的东西，也是我尚未探索的东西。</p>
<p>苏轼有自己的一套读书方法叫做“八面受敌”，他在写给侄女婿王庠的《又答王庠书》中作了详细介绍：“但卑意欲少年为学者，每一书皆作数过尽之。书富如入海，百货皆有，人之精力，不能兼收尽取，但得其所欲求者尔。故愿学者每次作一意求之。如欲求古今兴亡治乱、圣贤作用、但作此意求之，勿生余念。又别作一次，求事迹故实典章文物之类，亦如之。他皆仿此。此虽迂钝，而他日学成，八面受敌，与涉猎者不可同日而语也。”</p>
<p>这段话可谓深得我心，“人之精力，不能兼收尽取，但得其所欲求者尔”、“故愿学者每次作一意求之”，我欲寻求堆栈的本源，翻尽家中藏书，完成了《学渣三部曲》，又执着于调度，翻阅同样的书，才有了这一篇万字长文，此虽迂钝，而他日学成，八面受敌，与涉猎者不可同日而语也。</p>
<p>最后再聊一聊“程序”，第4节曾讨论过“程序”一词的含义，平时我们习惯将开发最终交付的制品称为“程序”，或有“我写了某某程序”之类云云，“程序”若是躺在计算机硬盘中的二进制文件，那当它被调入内存醒来时，一定会哀叹自己生命的不完整，因为每当它想“耳听之而为声，目遇之而成色”的时候，面前总会横着一道“系统调用”的鸿沟，以至于它永远无法亲自触摸“大自然”的无尽藏。换句话说，我们到底创造了什么？一条流动的进程中，有多少是属于我们这样平凡之人的？刨去内核指令，刨去运行时、库以及不可胜数的框架代码，我相信已所剩无几！</p>
<p>我之所以无法骄傲，是因为站在巨人的肩上！</p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMzQ2MzkzMC8=">操作系统导论<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjkxMjc2Ny8=">深入理解计算机系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yMjg3NTA2Lw==">深入理解LINUX内核<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80ODQzNTY3Lw==">深入 Linux 内核架构<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDI5NzkxOS8=">操作系统概念<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1saW51eC1zeXN0ZW0tY2FsbHMv">The Definitive Guide to Linux System Calls<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96Ym95YS5naXRodWIuaW8vcG9zdC9nb19zY2hlZHVsZXIv">深入golang runtime的调度<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvemhpeXVuLmNvbS9hcmNoaXZlcy80ODU=">从源码剖析Go语言基于信号抢占式调度<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2xhc3R3ZWVrLmlvL25vdGVzL2xpbnV4L2Zvcmsv">Misc on Linux fork, switch_to, and scheduling<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWFpenVyZS5vcmcvcHJvamVjdHMvZXZvbHV0aW9uX3g4Nl9jb250ZXh0X3N3aXRjaF9saW51eC8=">Evolution of the x86 context switch in Linux<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcuZGVzaWduL3VuZGVyLXRoZS1ob29kL3poLWNuL3BhcnQycnVudGltZS9jaDA2c2NoZWQvcHJlZW1wdGlvbi8=">Go 语言原本<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMTgvMDgvc2NoZWR1bGluZy1pbi1nby1wYXJ0Mi5odG1s">Scheduling In Go : Part II - Go Scheduler<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2022/04/26/theory/stack-insight-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/26/theory/stack-insight-03/" class="post-title-link" itemprop="url">Stack 顿悟三部曲（3）：溯源 goroutine 堆栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-26 10:30:17" itemprop="dateCreated datePublished" datetime="2022-04-26T10:30:17+08:00">2022-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过 <a href="https://liupzmin.com/2021/06/27/theory/stack-insight-01-md/">从CPU的视角说起</a> 和 <a href="https://liupzmin.com/2021/07/20/theory/stack-insight-02/">穿越虚拟内存的迷雾</a> 两篇文章我们知道，所谓进程堆栈不过是应用程序向内核申请了一块连续内存后，设定相应的寄存器，从而将这块内存当做堆栈来使用，典型的用法就是用于函数调用。</p>
<p>我们在<a href="https://liupzmin.com/2021/07/20/theory/stack-insight-02/">上一篇</a>讨论了进线程的堆栈，现在继续探索 go 中的协程栈。如果吊一下书袋的话，口称 go 协程是不严谨的，go 的协程不同于其他语言的协程，go 的协程是一种有栈协程，每一个协程都有自己的协程堆栈，因此 go 官网发明了一个新词 <code>goroutine</code>，以区别于普通的 <code>coroutine</code>。我们接下来就聊聊 goroutine 的堆栈。在此之前，先来回顾一下上一篇中对进线程堆栈位置的总结。</p>
<blockquote>
<p>本文基于 Linux 平台 x64 架构，使用 go 1.18 源码，禁用 cgo</p>
</blockquote>
<h2 id="1·-进线程堆栈"><a href="#1·-进线程堆栈" class="headerlink" title="1· 进线程堆栈"></a>1· 进线程堆栈</h2><p><img data-src="https://s3.ap-northeast-1.amazonaws.com/qiniu.liupzmin.com/stack-region.png" alt="图 3-1 位于不同区域的线程 stack"></p>
<p>图 3.1 为 64 位虚拟地址空间布局图，粉色标识说明了线程堆栈可能存在的位置，总结下来，不外乎以下三种情况：</p>
<ol>
<li>主线程堆栈位于用户空间顶部，但 clone 时，子进程的主线程实际使用的堆栈未必如此。</li>
<li>有可能分配在 mmap 区域。</li>
<li>有可能通过 C 库 malloc 分配在 heap 区域。</li>
</ol>
<h2 id="2-goroutine-的堆栈"><a href="#2-goroutine-的堆栈" class="headerlink" title="2. goroutine 的堆栈"></a>2. goroutine 的堆栈</h2><p>或许你已经知道 goroutine 的堆栈是从 heap 上分配的，但如果你足够好奇，你就会为 heap 在虚拟地址空间中的位置而发狂。</p>
<p>go 重写了运行时，如果不使用 cgo 的话，编译完成的 go 程序是静态链接的，不依赖任何C库，这使它拥有不错的可移植性，在较新内核上编译好的程序，拉到旧版本内核的操作系统上依然能够运行。在这一点上，rust 并没有多少优势，反而新生语言 <span class="exturl" data-url="aHR0cHM6Ly9oYXJlbGFuZy5vcmcv">hare<i class="fa fa-external-link-alt"></i></span> 表现足够强劲。</p>
<p>不依赖 C 库，意味着 go 对 heap 的管理有自己的方式。 那么， go 管理的 heap 是否与之前内存空间布局图中的 heap 位置相同就要打一个大大的问号了。要搞清楚这个问题，我们需要到 runtime 的源码中一探究竟，且要挖到 go 与内核的接口处，找出其申请内存的方式方可。</p>
<p>本文并不打算分析 go 的内存分配器，也不打算介绍堆栈的分配算法，仅仅为了解决 goroutine 堆栈在虚拟地址空间中位置的疑惑。想了解内存管理和堆栈分配算法的读者可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvemhpeXVuLmNvbS9hcmNoaXZlcy80MzQ=">详解Go中内存分配源码实现<i class="fa fa-external-link-alt"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvemhpeXVuLmNvbS9hcmNoaXZlcy81MTM=">一文教你搞懂 Go 中栈操作<i class="fa fa-external-link-alt"></i></span>。</p>
<p>先从普通 goroutine 的创建开始吧！</p>
<p>在 go 中，每通过<code>go func()&#123;&#125;</code>的方式开启一个 goroutine 时，编译器都会将其转换成对 <code>runtime.newproc</code>的调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new g running fn.</span></span><br><span class="line"><span class="comment">// Put it on the queue of g&#x27;s waiting to run.</span></span><br><span class="line"><span class="comment">// The compiler turns a go statement into a call to this.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(fn *funcval)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">    <span class="comment">// 切换到线程堆栈创建 g</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newg := newproc1(fn, gp, pc)</span><br><span class="line"></span><br><span class="line">		_p_ := getg().m.p.ptr()</span><br><span class="line">		runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newproc</code> 仅仅是对 <code>newproc1</code> 的包装，创建新 g 的动作不能在用户堆栈上进行，所以这里切换到底层线程的堆栈来执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new g in state _Grunnable, starting at fn. callerpc is the</span></span><br><span class="line"><span class="comment">// address of the go statement that created this. The caller is responsible</span></span><br><span class="line"><span class="comment">// for adding the new g to the scheduler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> *g &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">		throw(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line"></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="comment">// 从 P 的空闲链表中获取一个新的 G</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">    <span class="comment">// 获取不到则调用 malg 进行创建</span></span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newproc1</code> 方法很长，里面主要是获取 <code>G</code> ，然后对获取到的 <code>G</code> 做一些初始化的工作。当创建 <code>G</code> 时，会先从缓存的空闲链表中获取，如果没有空闲的 <code>G</code> ，再进行创建。所以，我们这里只看 <code>malg</code> 函数的调用。</p>
<p>在调用 <code>malg</code> 函数的时候会传入一个最小堆栈大小值：**_StackMin**（linux 平台下为 2048）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a new g, with a stack big enough for stacksize bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">malg</span><span class="params">(stacksize <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">	newg := <span class="built_in">new</span>(g)</span><br><span class="line">	<span class="keyword">if</span> stacksize &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		stacksize = round2(_StackSystem + stacksize)</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newg.stack = stackalloc(<span class="type">uint32</span>(stacksize))</span><br><span class="line">		&#125;)</span><br><span class="line">		newg.stackguard0 = newg.stack.lo + _StackGuard</span><br><span class="line">		newg.stackguard1 = ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">		<span class="comment">// Clear the bottom word of the stack. We record g</span></span><br><span class="line">		<span class="comment">// there on gsignal stack during VDSO on ARM and ARM64.</span></span><br><span class="line">		*(*<span class="type">uintptr</span>)(unsafe.Pointer(newg.stack.lo)) = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>malg</code> 会创建新的 <code>G</code> 并为其设置好堆栈，以及堆栈的边界，以供日后扩容使用。这里重点看 <code>stackalloc</code> 函数，堆栈的内存的分配就是由它来完成的，函数的返回值赋给新 <code>G</code> 的 <code>stack</code> 字段。</p>
<p><code>G</code> 的 <code>stack</code> 字段是一个 <code>stack</code> 结构体类型，里面标记了堆栈的高地址和低地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack describes a Go execution stack.</span></span><br><span class="line"><span class="comment">// The bounds of the stack are exactly [lo, hi),</span></span><br><span class="line"><span class="comment">// with no implicit data structures on either side.</span></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	lo <span class="type">uintptr</span></span><br><span class="line">	hi <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着看这个 <code>stack</code> 是怎么创建出来的。</p>
<p><code>stackalloc</code> 的函数比较长，里面涉及到大堆栈和小堆栈的分配逻辑，这里就不贴大段的代码了。这个函数不管是从 cache 还是 pool 中获取内存，最终都会在内存不够时调用 <code>mheap</code> 的<code>allocManual</code>函数去分配新的内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mheap_.allocManual(_StackCacheSize&gt;&gt;_PageShift, spanAllocStack)</span><br></pre></td></tr></table></figure>

<p>到这里就遇见 go 管理的 <code>heap</code> 了，关于 <code>heap</code> 的位置我们稍后再讨论，现在继续挖 <code>allocManual</code> 直到我们找到系统调用为止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocManual(npages <span class="type">uintptr</span>, typ spanAllocType) *mspan &#123;</span><br><span class="line">	<span class="keyword">if</span> !typ.manual() &#123;</span><br><span class="line">		throw(<span class="string">&quot;manual span allocation called with non-manually-managed type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h.allocSpan(npages, typ, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allocManual</code> 只是对 <code>allocSpan</code> 的简单封装，这里简单提一下 go 对内存管理的最小单位是 <code>mspan</code>，它包含若干连续的页。</p>
<p><code>allocSpan</code> 的逻辑较多，主要是从 heap 中分配 <code>npages</code> 个页来填充 span。一般随着程序的运行，内存的不断申请，<code>heap</code> 中会有很多空闲的页用来供给后续的内存申请。现在我们需要查看 cache 不足的情况，当 heap 中的 page 不够的时候，就需要推动 heap 增长了，<code>allocSpan</code> 通过调用 <code>mheap.grow</code> 来达成这一点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to add at least npage pages of memory to the heap,</span></span><br><span class="line"><span class="comment">// returning how much the heap grew by and whether it worked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> grow(npage <span class="type">uintptr</span>) (<span class="type">uintptr</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	assertLockHeld(&amp;h.lock)</span><br><span class="line">	ask := alignUp(npage, pallocChunkPages) * pageSize</span><br><span class="line">	totalGrowth := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// This may overflow because ask could be very large</span></span><br><span class="line">	<span class="comment">// and is otherwise unrelated to h.curArena.base.</span></span><br><span class="line">	<span class="comment">// curArena 无需初始化，但问题是怎么判断 Arena 边界呢</span></span><br><span class="line">	end := h.curArena.base + ask</span><br><span class="line">	nBase := alignUp(end, physPageSize)</span><br><span class="line">	<span class="keyword">if</span> nBase &gt; h.curArena.end || <span class="comment">/* overflow */</span> end &lt; h.curArena.base &#123;</span><br><span class="line">		<span class="comment">// 尝试分配新的 Arena，但有可能跨越 hint 区域，所以全额申请</span></span><br><span class="line">		<span class="comment">// Not enough room in the current arena. Allocate more</span></span><br><span class="line">		<span class="comment">// arena space. This may not be contiguous with the</span></span><br><span class="line">		<span class="comment">// current arena, so we have to request the full ask.</span></span><br><span class="line">		av, asize := h.sysAlloc(ask)</span><br><span class="line">		<span class="comment">// 此时已经将需要的内存 reserve 了</span></span><br><span class="line">		<span class="keyword">if</span> av == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: out of memory: cannot allocate &quot;</span>, ask, <span class="string">&quot;-byte block (&quot;</span>, memstats.heap_sys, <span class="string">&quot; in use)\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="type">uintptr</span>(av) == h.curArena.end &#123;</span><br><span class="line">			<span class="comment">// 说明是连续的，拓展此 curArena 的边界</span></span><br><span class="line">			<span class="comment">// The new space is contiguous with the old</span></span><br><span class="line">			<span class="comment">// space, so just extend the current space.</span></span><br><span class="line">			h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 感觉像是这一次不够分配的，但也别浪费，把剩余的内存标记为已使用，加入到一个地方以供分配</span></span><br><span class="line">			<span class="comment">// The new space is discontiguous. Track what</span></span><br><span class="line">			<span class="comment">// remains of the current space and switch to</span></span><br><span class="line">			<span class="comment">// the new space. This should be rare.</span></span><br><span class="line">			<span class="keyword">if</span> size := h.curArena.end - h.curArena.base; size != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Transition this space from Reserved to Prepared and mark it</span></span><br><span class="line">				<span class="comment">// as released since we&#x27;ll be able to start using it after updating</span></span><br><span class="line">				<span class="comment">// the page allocator and releasing the lock at any time.</span></span><br><span class="line">				sysMap(unsafe.Pointer(h.curArena.base), size, &amp;memstats.heap_sys)</span><br><span class="line">				<span class="comment">// Update stats.</span></span><br><span class="line">				atomic.Xadd64(&amp;memstats.heap_released, <span class="type">int64</span>(size))</span><br><span class="line">				stats := memstats.heapStats.acquire()</span><br><span class="line">				atomic.Xaddint64(&amp;stats.releagrowsed, <span class="type">int64</span>(size))</span><br><span class="line">				memstats.heapStats.release()</span><br><span class="line">				<span class="comment">// Update the page allocator&#x27;s structures to make this</span></span><br><span class="line">				<span class="comment">// space ready for allocation.</span></span><br><span class="line">				h.pages.grow(h.curArena.base, size)</span><br><span class="line">				totalGrowth += size</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Switch to the new space.</span></span><br><span class="line">			<span class="comment">// 把 curArena 切换到新的地址</span></span><br><span class="line">			h.curArena.base = <span class="type">uintptr</span>(av)</span><br><span class="line">			h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Recalculate nBase.</span></span><br><span class="line">		<span class="comment">// We know this won&#x27;t overflow, because sysAlloc returned</span></span><br><span class="line">		<span class="comment">// a valid region starting at h.curArena.base which is at</span></span><br><span class="line">		<span class="comment">// least ask bytes in size.</span></span><br><span class="line">		nBase = alignUp(h.curArena.base+ask, physPageSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新 base</span></span><br><span class="line">	<span class="comment">// Grow into the current arena.</span></span><br><span class="line">	v := h.curArena.base</span><br><span class="line">	h.curArena.base = nBase</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把分配的那块内存标记为 Prepared</span></span><br><span class="line">	<span class="comment">// Transition the space we&#x27;re going to use from Reserved to Prepared.</span></span><br><span class="line">	sysMap(unsafe.Pointer(v), nBase-v, &amp;memstats.heap_sys)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...... 省略部分代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the page allocator&#x27;s structures to make this</span></span><br><span class="line">	<span class="comment">// space ready for allocation.</span></span><br><span class="line">	h.pages.grow(v, nBase-v)</span><br><span class="line">	totalGrowth += nBase - v</span><br><span class="line">	<span class="keyword">return</span> totalGrowth, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>curArena</code>的空闲内存（内核返回的内存空间往往会比请求的多一些）不足以满足分配时，调用<code>mheap.sysAlloc</code>来申请更多的空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> sysAlloc(n <span class="type">uintptr</span>) (v unsafe.Pointer, size <span class="type">uintptr</span>) &#123;</span><br><span class="line">	assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">	n = alignUp(n, heapArenaBytes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, try the arena pre-reservation.</span></span><br><span class="line">	v = h.arena.alloc(n, heapArenaBytes, &amp;memstats.heap_sys)</span><br><span class="line">	<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">		size = n</span><br><span class="line">		<span class="keyword">goto</span> mapped</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try to grow the heap at a hint address.</span></span><br><span class="line">	<span class="keyword">for</span> h.arenaHints != <span class="literal">nil</span> &#123;</span><br><span class="line">		hint := h.arenaHints</span><br><span class="line">		p := hint.addr</span><br><span class="line">		<span class="keyword">if</span> hint.down &#123;</span><br><span class="line">			p -= n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line">			<span class="comment">// We can&#x27;t use this, so don&#x27;t ask.</span></span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">			<span class="comment">// Outside addressable heap. Can&#x27;t use.</span></span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果不相等，则说明 mmap 在建议的地址上没能分配成功</span></span><br><span class="line">		<span class="keyword">if</span> p == <span class="type">uintptr</span>(v) &#123;</span><br><span class="line">			<span class="comment">// Success. Update the hint.</span></span><br><span class="line">			<span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">				p += n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 成功后，hint 的地址也跟着更新</span></span><br><span class="line">			hint.addr = p</span><br><span class="line">			size = n</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此时，丢弃这次分配的内存，尝试下一个 arenaHints, 也就是下一个 1T 区间</span></span><br><span class="line">		<span class="comment">// Failed. Discard this hint and try the next.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This would be cleaner if sysReserve could be</span></span><br><span class="line">		<span class="comment">// told to only return the requested address. In</span></span><br><span class="line">		<span class="comment">// particular, this is already how Windows behaves, so</span></span><br><span class="line">		<span class="comment">// it would simplify things there.</span></span><br><span class="line">		<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">			sysFree(v, n, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.arenaHints = hint.next</span><br><span class="line">		h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			<span class="comment">// The race detector assumes the heap lives in</span></span><br><span class="line">			<span class="comment">// [0x00c000000000, 0x00e000000000), but we</span></span><br><span class="line">			<span class="comment">// just ran out of hints in this region. Give</span></span><br><span class="line">			<span class="comment">// a nice failure.</span></span><br><span class="line">			throw(<span class="string">&quot;too many address space collisions for -race mode&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All of the hints failed, so we&#x27;ll take any</span></span><br><span class="line">		<span class="comment">// (sufficiently aligned) address the kernel will give</span></span><br><span class="line">		<span class="comment">// us.</span></span><br><span class="line">		<span class="comment">// 所有的 hint 都失败了，然后让内核自动分配一个定量内存</span></span><br><span class="line">		v, size = sysReserveAligned(<span class="literal">nil</span>, n, heapArenaBytes)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create new hints for extending this region.</span></span><br><span class="line">		hint := (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr, hint.down = <span class="type">uintptr</span>(v), <span class="literal">true</span></span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		hint = (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr = <span class="type">uintptr</span>(v) + size</span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ......省略大段代码</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里真正申请内存的操作是 <code>sysReserve</code>，让我们来一睹究竟：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉的 <code>mmap</code> 映入眼帘！我们已经抵达了内核的大门，查看其定义发现，它包裹了一个<code>sysMmap</code>函数，该函数就是发起<code>mmap</code>系统调用的所在，它是由汇编语言写成，Linux 下函数体位于 sys_linux_amd64.s 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysMmap calls the mmap system call. It is implemented in assembly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysMmap</span><span class="params">(addr unsafe.Pointer, n <span class="type">uintptr</span>, prot, flags, fd <span class="type">int32</span>, off <span class="type">uint32</span>)</span></span> (p unsafe.Pointer, err <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p><code>mmap</code>调用中的 flag <code>_PROT_NONE, _MAP_ANON|_MAP_PRIVATE</code>表示申请的内存块是无文件背景的匿名映射，这里在调用时传入了一个提示地址，用于告知内核尽量从要求的地址开始分配。</p>
<p>内核当然不能保证这一点，但 go 也足够倔强，如果不能保证连续增长，就另找一段空间开始：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不相等，则说明 mmap 在建议的地址上没能分配成功</span></span><br><span class="line"><span class="keyword">if</span> p == <span class="type">uintptr</span>(v) &#123;</span><br><span class="line">	<span class="comment">// Success. Update the hint.</span></span><br><span class="line">	<span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">		p += n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成功后，hint 的地址也跟着更新</span></span><br><span class="line">	hint.addr = p</span><br><span class="line">	size = n</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时，丢弃这次分配的内存，尝试下一个 arenaHints, 也就是下一个 1T 区间</span></span><br><span class="line"><span class="comment">// Failed. Discard this hint and try the next.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This would be cleaner if sysReserve could be</span></span><br><span class="line"><span class="comment">// told to only return the requested address. In</span></span><br><span class="line"><span class="comment">// particular, this is already how Windows behaves, so</span></span><br><span class="line"><span class="comment">// it would simplify things there.</span></span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">	sysFree(v, n, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">h.arenaHints = hint.next</span><br><span class="line">h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br></pre></td></tr></table></figure>

<p>从 <code>sysAlloc</code> 返回之后，就意味着已经从内核申请到了一块空间。回到 <code>mheap.grow</code>的代码，会看到调用了 <code>sysMap</code> 再次向内核申请内存，<code>sysMap</code> 代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysMap</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> &#123;</span><br><span class="line">	sysStat.add(<span class="type">int64</span>(n))</span><br><span class="line"></span><br><span class="line">	p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err == _ENOMEM &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: out of memory&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p != v || err != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: mmap(&quot;</span>, v, <span class="string">&quot;, &quot;</span>, n, <span class="string">&quot;) returned &quot;</span>, p, <span class="string">&quot;, &quot;</span>, err, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;runtime: cannot map pages in arena address space&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，也是一个<code>mmap</code>系统调用，但传入的 flag 不同，多了一个 <code>_MAP_FIXED</code> 。</p>
<p>查看 <code>mmap</code> 的手册便会明白，在不提供<code>_MAP_FIXED</code> 的情况下，内核会尽量从给出的地址分配空间，但避免冲突是第一位的，所以结果并不总能如意。而<code>_MAP_FIXED</code>保证了这一点，即使在请求的地址处已有其它映射的情况下也会覆盖之前的映射。</p>
<p><code>mmap</code> 文档中也对 <code>_MAP_FIXED</code> 使用提出了警示，而 go 在这里使用是完全没有问题的，因为事先已经向内核申请了该块内存了，在里面隔上一刀根本不需要睁眼。</p>
<p>我们拿到了一块连续的内存，是时候从 <code>allocSpan</code> 返回了，如此 <code>stackalloc</code> 就为新 G 申请到了一块连续内存用作堆栈。</p>
<p>从 goroutine 的新建一直到内核的大门，我们发现了用于申请内存的方式是 <code>mmap</code>，但<code>mmap</code>从进程虚拟地址空间的哪个位置分配内存呢？<code>runtime</code> 源码中给与的<code>提示地址</code>又是从何而来呢？</p>
<h2 id="3-mmap-申请内存的位置"><a href="#3-mmap-申请内存的位置" class="headerlink" title="3. mmap 申请内存的位置"></a>3. mmap 申请内存的位置</h2><p>mmap 既是一个系统调用，也是进程虚拟地址空间中的一个区域，让我再次援引《深入 Linux 内核架构》中的一幅图：</p>
<p><img data-src="https://qiniu.liupzmin.com/mmap-region.png" alt="图3-2 mmap 区域自顶向下扩展"></p>
<p>书中介绍了 2.6 版本的内核内存布局，其中 mmap 区域是和 heap 相对增长的，内核会留出足够的空间给主线程 stack，这样便可最大化的利用内存空间，好在 stack 通常不会很大。</p>
<p>但是 mmap 并非只能在概念上划出的区域进行分配，它甚至可以在用户空间内任意地方分配内存，这当然也包括传统的 heap 区域！还记得 <code>_MAP_FIXED</code> 吧？我打赌它绝对能让你的程序 crash 掉！</p>
<p>heap 是用来为进程动态分配内存的，传统的定义是：<strong>堆是一段长度可变的连续虚拟内存，始于进程的未初始化数据段的末尾，随着内存的分配和释放而增减</strong>：</p>
<p><img data-src="https://qiniu.liupzmin.com/virtual-memory-of-a-linux-process.png" alt="图 3-3 Linux 进程的虚拟内存布局"></p>
<p>改变 heap 大小的系统调用是 <code>brk</code> 和 <code>sbrk</code> ，而 go 主要使用 mmap 来维护堆，这就说明 go 堆和传统的堆位置是不同的。位置虽然不同，但使命毫无二致，让我们来看一个 go 程序的内存布局：</p>
<pre>00400000-004bd000 r-xp 00000000 103:02 8916313      playground/helloworld/hello/hello
004bd000-00574000 r--p 000bd000 103:02 8916313      playground/helloworld/hello/hello
00574000-0058f000 rw-p 00174000 103:02 8916313      playground/helloworld/hello/hello
0058f000-005c4000 rw-p 00000000 00:00 0 
<span style="color:red">c000000000-c000200000 rw-p 00000000 00:00 0 </span>
c000200000-c017e00000 rw-p 00000000 00:00 0 
c017e00000-c018000000 rw-p 00000000 00:00 0 
c018000000-c018400000 rw-p 00000000 00:00 0 
c018400000-c01c000000 ---p 00000000 00:00 0 
7fef44906000-7fef449ba000 rw-p 00000000 00:00 0 
7fef449d2000-7fef47c19000 rw-p 00000000 00:00 0 
7fef47c19000-7fef57d99000 ---p 00000000 00:00 0 
7fef57d99000-7fef57d9a000 rw-p 00000000 00:00 0 
7fef57d9a000-7fef69c49000 ---p 00000000 00:00 0 
7fef69c49000-7fef69c4a000 rw-p 00000000 00:00 0 
7fef69c4a000-7fef6c01f000 ---p 00000000 00:00 0 
7fef6c01f000-7fef6c020000 rw-p 00000000 00:00 0 
7fef6c020000-7fef6c499000 ---p 00000000 00:00 0 
7fef6c499000-7fef6c49a000 rw-p 00000000 00:00 0 
7fef6c49a000-7fef6c519000 ---p 00000000 00:00 0 
7fef6c519000-7fef6c579000 rw-p 00000000 00:00 0 
7ffc335d5000-7ffc335f7000 rw-p 00000000 00:00 0                          [stack]
7ffc335f8000-7ffc335fc000 r--p 00000000 00:00 0                          [vvar]
7ffc335fc000-7ffc335fe000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</pre>

<p align="center">表3-1 Go 进程的内存布局映射</p>

<p>除了代码段不足 2M 的区域之外，似乎 <code>c000000000</code> 最值得怀疑，而且这份映射当中没有看到 heap 身影，这直接印证了上述猜想。关于 <code>c000000000</code> 我们要去源码中寻找答案，且看内存分配器的初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...... 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只看 64 位系统的初始化部分</span></span><br><span class="line">	<span class="comment">// Create initial arena growth hints.</span></span><br><span class="line">	<span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">		<span class="comment">// On a 64-bit machine, we pick the following hints</span></span><br><span class="line">		<span class="comment">// because:</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 1. Starting from the middle of the address space</span></span><br><span class="line">		<span class="comment">// makes it easier to grow out a contiguous range</span></span><br><span class="line">		<span class="comment">// without running in to some other mapping.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 2. This makes Go heap addresses more easily</span></span><br><span class="line">		<span class="comment">// recognizable when debugging.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 3. Stack scanning in gccgo is still conservative,</span></span><br><span class="line">		<span class="comment">// so it&#x27;s important that addresses be distinguishable</span></span><br><span class="line">		<span class="comment">// from other data.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Starting at 0x00c0 means that the valid memory addresses</span></span><br><span class="line">		<span class="comment">// will begin 0x00c0, 0x00c1, ...</span></span><br><span class="line">		<span class="comment">// In little-endian, that&#x27;s c0 00, c1 00, ... None of those are valid</span></span><br><span class="line">		<span class="comment">// UTF-8 sequences, and they are otherwise as far away from</span></span><br><span class="line">		<span class="comment">// ff (likely a common byte) as possible. If that fails, we try other 0xXXc0</span></span><br><span class="line">		<span class="comment">// addresses. An earlier attempt to use 0x11f8 caused out of memory errors</span></span><br><span class="line">		<span class="comment">// on OS X during thread allocations.  0x00c0 causes conflicts with</span></span><br><span class="line">		<span class="comment">// AddressSanitizer which reserves all memory up to 0x0100.</span></span><br><span class="line">		<span class="comment">// These choices reduce the odds of a conservative garbage collector</span></span><br><span class="line">		<span class="comment">// not collecting memory because some non-pointer block of memory</span></span><br><span class="line">		<span class="comment">// had a bit pattern that matched a memory address.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// However, on arm64, we ignore all this advice above and slam the</span></span><br><span class="line">		<span class="comment">// allocation at 0x40 &lt;&lt; 32 because when using 4k pages with 3-level</span></span><br><span class="line">		<span class="comment">// translation buffers, the user address space is limited to 39 bits</span></span><br><span class="line">		<span class="comment">// On ios/arm64, the address space is even smaller.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// On AIX, mmaps starts at 0x0A00000000000000 for 64-bit.</span></span><br><span class="line">		<span class="comment">// processes.</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">var</span> p <span class="type">uintptr</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> raceenabled:</span><br><span class="line">				<span class="comment">// The TSAN runtime requires the heap</span></span><br><span class="line">				<span class="comment">// to be in the range [0x00c000000000,</span></span><br><span class="line">				<span class="comment">// 0x00e000000000).</span></span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">32</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">				<span class="keyword">if</span> p &gt;= uintptrMask&amp;<span class="number">0x00e000000000</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span> &amp;&amp; GOOS == <span class="string">&quot;ios&quot;</span>:</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span>:</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">			<span class="keyword">case</span> GOOS == <span class="string">&quot;aix&quot;</span>:</span><br><span class="line">				<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// We don&#x27;t use addresses directly after 0x0A00000000000000</span></span><br><span class="line">					<span class="comment">// to avoid collisions with others mmaps done by non-go programs.</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0xa0</span>&lt;&lt;<span class="number">52</span>)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">			hint.addr = p</span><br><span class="line">			hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释部分第一条便说：<strong>从地址空间的中间开始向上增长，很容易获得连续的区域，且不会和其它映射部位发生碰撞。</strong></p>
<p>因此 go 选择了从 <code>0x00c0</code>开始，并且用一个 for 循环生成了 128 个提示地址，组成链表初始化到 <code>mheap_.arenaHints</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0x7fc000000000</span><br><span class="line">......</span><br><span class="line">0x10c000000000</span><br><span class="line">0x0fc000000000</span><br><span class="line">0x0ec000000000</span><br><span class="line">0x0dc000000000</span><br><span class="line">0x0cc000000000</span><br><span class="line">0x0bc000000000</span><br><span class="line">0x0ac000000000</span><br><span class="line">0x09c000000000</span><br><span class="line">0x08c000000000</span><br><span class="line">0x07c000000000</span><br><span class="line">0x06c000000000</span><br><span class="line">0x05c000000000</span><br><span class="line">0x04c000000000</span><br><span class="line">0x03c000000000</span><br><span class="line">0x02c000000000</span><br><span class="line">0x01c000000000</span><br><span class="line">0x00c000000000</span><br></pre></td></tr></table></figure>

<p>这 128 个起始地址除了最后一个之外，其余皆可向上增长 1TiB 的空间，最后一个距离用户空间顶部仅剩 256 GiB。</p>
<p><code>0x00c000000000</code> 距离用户空间的开始有 765 GiB，这也是为什么<strong>不会和其它映射部位发生碰撞</strong>的原因！</p>
<p><code>mallocinit</code> 初始化了<code>mheap_.arenaHints</code>，还记得 mheap 为增加 heap 而申请内存时的方法吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to grow the heap at a hint address.</span></span><br><span class="line"><span class="keyword">for</span> h.arenaHints != <span class="literal">nil</span> &#123;</span><br><span class="line">	hint := h.arenaHints</span><br><span class="line">	p := hint.addr</span><br><span class="line">	<span class="keyword">if</span> hint.down &#123;</span><br><span class="line">		p -= n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line">		<span class="comment">// We can&#x27;t use this, so don&#x27;t ask.</span></span><br><span class="line">		v = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">		<span class="comment">// Outside addressable heap. Can&#x27;t use.</span></span><br><span class="line">		v = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果不相等，则说明 mmap 在建议的地址上没能分配成功</span></span><br><span class="line">	<span class="keyword">if</span> p == <span class="type">uintptr</span>(v) &#123;</span><br><span class="line">		<span class="comment">// Success. Update the hint.</span></span><br><span class="line">		<span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">			p += n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 成功后，hint 的地址也跟着更新</span></span><br><span class="line">		hint.addr = p</span><br><span class="line">		size = n</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时，丢弃这次分配的内存，尝试下一个 arenaHints, 也就是下一个 1T 区间</span></span><br><span class="line">	<span class="comment">// Failed. Discard this hint and try the next.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> This would be cleaner if sysReserve could be</span></span><br><span class="line">	<span class="comment">// told to only return the requested address. In</span></span><br><span class="line">	<span class="comment">// particular, this is already how Windows behaves, so</span></span><br><span class="line">	<span class="comment">// it would simplify things there.</span></span><br><span class="line">	<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">		sysFree(v, n, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	h.arenaHints = hint.next</span><br><span class="line">	h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mmap</code> 的调用都是围绕着 <code>arenaHints</code> 来进行的，并且每次申请成功后都会更新 hint 的 addr，这样就实现了连续增长，直到失败。如果失败了，就从下一个 1TiB 的区间再次开始！</p>
<h2 id="4-g0-堆栈"><a href="#4-g0-堆栈" class="headerlink" title="4. g0 堆栈"></a>4. g0 堆栈</h2><p>看过了普通 goroutine 堆栈的分配之后，再来简要说一下 <code>g0</code> 的堆栈。<code>g0</code> 是个比较特殊的 goroutine 它只是协助 runtime 来执行，但不承载任何执行函数，与普通的用户 goroutine 有所区别。在一定程度上，可以把它类比成操作系统上每个线程的内核栈，每当 runtime 获得控制权的时候就会将堆栈切换到 <code>g0</code> 代表的堆栈上。</p>
<p>go 的 <code>GPM</code> 模型此处不作介绍，建议阅读<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMTgvMDgvc2NoZWR1bGluZy1pbi1nby1wYXJ0Mi5odG1s">Scheduling In Go : Part II - Go Scheduler<i class="fa fa-external-link-alt"></i></span> 来了解并发模型。我们只说其中的 <code>M</code>，每个<code>M</code> 都有一个 <code>g0</code> 堆栈，用于执行 runtime 代码，其中较为特殊的 <code>M0</code> （即 go 进程的主线程，每个 go 程序仅有一个 M0）的 <code>g0</code> 堆栈是通过汇编语言进行初始化的。</p>
<p>我们先来看看 go 程序的入口地址：</p>
<pre>richard@Richard-Manjaro:~ » readelf -h carefree 
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  <span style="color:red">Entry point address:               0x463f20</span>
  Start of program headers:          64 (bytes into file)
  Start of section headers:          456 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         7
  Size of section headers:           64 (bytes)
  Number of section headers:         23
  Section header string table index: 3</pre>

<p>读取 ELF文件头可知，入口地址为<strong>0x463f20</strong>，因为禁用了 cgo，没有动态链接库，所以 Entry point 指示的地址既是程序的入口地址。继续看一下该地址指示的代码：</p>
<pre>richard@Richard-Manjaro:~ » lldb ./carefree 
(lldb) target create "./carefree"
Current executable set to '/home/richard/carefree' (x86_64).
(lldb) image lookup --address 0x463f20
      Address: carefree[0x0000000000463f20] (carefree.PT_LOAD[0]..text + 405280)
      Summary: carefree`<span style="color:red">_rt0_amd64_linux</span>
(lldb) </pre>

<p><code>_rt0_amd64_linux</code> 即为程序的入口，当运行程序时，shell 会 fork 一个子进程出来，之后执行 <code>execve()</code> 系统调用来装载 go 的可执行文件，当内核装载完毕之后，会将 CPU 的程序计数器设置为此入口点，之后 go 程序开始执行。</p>
<p><code>_rt0_amd64_linux</code> 是对 <code>asm_amd64.s</code> 中 <code>runtime·rt0_go</code> 的调用，看一下<code>runtime·rt0_go</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0</span><br><span class="line">	// copy arguments forward on an even stack</span><br><span class="line">	MOVQ	DI, AX		// argc</span><br><span class="line">	MOVQ	SI, BX		// argv</span><br><span class="line">	SUBQ	$(5*8), SP		// 3args 2auto</span><br><span class="line">	ANDQ	$~15, SP</span><br><span class="line">	MOVQ	AX, 24(SP)</span><br><span class="line">	MOVQ	BX, 32(SP)</span><br><span class="line"></span><br><span class="line">	// create istack out of the given (operating system) stack.</span><br><span class="line">	// _cgo_init may update stackguard.</span><br><span class="line">	// 初始化 g0</span><br><span class="line">	MOVQ	$runtime·g0(SB), DI</span><br><span class="line">	LEAQ	(-64*1024+104)(SP), BX</span><br><span class="line">	MOVQ	BX, g_stackguard0(DI)</span><br><span class="line">	MOVQ	BX, g_stackguard1(DI)</span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)</span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)</span><br></pre></td></tr></table></figure>

<p>这段代码设置 <code>g0</code> 堆栈的方式是使用线程堆栈的栈顶指针减少 <code>64KB + 104B</code> 作为 <code>g0</code> 堆栈的低端，当前线程堆栈的栈顶为 <code>g0</code> 堆栈的高端。执行完成后，<code>g0</code> 的堆栈便被初始化为 64KB 了。令人惊讶的是，这居然是在系统线程的 8M 堆栈（Linux 的默认线程堆栈为 8 M）中分配的。</p>
<p>再来看一下其它新建 <code>M</code> 的 <code>g0</code>，go 通过 <code>runtime.newm</code> 来新建操作系统线程，顺藤摸瓜会发现其最终执行的系统调用为 <code>clone</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * note: strace gets confused if we use CLONE_PTRACE here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; clone=&quot;</span>, abi.FuncPCABI0(clone), <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)mp.g0.stack.hi</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable signals during clone, so that the new thread starts</span></span><br><span class="line">	<span class="comment">// with signals disabled. It will enable them in minit.</span></span><br><span class="line">	<span class="keyword">var</span> oset sigset</span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(abi.FuncPCABI0(mstart)))</span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: failed to create new OS thread (have &quot;</span>, mcount(), <span class="string">&quot; already; errno=&quot;</span>, -ret, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> ret == -_EAGAIN &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: may need to increase max user processes (ulimit -u)&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		throw(<span class="string">&quot;newosproc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clone</code> 中堆栈起始地址传入的是 <code>mp.g0.stack.hi</code>，即该 <code>M</code> 的 <code>g0</code> 的堆栈高端地址，看一下 <code>g0</code> 的初始化，相应的代码在 <code>runtime.allocm</code>  中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> iscgo || mStackIsSystemAllocated() &#123;</span><br><span class="line">	mp.g0 = malg(<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	mp.g0 = malg(<span class="number">8192</span> * sys.StackGuardMultiplier)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见后续 <code>g0</code> 分配就是通过 <code>malg</code> 来进行的，该函数我们之前已经介绍过了，此处只要明白分配的堆栈大小为 8K 即可。由此可知，除了 <code>m0</code> 的 <code>g0</code> 在传统的主线程堆栈区域外，后续 <code>M</code> 的堆栈都是分配自 go 堆中，其可能的区域自不待言，我们已在上一节论述过了。</p>
<h2 id="5-goroutine-的堆栈切换"><a href="#5-goroutine-的堆栈切换" class="headerlink" title="5. goroutine 的堆栈切换"></a>5. goroutine 的堆栈切换</h2><p>当 goroutine 被 runtime 调度到 CPU 上时，不仅要将程序计数器设置为该 goroutine 的执行函数地址，而且要切换到该 goroutine 的堆栈上执行后续操作，我们这一节就来看看 goroutine 的堆栈是如何切换的。堆栈的切换和调度密切相关，但此处只讨论和堆栈有关的内容，不再深入调度相关的细节。</p>
<p><code>m0</code> 在初始化好一系列条件之后，会调用 <code>runtime·mstart</code> 从而真正的让 <code>M0</code> 跑起来，后续新建 <code>M</code> 时向 <code>clone</code> 传入的运行函数也是 <code>runtime·mstart</code>，而 <code>runtime·mstart</code> 最终会进入调度函数 <code>runtime.schedule</code>， 而 <code>schedule</code> 的工作就是千方百计的寻找空闲的 G 将它送到 CPU 上运行。当最终找到这个 G 的时候，会调用一段用汇编代码写成的函数 <code>runtime·gogo(buf *gobuf)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// func gogo(buf *gobuf)</span><br><span class="line">// restore state from Gobuf; longjmp</span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $0-8</span><br><span class="line">	MOVQ	buf+0(FP), BX		// gobuf</span><br><span class="line">	MOVQ	gobuf_g(BX), DX</span><br><span class="line">	MOVQ	0(DX), CX		// make sure g != nil</span><br><span class="line">	JMP	gogo&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line">TEXT gogo&lt;&gt;(SB), NOSPLIT, $0</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	DX, g(CX)</span><br><span class="line">	MOVQ	DX, R14		// set the g register</span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	// restore SP</span><br><span class="line">	MOVQ	gobuf_ret(BX), AX</span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX</span><br><span class="line">	MOVQ	gobuf_bp(BX), BP</span><br><span class="line">	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector</span><br><span class="line">	MOVQ	$0, gobuf_ret(BX)</span><br><span class="line">	MOVQ	$0, gobuf_ctxt(BX)</span><br><span class="line">	MOVQ	$0, gobuf_bp(BX)</span><br><span class="line">	MOVQ	gobuf_pc(BX), BX</span><br><span class="line">	JMP	BX</span><br></pre></td></tr></table></figure>

<p><code>runtime·gogo </code> 会调用 <code>gogo</code>，传入的参数是 <code>g</code> 结构体中和调度相关的一个字段 <code>gobuf</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">	sp   <span class="type">uintptr</span></span><br><span class="line">	pc   <span class="type">uintptr</span></span><br><span class="line">	g    guintptr</span><br><span class="line">	ctxt unsafe.Pointer</span><br><span class="line">	ret  <span class="type">uintptr</span></span><br><span class="line">	lr   <span class="type">uintptr</span></span><br><span class="line">	bp   <span class="type">uintptr</span> <span class="comment">// for framepointer-enabled architectures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有程序计数器和堆栈栈顶指针等重要的值，这些值都是该 goroutine 被调度出 CPU 的时候保存进来的，是 goroutine 的执行现场。<code>gogo</code> 会将现场恢复，这包括程序计数器和栈顶，之后这个 goroutine 就又从上次中断的地方跑起来了。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本文以<strong>探求 goroutine 堆栈在进程虚拟地址空间中的位置</strong>为诉求，对源代码进行有目的的展开，并最终找到内存分配的内核接口 <code>mmap</code>。</p>
<p><code>mmap</code> 的使用太过灵活，以至于非要刻板的对应到虚拟内存布局中的位置显得有些棘手，因为 <strong>go 堆</strong> 接管的是整个虚拟内存的用户空间，但我们仍然可以从其内存分配的设计思想中窥得一二。</p>
<p>go 堆的起始位置在用户空间的中段，确切的说是距离起始端 768 GiB 的地方开始，而从用户空间 128 TiB 的角度来看，这远远算不上中间，仅仅是相对于传统 heap 来说的。我想这也是 go 对于历史的一种尊重，好在 64 位模式下虚拟地址空间的跨度足够大，可以做出很灵活的设计。</p>
<p>go 堆把后续的空间划分成了 128 份，几乎每份都有 1TiB 的大小，然后默默地从地址 <code>0x00c000000000</code> 处向上增长，因为<code>00 c0</code> 既不是有效的 UTF8 编码，又有足够的辨识度。</p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjkxMjc2Ny8=">深入理解计算机系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zNjUyMzg4Lw==">程序员的自我修养<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">Linux&#x2F;UNIX系统编程手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80ODQzNTY3Lw==">深入 Linux 内核架构<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgyODc3My8=">Linux 系统编程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9tbWFwLjIuaHRtbA==">mmap<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96Ym95YS5naXRodWIuaW8vcG9zdC9nb19zY2hlZHVsZXIv">深入golang runtime的调度<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vaXNoYXJlL2dvLXNjaGVkdWxlci8=">go-scheduler<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcuZGVzaWduL3VuZGVyLXRoZS1ob29kLw==">Go 语言原本<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvemhpeXVuLmNvbS9hcmNoaXZlcy81MTM=">一文教你搞懂 Go 中栈操作<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvemhpeXVuLmNvbS9hcmNoaXZlcy80MzQ=">详解Go中内存分配源码实现<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMTgvMDgvc2NoZWR1bGluZy1pbi1nby1wYXJ0Mi5odG1s">Scheduling In Go : Part II - Go Scheduler<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2022/03/28/golang/effective-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/golang/effective-go/" class="post-title-link" itemprop="url">另一个 effective go 中文版</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-28 10:08:30" itemprop="dateCreated datePublished" datetime="2022-03-28T10:08:30+08:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>希望能给 Go 后学带来更多有意义的内容</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aA==">effective go 中文版<i class="fa fa-external-link-alt"></i></span> 是我个人的文档轮子。为了帮助需要的人准确理解原文，特采纳中英双语格式，目前翻译初稿已经完成。</p>
<p>互联网上已有 <code>effective go </code> 的中文版，甚至还不止一版，那为什么还要再造这个轮子呢？首先，我个人的初衷是为了锻炼自己的英文理解与翻译水平，同时也能磨砺中文的语言组织能力，更是为了把 go 语言的基础夯实。</p>
<p>其次呢，我在读第一遍英文时，碰到有疑问的地方在中文版里往往得不到想要的答案，后来自己思考也解决了一些疑惑，有些问题呢是出自翻译的问题，比如最后一章有一句话：<em>The program here provides a nicer interface to one form of data: given a short piece of text, it calls on the chart server to produce a QR code, a matrix of boxes that encode the text.</em></p>
<p>冒号之后的内容姑且不论，它是对 <code>a nicer interface</code> 的详细阐述。我们看前半句中的 <code>one form of data</code> 到底指指什么？从字面意思看，或者由翻译软件翻译的话意思应该是：<strong>一种数据类别</strong>。我所见的两个翻译版本分别翻译成了 <strong>一种数据格式</strong> 和 <strong>某种形式的数据</strong>，可见就是照字面翻译，只是为了语句通顺问题，各自进行了调整。但即便是进行了调整，整个句子依然说不通，<strong>此程序为一种数据格式提供了更好的的接口</strong> 其意几何呢？</p>
<p>其实，下文中文档便给出了详细代码，html 的代码中有一个输入表单。我们知道 form 不仅有<strong>形式、类别、种类</strong>的意思，还具有<strong>表格</strong>的意思，并且在前端领域我们习惯于术语<strong>表单</strong>。所以此处分明是<strong>一个数据的表单</strong>之意！再者说，form 之前使用了数量词 <code>one</code> 而非定冠词 <code>a</code> ，我认为这是另一条佐证，这句话的本意是：<strong>本程序为表单数据提供了更加友好的接口</strong>。</p>
<p>除翻译问题外，春秋笔法，微言大义似乎也能造成困扰。<code>effective go</code> 虽为入门级必读资料，其内容算不上艰深，然而某些细微之处，于新手而言并不见得就能轻易领会，所以我在某些地方也注释了自己的心得。这看起来颇有几分古人注书的感觉，只不过我注的内容未必都对，所注条目也不甚多，但总归是自己花了精力的所思所想，相必对有些人有用也未可知，因此闲暇之余，又翻译了一版，很期待各位能够给予斧正。</p>
<p>因初稿未经校对，其中定有不少讹误疏漏之处，希望所有有兴趣的伙伴都能参与进来，不论是书写还是理解上的问题，都欢迎提交 <code>issue</code> 或者 <code>pr</code>，我定我会及时处理。</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDEuSW50cm9kdWN0aW9uLm1k">介绍<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDIuRm9ybWF0dGluZy5tZA==">格式化<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDMuQ29tbWVudGFyeS5tZA==">注释<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDQuTmFtZXMubWQ=">命名<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDUuU2VtaWNvbG9ucy5tZA==">分号<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDYuQ29udHJvbFN0cnVjdHVyZXMubWQ=">控制结构<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDcuRnVuY3Rpb25zLm1k">函数<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDguRGF0YS5tZA==">数据<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMDkuSW5pdGlhbGl6YXRpb24ubWQ=">初始化<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMTAuTWV0aG9kcy5tZA==">方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMTEuSW50ZXJmYWNlcy1hbmQtb3RoZXItdHlwZXMubWQ=">接口和其它类型<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMTIuVGhlLWJsYW5rLWlkZW50aWZpZXIubWQ=">空白标识符<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMTMuRW1iZWRkaW5nLm1k">内嵌<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMTQuQ29uY3VycmVuY3kubWQ=">并发<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMTUuRXJyb3JzLm1k">错误<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2VmZmVjdGl2ZS1nby16aC9ibG9iL21haW4vMTYuQS1XZWJTZXJ2ZXIubWQ=">一个 web 服务<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2022/03/22/golang/writer-availablebuffer-in-bufio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/22/golang/writer-availablebuffer-in-bufio/" class="post-title-link" itemprop="url">go 1.18 bufio 包中的 Writer.AvailableBuffer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-22 10:08:30" itemprop="dateCreated datePublished" datetime="2022-03-22T10:08:30+08:00">2022-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>go 1.18 于近日发布，带来了 go 历史上最大的一次语言级改变——<code>泛型</code>！但本文只聚焦于本次发布中标准库 bufio 包中的一个小小的改变——<strong>Writer.AvailableBuffer</strong>。go 每次版本发布都会伴随着标准库的些许变动，本次发布即在 bufio 包中增加了一个 <code>Writer.AvailableBuffer</code> 方法。</p>
<p>该方法的添加源于一条名为 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvNDc1Mjc=">bufio: add Writer.AvailableBuffer<i class="fa fa-external-link-alt"></i></span> 的 issue。作者认为 go 中很多 appendX 类型的 API 在与 <code>bufio.Writer</code> 一起工作的时候比较低效，原因在于 <code>Write(p []byte) (nn int, err error)</code> 方法只接受 <code>[]byte</code> ，却不向外提供 <code>[]byte</code>。这在一定程度上需要调用者自行分配内存，然后传给 <code>write</code> 使其再进行 <code>copy</code>，所以这里固定有一次内存的 <code>allocation</code> 和 <code>copy</code>。</p>
<p>作者的提议是：由 bufio 的 <code>Writer</code> 向外暴露自己的 buffer 以为 appendx 函数使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AvailableBuffer returns an empty buffer with b.Available capacity.</span></span><br><span class="line"><span class="comment">// This buffer is intended to be appended to and</span></span><br><span class="line"><span class="comment">// passed to an immediately succeeding Write call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> AvailableBuffer() []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.buf[b.n:][:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AvailableBuffer</code> 向外暴露了一个空的 <code>[]byte</code>， 但是其 <code>capacity</code> 是和 <code>Writer</code> 的 buffer 余量相同的，这意味着返回的 <code>[]byte</code> 和 <code>Writer</code> 共享同一个底层数组。那这样做的好处是什么呢？ 其好处就是在理想情况下，能够避免那固有的一次 <code>allocation</code> 和 <code>copy</code>，且看如下示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	w := bufio.NewWriter(os.Stdout)</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="type">int64</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;</span><br><span class="line">		b := w.AvailableBuffer()</span><br><span class="line">		b = strconv.AppendInt(b, i, <span class="number">10</span>)</span><br><span class="line">		b = <span class="built_in">append</span>(b, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		w.Write(b)</span><br><span class="line">	&#125;</span><br><span class="line">	w.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该例循环体内使用的 buffer <code>b</code> 都返回自 <code>AvailableBuffer</code>，此时没有额外的内存分配。理想情况下 append 的 byte 数量不超过 <code>Writer</code> 的 buffer 余量时， copy 会立即返回，因为 <code>b</code> 和 <code>Writer</code> 使用的同一个底层数组，不需要 copy，因此连 copy 的操作都省掉了。</p>
<p>极端情况下，由于 append 的扩张导致 b 的底层数组重新分配，那么 Write 也只是回到了其最初的工作方式。在很大程度上，该调整还是让 <code>Writer</code> 变得高效了不少！</p>
<p>那有什么不好的地方吗？ 唯一缺点应该就是暴露了 <code>bufio.Writer</code> 内部的 <code>buffer</code>。然而该包中的其它类型，诸如 <code>Reader</code>、 <code>Scanner</code> 已经向外提供了 <code>Reader.Peek</code>、 <code>Reader.ReadSlice</code>、以及 <code>Scanner.Bytes</code> 等对底层数组不安全的访问方法，故也不能独怪其罪。至少并没有破坏包的整体风格，而其利弊皆在人之为用！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2021/07/20/theory/stack-insight-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/theory/stack-insight-02/" class="post-title-link" itemprop="url">Stack 顿悟三部曲（2）：穿越虚拟内存的迷雾</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-20 20:30:40" itemprop="dateCreated datePublished" datetime="2021-07-20T20:30:40+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>文中的示例基于 X86_64 体系架构，基于 Linux 内核 5.9.16 版本，汇编语言采用 AT&amp;T 汇编</p>
</blockquote>
<p>在上一篇文章中，我简要介绍了 CPU 执行指令的过程，以及 CPU 如何将一段内存用于 stack。这篇文章会将讨论的重点集中于<strong>进程的内存布局</strong>上面，因为要搞明白 stack 的运作原理，必然要知晓 stack 在内存中分配的位置。而谈到位置，必然绕不开虚拟内存。</p>
<p>图 2-1 描述了一个 Linux 进程的虚拟内存布局，类似的布局图已经充斥于互联网的每个角落，虽形态各异，但描述的内容大抵相同。这张图我引用自 <span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjkxMjc2Ny8=">深入理解计算机系统.第三版<i class="fa fa-external-link-alt"></i></span>，是一个比较详尽且权威的图（以后的文章中会经常出现此书，这是一本每个程序员必读的书）：</p>
<p><img data-src="https://qiniu.liupzmin.com/virtual-memory-of-a-linux-process.png" alt="图 2-1 Linux 进程的虚拟内存布局"></p>
<p>这张图是进程的内存视角，从图中可知，进程虚拟内存的地址空间被分成两大部分：<strong>用户空间</strong>（<strong>Process virtual memory</strong>，也被称为<strong>user space</strong>）和 <strong>内核空间</strong>（<strong>Kernel virtual memory</strong>，也被称为<strong>kernel space</strong>）。每个进程拥有相同的<code>用户空间</code>视图（但彼此隔离），共享部分<strong>内核空间</strong>（如内核代码，图中的<strong>Identical for each process</strong>部分）。内核空间的另一部分是每个进程私有的， 如进程的内核堆栈、页表等。每个进程在内核空间都会有一块这样的私有区域（图中的<strong>Different for each process</strong>部分）。</p>
<p>这样的内存空间布局会在你的脑海里形成怎样的影像呢？</p>
<p>想象一下香蕉皮的样子🍌~，我心中虚拟内存地址空间的立体模型就是下面这个样子：</p>
<p><img data-src="https://qiniu.liupzmin.com/BananaPeel.jpeg" alt="图 2-2 Linux 进程地址空间形象图"></p>
<p>如果你尚未被<strong>进程地址空间布局</strong>折磨过，那图 2-1 或许会让你眼前一亮。你或许以为自己终于发现了事情的本质，但事实远没有那么简单。在陷入泥潭不能自拔之前，我们不妨先扪心自问一下：<strong>程序或者说进程为什么需要这样的虚拟内存抽象呢？</strong></p>
<p>不妨让时光倒流，回到上个世纪70年代去，回到大型机落幕、小型机兴起的时代去，回到个人计算机开始萌芽的时代去，回到计算机先辈们为之奋斗的精彩纷呈的那个时代去......</p>
<h2 id="1-为什么需要虚拟内存"><a href="#1-为什么需要虚拟内存" class="headerlink" title="1. 为什么需要虚拟内存"></a>1. 为什么需要虚拟内存</h2><p>计算机的洪荒时代是没有内存抽象的，比如早期的大型机、小型机以及最早的个人计算机，它们都没有如今我们习以为常的虚拟内存抽象。没有抽象的直观表现就是：<strong>程序直接访问物理内存</strong>，比如我在上一篇文章中以 8086 演示汇编指令的示例，示例中对内存的访问就是直接操纵物理内存。</p>
<p>在<strong>简单批处理时代</strong>，直接访问物理内存并没有任何不妥。人们把二进制程序制成穿孔卡，有专门的人员将穿孔卡输入计算机运行。彼时计算机一次只能处理一个任务，每个任务运行时内存被其独占，各个程序也就相安无事。</p>
<p>但由于当时的计算机非常昂贵，人们很自然地想要减少这种浪费。在计算机的体系结构里，IO 设备和 CPU 是两种独立运行的部件，一个程序在进行 IO 的时候，CPU 往往无事可干。这当然是一种不能容忍的浪费，更何况任务的接续是由人来进行干预的。为了解决作业切换需要人员干预而造成的 CPU 浪费问题，人们改良了作业的运行机制，使得计算机在运行完一件作业之后可以自动的载入下一个作业，这就是真正的<strong>批处理时代</strong>。</p>
<p>然而，批处理并没有解决作业在进入 IO 等待时 CPU 的闲置问题，如果一个程序在等待 IO 完成，那么何不将下一个程序调入内存来执行呢？于是计算机便进入了<strong>多道程序（multiprogramming）时代</strong>。图 2-3 展示了三个作业同驻内存的情况：</p>
<p><img data-src="https://qiniu.liupzmin.com/mulitiprogram.png" alt="图 2-3 一个内存中有3个作业的多道程序系统"></p>
<p>这种解决方案将内存分为几个部分，每个部分存放不同的作业，当一个作业在等待 I&#x2F;O 完成时，另一个作业就可以使用 CPU。假如内存足够大，就可以容纳所需的全部任务，而 CPU 也就可以达到 100% 的利用率。</p>
<p>但在那个内存以 KB 计算，动辄几百美元的时代，这种假设也只能是天方夜谭。于是聪明的先驱们发明了<strong>交换技术</strong>，交换技术是解决内存超载的方法，即把一个进程完整的调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲的进程主要存储在磁盘上，因此一个进程不运行就不会占用内存，图 2-4 展示了随时间流逝内存分配的情况：</p>
<p><img data-src="https://qiniu.liupzmin.com/mulitiprogramming.png" alt="图 2-4 内存分配情况随着进程进出而变化"></p>
<p>开始时内存中只有进程 A，之后创建进程 B 和 C。当 D 需要运行的时候，由于内存已经不足以容纳 D，A 即被交换到磁盘，D 装入内存。之后 B 运行完毕被调出，A 又被调入，但 A 的位置较之前发生了改变，所以在其被调入内存时需要特殊的手段对其进行重定位，比如我们之前介绍的段寄存器就适用于这种场景，代码段和堆栈段的寄存器都需要修改。</p>
<p>多道程序增加了计算机的利用率，提高了作业处理效率。很快，人们对计算机的要求变得更多，比如程序员们厌倦了较长周期的开发-调试循环，<strong>交互性</strong>变得更加迫切，因为许多用户可能在同时使用机器，每个人都在等待他们执行的任务及时响应。计算机便进入了<strong>分时共享</strong>时代。</p>
<p><strong>分时共享系统</strong>其实是多道程序系统的变体，在分时系统中假设有 20 个用户登录，其中有17个在思考或者在喝咖啡，那么 CPU 就可以分配给其它 3 个需要的作业来轮流执行。由于调试程序的用户常常只发出简短的命令，很少有长的费时的指令，所以计算机能够为许多用户提供快速的交互式的服务。对每个用户来讲，计算机就像是他们独占一样。而此时，计算机还有余力在后台运行批量作业。</p>
<p>第一个通用的分时系统是 **CCTS (Compatible Time Sharing System)**，它于 1962 年由 MIT（麻省理工学院）在一台改装过的 7094 大型机上开发出来。但直到第三代计算机广泛采用了必须的保护硬件之后，分时系统才逐渐流行开来。</p>
<p>系统中的所有进程共享 CPU 和主存，这本身就是对操作系统内核的巨大挑战。如果其中的某些进程需要太多的内存，那么有可能就无法运行；如果某个进程不小心写了另一个进程的内存，程序便会出现某些迷惑的 BUG；甚至操作系统内核也暴露在这种风险之下，也许在某个时候整个机器就会莫名其妙的停止运行。所以现代的操作系统都提供了一种对主存的抽象，叫做<strong>虚拟内存</strong>。</p>
<h2 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2. 虚拟内存"></a>2. 虚拟内存</h2><p><em><strong>虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。</strong></em></p>
<p>这是  <span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjkxMjc2Ny8=">深入理解计算机系统.第三版<i class="fa fa-external-link-alt"></i></span> 中对于虚拟内存的定义，简明扼要！</p>
<p>虚拟内存提供了三个重要的能力：</p>
<ol>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中仅保存活动的区域，并根据需要在磁盘和主存之间来回传送数据。</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其他程序破坏。</li>
</ol>
<p>顾名思义，虚拟内存其地址是虚拟的，不是真实的物理地址。你在程序中打印出的地址以及在 Linux <code>/proc/&#123;pid&#125;/maps</code>中看的地址都是虚拟地址。图 2-5 给出了虚拟寻址的过程：</p>
<p><img data-src="https://qiniu.liupzmin.com/virtual-addressing.png" alt="图 2-5 虚拟寻址"></p>
<p>在虚拟寻址系统中，传送给 CPU 的是虚拟地址，CPU 在访问内存之前，需要将这个虚拟地址转换为物理地址。事实上，这一转换动作是依靠另一种单独的硬件来完成的，将虚拟地址转换为物理地址的过程被称为<strong>地址翻译（address translation）</strong>。而负责地址翻译的专用硬件叫做内存管理单元，即图中的 <strong>MMU(Memory Management Unit)</strong> 。</p>
<p>当 MMU 完成地址翻译之后，真实的物理地址便被送入地址总线到达主存，随后相关的数据就会经数据总线读入 CPU 寄存器或由寄存器写入内存当中。当然，MMU 并不能凭空将虚拟地址翻译为物理地址，它需要一个叫做<strong>页表</strong>的内存结构的辅助。</p>
<p>虚拟内存系统将虚拟地址空间中固定大小的块分隔为虚拟页，将物理内存分割为物理页。虚拟内存所作的主要工作就是处理虚拟页和内存页之间的映射，虚拟页有3种状态：</p>
<ol>
<li>未分配：程序尚未用到（比如尚未执行到的代码片段所在页），VM 系统尚未创建此页。那么这种未分配的页没有任何数据相关联，更不会在物理内存中</li>
<li>缓存的：程序已经使用的页，并且 VM 已分配且已经驻留在物理内存中</li>
<li>未缓存的：程序用过，VM 已经分配，但此刻不在物理内存中（已被交换到文件或者交换到磁盘上的交换空间中）</li>
</ol>
<p><img data-src="https://qiniu.liupzmin.com/vp-pp.png" alt="图 2-6 一个 VM 系统是如何使用主存作为缓存的"></p>
<p>图 2-6 展示了一个有 8 个虚拟页的小虚拟内存。虚拟页 0 和 3 还没有被分配，1、4、6 已经被缓存在物理内存中，2、5、7 已经被分配了，但是当前并不在主存中，已经被交换到文件或者 swap 空间中去了。</p>
<p>虚拟系统必须用某种方式记录下这层映射关系以及缓存与否，否则地址翻译便不能工作。用于记录映射关系与缓存有效情况的内存结构叫做<strong>页表（page table）</strong>，它位于进程内核空间的进程私有区域，可参见图 2-1 进程空间布局视图。</p>
<p>本文并不想介绍<strong>页表</strong>的工作原理，这超出了文章的讨论范围。此处读者只需要明白页表的作用即可：<strong>为地址翻译提供帮助。</strong>页表相关内容可以参考任意一本介绍操作系统的书籍。</p>
<p>上述组织内存的方式被称为<strong>分页</strong>，事实上还有一种方式叫做分段，先将内存分段，再将这段内存分页，可以想见其复杂性。有必要指出的是第一个实现了分段加分页的操作系统是大名鼎鼎的 <strong>MULTICS</strong>。</p>
<p> <strong>MULTICS</strong> 是有史以来最具影响力的操作系统之一，每一个 Unix 爱好者都曾闻其大名。它始于麻省理工学院的一个研究项目，其设计者着眼于建造一台满足整个波士顿地区所有用户计算需求的机器。除了 MIT 还有贝尔实验室以及通用电气公司参与。然而项目的难度远远超出了人们的预料，贝尔实验室退出了，通用电气公司也退出了，最后只有 MIT 坚持了下来。系统最后于 1969 年上线，在运行了 31 年后于 2000 年关闭。</p>
<p>几乎没有系统能像  <strong>MULTICS</strong>  一样没有修改地持续运行 31 年之久，尽管  <strong>MULTICS</strong>  在商业上失败了，但其许多原创的概念却散布于各种计算机文献。它的设计思想也经由 Ken Thompson 传承给了 Unix，一度催动了 C 语言的蓬勃发展，而 C 和 Unix 又反过来深深影响了后来的 Linux。</p>
<p>在 <strong>MULTICS</strong> 的这一波影响下，Intel 也未能幸免。 <strong>MULTICS</strong> 分段的思想在 X86 处理器上得到了继承，我们上篇提到的段寄存器便是受此影响的产物。换言之，8086 段设计的一部分思想来源于 <strong>MULTICS</strong>，并不完全是因为寄存器大小限制而催生的奇思妙想。虽然 x86-64 架构下仍有分段机制的某些痕迹，但正如上篇所言，这大多数情况下只是为了兼容。</p>
<p>那么，Intel 为什么要剔除它支持了近 30 年，且源自表现良好的 <strong>MULTICS</strong> 存储模型的变形体呢？</p>
<p>或许是因为 Unix 和 Windows 都不曾真正的使用过该模型！</p>
<h2 id="3-线程堆栈"><a href="#3-线程堆栈" class="headerlink" title="3. 线程堆栈"></a>3. 线程堆栈</h2><h3 id="3-1-stack-在哪儿-？"><a href="#3-1-stack-在哪儿-？" class="headerlink" title="3.1 stack 在哪儿 ？"></a>3.1 stack 在哪儿 ？</h3><p>经过上面的铺垫，终于可以聊一聊进程地址空间中的 stack 了。那么，stack 在进程地址空间中的什么位置呢？从图 2-1 来看，答案似乎显而易见：<strong>stack 开始于用户空间的顶端，从高地址向低地址增长</strong>。而作为动态增长的内存区域，<strong>heap 排在代码段、数据段和 bss 段之上，由低地址向高地址增长，与 stack 遥相呼应，相对增长。</strong>为了方便对照，此处再贴一次进程的地址空间布局，如图 2-7 ：</p>
<p><img data-src="https://qiniu.liupzmin.com/virtual-memory-of-a-linux-process.png" alt="图 2-7 Linux 进程的虚拟内存布局"></p>
<p>x86_64 架构下 Linux 平台二进制可执行文件的代码段总是从地址的 <code>0x40000</code> 处开始，这是在链接阶段就决定的。但是如果你在稍微新一点的 Linux 上去做测试的话，代码段的起始地址很大程度上并不是从 <code>0x40000</code> 处开始，它似乎是一个随机的值。比如，我用下面一个简单的 C 程序来观察其地址空间的分布：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc demo.c</code>来编译为<code>a.out</code>，并运行。之后获取其进程号，查看<code>/proc/&#123;pid&#125;/maps</code>中的内容来观察地址空间的映射情况，如 表 2-1 ：</p>
<pre>~/play/c ➭ cat /proc/2231/maps 
<span style="color:red">56487f376000-56487f377000 r--p 00000000 103:02 7093179                   /home/richard/play/c/a.out</span>
56487f377000-56487f378000 r-xp 00001000 103:02 7093179                   /home/richard/play/c/a.out
56487f378000-56487f379000 r--p 00002000 103:02 7093179                   /home/richard/play/c/a.out
56487f379000-56487f37a000 r--p 00002000 103:02 7093179                   /home/richard/play/c/a.out
56487f37a000-56487f37b000 rw-p 00003000 103:02 7093179                   /home/richard/play/c/a.out
56487fbc6000-56487fbe7000 rw-p 00000000 00:00 0                          [heap]
7f593eb72000-7f593eb74000 rw-p 00000000 00:00 0 
7f593eb74000-7f593eb9a000 r--p 00000000 103:02 4859211                   /usr/lib/libc-2.33.so
7f593eb9a000-7f593ece5000 r-xp 00026000 103:02 4859211                   /usr/lib/libc-2.33.so
7f593ece5000-7f593ed31000 r--p 00171000 103:02 4859211                   /usr/lib/libc-2.33.so
7f593ed31000-7f593ed34000 r--p 001bc000 103:02 4859211                   /usr/lib/libc-2.33.so
7f593ed34000-7f593ed37000 rw-p 001bf000 103:02 4859211                   /usr/lib/libc-2.33.so
7f593ed37000-7f593ed42000 rw-p 00000000 00:00 0 
7f593ed6f000-7f593ed70000 r--p 00000000 103:02 4859198                   /usr/lib/ld-2.33.so
7f593ed70000-7f593ed94000 r-xp 00001000 103:02 4859198                   /usr/lib/ld-2.33.so
7f593ed94000-7f593ed9d000 r--p 00025000 103:02 4859198                   /usr/lib/ld-2.33.so
7f593ed9d000-7f593ed9f000 r--p 0002d000 103:02 4859198                   /usr/lib/ld-2.33.so
7f593ed9f000-7f593eda1000 rw-p 0002f000 103:02 4859198                   /usr/lib/ld-2.33.so
<span style="color:red">7ffcf3aea000-7ffcf3b0b000 rw-p 00000000 00:00 0                          [stack]</span>
7ffcf3ba2000-7ffcf3ba6000 r--p 00000000 00:00 0                          [vvar]
7ffcf3ba6000-7ffcf3ba8000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</pre>

<p align="center">表2-1 进程的内存布局映射</p>

<p>可见，其代码段的起始地址为<code>56487f376000</code>，stack 段的其实地址为<code>7ffcf3b0b000</code>，如果多观察几次，每次的地址都不相同。</p>
<p>这其实归根于 Linux 在 2.6.12 之后加入的<strong>地址空间布局随机化（Address space layout randomization，缩写ASLR）</strong>，ASLR 的目的是为了安全，要禁用它，只需执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>并且在使用<code>gcc</code>编译时加入<code>-no-pie</code>选项，然后再观察其内存布局，这一次我们直接观察proc中的maps：</p>
<pre>~/play/c ➭ cat /proc/5206/maps
<span style="color:red">00400000-00401000 r--p 00000000 103:02 7095689                           /home/richard/play/c/a.out</span>
00401000-00402000 r-xp 00001000 103:02 7095689                           /home/richard/play/c/a.out
00402000-00403000 r--p 00002000 103:02 7095689                           /home/richard/play/c/a.out
00403000-00404000 r--p 00002000 103:02 7095689                           /home/richard/play/c/a.out
00404000-00405000 rw-p 00003000 103:02 7095689                           /home/richard/play/c/a.out
00405000-00426000 rw-p 00000000 00:00 0                                  [heap]
7ffff7dca000-7ffff7dcc000 rw-p 00000000 00:00 0 
7ffff7dcc000-7ffff7df2000 r--p 00000000 103:02 4859211                   /usr/lib/libc-2.33.so
7ffff7df2000-7ffff7f3d000 r-xp 00026000 103:02 4859211                   /usr/lib/libc-2.33.so
7ffff7f3d000-7ffff7f89000 r--p 00171000 103:02 4859211                   /usr/lib/libc-2.33.so
7ffff7f89000-7ffff7f8c000 r--p 001bc000 103:02 4859211                   /usr/lib/libc-2.33.so
7ffff7f8c000-7ffff7f8f000 rw-p 001bf000 103:02 4859211                   /usr/lib/libc-2.33.so
7ffff7f8f000-7ffff7f9a000 rw-p 00000000 00:00 0 
7ffff7fc7000-7ffff7fcb000 r--p 00000000 00:00 0                          [vvar]
7ffff7fcb000-7ffff7fcd000 r-xp 00000000 00:00 0                          [vdso]
7ffff7fcd000-7ffff7fce000 r--p 00000000 103:02 4859198                   /usr/lib/ld-2.33.so
7ffff7fce000-7ffff7ff2000 r-xp 00001000 103:02 4859198                   /usr/lib/ld-2.33.so
7ffff7ff2000-7ffff7ffb000 r--p 00025000 103:02 4859198                   /usr/lib/ld-2.33.so
7ffff7ffb000-7ffff7ffd000 r--p 0002d000 103:02 4859198                   /usr/lib/ld-2.33.so
7ffff7ffd000-7ffff7fff000 rw-p 0002f000 103:02 4859198                   /usr/lib/ld-2.33.so
<span style="color:red">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span>
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</pre>

<p align="center">表2-2 无地址随机的进程内存布局映射</p>

<p>可见，代码段的起始位置已经是固定的<code>00400000</code>，stack 段的起始地址为固定的<code>7ffffffff000</code>了。</p>
<p>值得注意的是：在不开启地址随机的情况下，stack 的起始地址位于<strong>用户空间最高地址 - 4k</strong> 处，即0x7ffffffff000<code>。用户空间的最高地址是</code>00007fffffffffff，即用户空间有 128TB 大小，Linux 文档 <span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi94ODYveDg2XzY0L21tLnR4dA==">mm<i class="fa fa-external-link-alt"></i></span> 描述了x86_64 架构下的内存空间布局，如表 2-3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">====================================================</span><br><span class="line">Complete virtual memory map with 4-level page tables</span><br><span class="line">====================================================</span><br><span class="line"></span><br><span class="line">Notes:</span><br><span class="line"></span><br><span class="line"> - Negative addresses such as &quot;-23 TB&quot; are absolute addresses in bytes, counted down</span><br><span class="line">   from the top of the 64-bit address space. It&#x27;s easier to understand the layout</span><br><span class="line">   when seen both in absolute addresses and in distance-from-top notation.</span><br><span class="line"></span><br><span class="line">   For example 0xffffe90000000000 == -23 TB, it&#x27;s 23 TB lower than the top of the</span><br><span class="line">   64-bit address space (ffffffffffffffff).</span><br><span class="line"></span><br><span class="line">   Note that as we get closer to the top of the address space, the notation changes</span><br><span class="line">   from TB to GB and then MB/KB.</span><br><span class="line"></span><br><span class="line"> - &quot;16M TB&quot; might look weird at first sight, but it&#x27;s an easier to visualize size</span><br><span class="line">   notation than &quot;16 EB&quot;, which few will recognize at first sight as 16 exabytes.</span><br><span class="line">   It also shows it nicely how incredibly large 64-bit address space is.</span><br><span class="line"></span><br><span class="line">========================================================================================================================</span><br><span class="line">    Start addr    |   Offset   |     End addr     |  Size   | VM area description</span><br><span class="line">========================================================================================================================</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0000000000000000 |    0       | 00007fffffffffff |  128 TB | user-space virtual memory, different per mm</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0000800000000000 | +128    TB | ffff7fffffffffff | ~16M TB | ... huge, almost 64 bits wide hole of non-canonical</span><br><span class="line">                  |            |                  |         |     virtual memory addresses up to the -128 TB</span><br><span class="line">                  |            |                  |         |     starting offset of kernel mappings.</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Kernel-space virtual memory, shared between all processes:</span><br><span class="line">____________________________________________________________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> ffff800000000000 | -128    TB | ffff87ffffffffff |    8 TB | ... guard hole, also reserved for hypervisor</span><br><span class="line"> ffff880000000000 | -120    TB | ffff887fffffffff |  0.5 TB | LDT remap for PTI</span><br><span class="line"> ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br><span class="line"> ffffc88000000000 |  -55.5  TB | ffffc8ffffffffff |  0.5 TB | ... unused hole</span><br><span class="line"> ffffc90000000000 |  -55    TB | ffffe8ffffffffff |   32 TB | vmalloc/ioremap space (vmalloc_base)</span><br><span class="line"> ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole</span><br><span class="line"> ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base)</span><br><span class="line"> ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole</span><br><span class="line"> ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory</span><br><span class="line">__________________|____________|__________________|_________|____________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Identical layout to the 56-bit one from here on:</span><br><span class="line">____________________________________________________________|____________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole</span><br><span class="line">                  |            |                  |         | vaddr_end for KASLR</span><br><span class="line"> fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping</span><br><span class="line"> fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole</span><br><span class="line"> ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks</span><br><span class="line"> ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole</span><br><span class="line"> ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space</span><br><span class="line"> ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole</span><br><span class="line"> ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0</span><br><span class="line"> ffffffff80000000 |-2048    MB |                  |         |</span><br><span class="line"> ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space</span><br><span class="line"> ffffffffff000000 |  -16    MB |                  |         |</span><br><span class="line">    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset</span><br><span class="line"> ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI</span><br><span class="line"> ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br></pre></td></tr></table></figure>

<p align="center">表2-3 x86_64 下 Linux 48 bit 地址空间</p>

<p>可以简单的用图 2-8 来表示空间的跨度，其中最高位的 128 TB 是留给内核空间的，低 128 TB 则属于用户空间，stack 起始地址紧随用户空间顶部。由于 <code>ASLR</code>的原因，其真实的地址会随机进行偏移。</p>
<p><img data-src="https://qiniu.liupzmin.com/mm.jpg" alt="mm"></p>
<p>那么，<strong>stack 会增长到多大呢？</strong>这个问题似乎跟体系结构和操作系统有很大的关系，各类书籍不仅没有定论，甚至含糊其词，更没有一个可以让你一览无遗的列表清单。但我们似乎可以根据 Linux 来窥视一二。</p>
<p>从图 2-7 中可以看到，<code>stack</code> 和 <code>heap</code>之间还夹着一块**内存映射区域(mmap)**，且 Linux 下可以使用 <strong>ulimit -s size</strong> 来设置 stack 的大小。问题开始变得有些复杂，因为 mmap 区域的起点要根据 stack 的大小来进行计算，但 stack 的大小似乎可以任意指定，甚至可以设置为无限。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80ODQzNTY3Lw==">深入 Linux 内核架构<i class="fa fa-external-link-alt"></i></span> 在其<strong>第 4 章：进程虚拟内存</strong> 的 246 页指出：<strong>可以根据栈的最大长度，来计算栈最低的可能位置，以用作 mmap 区域的起始点。但内核会确保 stack 至少跨越 128 MiB 的空间。另外，如果指定的栈界限非常巨大，那么内核会保证至少有一小部分地址空间不会被占据。</strong></p>
<p>书中的论断于当今的 Linux 内核是否仍适用，我目前也无从证明，但这已无关紧要。<strong>进程的虚拟地址空间布局</strong>也经过多次变迁，我们如今讨论的默认空间布局想来也不会一成不变。但 Linux 内核志在为用户呈现虚拟内存抽象的思想已可见一斑。可以肯定的是，它一定在繁芜的细节上做了大量细致的工作，才有了用户空间代码使用内存时的举重若轻。</p>
<h3 id="3-2-stack-能长到多大-？"><a href="#3-2-stack-能长到多大-？" class="headerlink" title="3.2 stack 能长到多大 ？"></a>3.2 stack 能长到多大 ？</h3><p>要验证 stack 能长多大，说来也很容易，下面这段 C 代码就可以探测到 stack 的边界：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	 <span class="type">void</span> *y;</span><br><span class="line">	 y = alloca(<span class="number">128</span>);</span><br><span class="line">	 a += <span class="number">128</span>;</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;\nStack Size = %ld&quot;</span>, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码在死循环中不断地从 stack 上申请<code>128</code>字节的空间并打印出当前已申请空间的大小，编译运行之，程序会在栈溢出时终止。令人意外的是，收到的错误并不是意料中的<code>stack overflow</code>，而是<code>segmentation fault (core dumped)</code>。</p>
<p>其实，**Stack overflow is [a] cause, segmentation fault is the result.**，详见<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjY4NTQxMy93aGF0LWlzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tYS1zZWdtZW50YXRpb24tZmF1bHQtYW5kLWEtc3RhY2stb3ZlcmZsb3c=">What is the difference between a segmentation fault and a stack overflow?<i class="fa fa-external-link-alt"></i></span></p>
<p>这段代码探测到的 stack 大小在我的 Linux 内核 5.9.16 版本上是受 <strong>ulimit</strong> 控制的。那么，如果不对其设限，是否会碰撞到 mmap 区域，甚至 heap 区域呢？</p>
<p>执行<code>ulimit -s unlimited</code>之后再来运行程序，会发现程序使用的内存一路飙升，用完了 16 GB的内存后，又填满了 16GB 的 swap 空间，最后 OOM 被内核杀死。</p>
<p>是的，回忆一下图 2-8 ，用户空间有 128 TB 的大小呢，我的弱机并不配去探测极限🤣！</p>
<h3 id="3-3-其他线程的-stack-呢-？"><a href="#3-3-其他线程的-stack-呢-？" class="headerlink" title="3.3 其他线程的 stack 呢 ？"></a>3.3 其他线程的 stack 呢 ？</h3><p>似乎有些东西被我们遗忘了，一直以来我们都是在测试主线程的 stack，那其它的线程呢？</p>
<p>图 2-8 表示的内存布局看起来非常完美，<code>stack</code> 和 <code>heap</code> 相对增长，各自都有充裕的空间可以使用，何况大多数情况下 <code>stack</code> 并不会增长太大。因此，<strong>48 bit</strong>的寻址空间即便在中间又加入了 <code>mmap</code> 区域的情况下依旧可以处之泰然。</p>
<p>我们还没有介绍 <code>mmap</code> 区域，此处只需要知道 mmap 区域用于<code>私有文件映射</code>、<code>私有匿名映射</code>、<code>共享文件映射</code>、<code>共享匿名映射</code>即可。需要指出的是，在默认的虚拟内存地址空间布局下<code>mmap</code> 区域是和<code>heap</code>相对增长的，如图 2-9 所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/mmap-region.png" alt="图2-9 mmap 区域自顶向下扩展"></p>
<p>同时，从表 2-1 和 2-2 可以推出：stack 和 mmap 之间分别有 654 GiB 和 128 MiB，mmap 和 heap 之间占据了用户空间的绝大部分。如果我们不限制 stack 的大小，再来看一看布局情况。先执行<code>ulimit -s unlimited</code>，再来执行下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存布局见表 2-4：</p>
<pre>~/play/c ➭ cat /proc/6612/maps
00400000-00401000 r--p 00000000 103:02 7096036                           /home/richard/play/c/getchar
00401000-00402000 r-xp 00001000 103:02 7096036                           /home/richard/play/c/getchar
00402000-00403000 r--p 00002000 103:02 7096036                           /home/richard/play/c/getchar
00403000-00404000 r--p 00002000 103:02 7096036                           /home/richard/play/c/getchar
00404000-00405000 rw-p 00003000 103:02 7096036                           /home/richard/play/c/getchar
<span style="color:green">00405000-00426000 rw-p 00000000 00:00 0                                  [heap]</span>
155555321000-155555323000 rw-p 00000000 00:00 0 
155555323000-155555349000 r--p 00000000 103:02 4859211                   /usr/lib/libc-2.33.so
155555349000-155555494000 r-xp 00026000 103:02 4859211                   /usr/lib/libc-2.33.so
155555494000-1555554e0000 r--p 00171000 103:02 4859211                   /usr/lib/libc-2.33.so
1555554e0000-1555554e3000 r--p 001bc000 103:02 4859211                   /usr/lib/libc-2.33.so
1555554e3000-1555554e6000 rw-p 001bf000 103:02 4859211                   /usr/lib/libc-2.33.so
1555554e6000-1555554f1000 rw-p 00000000 00:00 0 
15555551e000-155555522000 r--p 00000000 00:00 0                          [vvar]
155555522000-155555524000 r-xp 00000000 00:00 0                          [vdso]
155555524000-155555525000 r--p 00000000 103:02 4859198                   /usr/lib/ld-2.33.so
155555525000-155555549000 r-xp 00001000 103:02 4859198                   /usr/lib/ld-2.33.so
155555549000-155555552000 r--p 00025000 103:02 4859198                   /usr/lib/ld-2.33.so
155555552000-155555554000 r--p 0002d000 103:02 4859198                   /usr/lib/ld-2.33.so
<span style="color:orange">155555554000-155555556000 rw-p 0002f000 103:02 4859198                   /usr/lib/ld-2.33.so</span>
<span style="color:red">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span>
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</pre>

<p align="center">表2-4 进程的地址映射表</p>

<p>可见，<code>stack</code> 和 <code>mmap</code> 之间有 106TiB 之大，<code>heap</code> 和 <code>mmap</code>之间仅剩 21TiB 的大小。</p>
<p>作为一个未曾充分使用过 C 语言的人，我看遍了所有的虚拟内存地址空间布局图之后，脑海中对于 <code>stack</code> 和 <code>heap</code> 的位置早已烂熟于胸。这也自然而然让我产生了思维定式：我以为线程所有的 stack 都是在这些布局图所示的 stack 位置上分配的。</p>
<p>然而事实并非如此，这些图的产生也有其历史原因。依我推测，它们大多是成图于线程概念出现之前，而线程出现之后，其内存布局并未在图中充分的体现，让我们来看<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMzQ2MzkzMC8=">操作系统导论<i class="fa fa-external-link-alt"></i></span>中的一句话：</p>
<p><em><strong>不是地址空间中只有一个栈，而是每个线程都有一个栈 ...... 你可能注意到，多个栈也破坏了地址空间的美感。以前堆和栈可以互不影响地增长，直到空间耗尽。多个栈就没有这么简单了。幸运的是，通常栈不会很大。</strong></em></p>
<p>细细体悟，此处<strong>破坏了空间布局美感</strong>背后的深意：即<strong>后续的线程 stack 可以在很多地方分配，包括 <code>heap</code> 和 <code>mmap</code> 区域。</strong></p>
<p>除了<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMzQ2MzkzMC8=">操作系统导论<i class="fa fa-external-link-alt"></i></span>中这蜻蜓点水的一句之外，就没有其它的权威资料来说明这一点了么？</p>
<p>还真有，而且还被我找到了😉。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">TLPI<i class="fa fa-external-link-alt"></i></span> 第 29.1 节展示了同时执行 4 个线程的进程，美中不足的是这幅图是基于 32 位地址空间的，如图 2-10 所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/multiple-threads-stack.png" alt="图 2-10：同时执行 4 个线程的进程"></p>
<p>主线程的 stack 位于我们熟知的内存布局的 stack 区域，而其余 3 个线程的栈位于 mmap 区域。事实上，<strong>使用 <code>Pthread</code>线程库来创建线程的时候，对于线程 stack 的分配就是使用的 <code>mmap</code> 系统调用，其位置也必然位于 mmap 区域内。</strong></p>
<p>然而，Pthread 创建线程使用的是 <code>clone</code> 系统调用，而 clone 系统调用需要使用者自行传入一个内存区域以用作该线程的 stack。我们可以看一下文档中使用 clone 创建子进程的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate memory to be used for the stack of the child. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> = mmap(<span class="literal">NULL</span>, STACK_SIZE, PROT_READ | PROT_WRITE,</span><br><span class="line">             MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span> == MAP_FAILED)</span><br><span class="line">   errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">stackTop = <span class="built_in">stack</span> + STACK_SIZE;  <span class="comment">/* Assume stack grows downward */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create child that has its own UTS namespace;</span></span><br><span class="line"><span class="comment">   child commences execution in childFunc(). */</span></span><br><span class="line"></span><br><span class="line">pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">&quot;clone&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;clone() returned %jd\n&quot;</span>, (<span class="type">intmax_t</span>) pid);</span><br></pre></td></tr></table></figure>

<p>可见子进程的 stack 并没有使用传统意义上主线程使用的 stack 区域，而是使用<code>mmap</code> 在内存映射区域开辟了一块内存用于 stack。既然是自行传入的，那是不是就说明可以把 heap 中的一块内存当作线程的 stack 来用呢？恰好 Pthread 也提供自行设置 stack 的接口，那么，不妨来试试吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">start_thread</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">long</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">  <span class="type">void</span> *y;</span><br><span class="line">	y = alloca(<span class="number">1024</span>);</span><br><span class="line">	a += <span class="number">1024</span>;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;\nStack Size = %ld&quot;</span>, a);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="type">pthread_t</span> thing1, pattr;</span><br><span class="line">  <span class="type">pthread_attr_t</span> tattr;</span><br><span class="line">  <span class="type">void</span> *stackbase;</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 heap 总申请 100KiB 的内存</span></span><br><span class="line">  <span class="type">long</span> size = <span class="number">100</span> * <span class="number">1024</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">    ptr = (<span class="type">void</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stackbase = (<span class="type">void</span> *) <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc address: %p\n&quot;</span>,stackbase);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const char *message = &quot;ThingHive&quot;;</span></span><br><span class="line">	</span><br><span class="line">  pthread_attr_init(&amp;tattr);</span><br><span class="line">  pthread_attr_setstack(&amp;tattr, stackbase, size);</span><br><span class="line">  <span class="comment">// 自定义 stack 线程</span></span><br><span class="line">  pthread_create(&amp;pattr, &amp;tattr, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 默认线程</span></span><br><span class="line">  pthread_create(&amp;thing1, <span class="literal">NULL</span>, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  pthread_join(pattr,<span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(thing1, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// getchar();</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码除主线程外，额外创建了 2 个线程，一个 <code>pattr</code> 使用自定义 stack，另一个<code>thing1</code>使用默认选项。需要注意的是，代码使用<code>malloc</code>在 heap 上开辟一块内存用于线程的 stack，但这块内存不能大于 128KiB，否则 <code>malloc</code>会使用<code>mmap</code>来申请内存，详见<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">TLPI<i class="fa fa-external-link-alt"></i></span>  49.7 节。</p>
<p>线程的执行体会每隔 1 秒钟在 stack 上分配 1KiB 的内存，便于我们观察 stack 的位置。编译并运行程序，这次使用<code>pmap -X &#123;pid&#125;</code>来观察区域的大小，如表 2-5 所示：</p>
<pre>~/play/c ➭ pmap -X 9692
9692:   ./a.out
         Address Perm   Offset Device   Inode  Size  Rss Pss Referenced Anonymous  Mapping
        00400000 r--p 00000000 103:02 7093179     4    4   4          4         0  a.out
        00401000 r-xp 00001000 103:02 7093179     4    4   4          4         0  a.out
        00402000 r--p 00002000 103:02 7093179     4    4   4          4         0  a.out
        00403000 r--p 00002000 103:02 7093179     4    4   4          4         4  a.out
        00404000 rw-p 00003000 103:02 7093179     4    4   4          4         4  a.out
        <span style="color:orange">00405000 rw-p 00000000  00:00       0   732   <span style="color:red">92  92</span>         92        92  [heap]</span>
    7ffff75a7000 ---p 00000000  00:00       0     4    0   0          0         0  
    <span style="color:orange">7ffff75a8000 rw-p 00000000  00:00       0  8204   <span style="color:red">76  76</span>         76        76  </span>
    7ffff7dab000 r--p 00000000 103:02 4859211   152  148   1        148         0  libc-2.33.so
    7ffff7dd1000 r-xp 00026000 103:02 4859211  1324  876   6        876         0  libc-2.33.so
    7ffff7f1c000 r--p 00171000 103:02 4859211   304   64   0         64         0  libc-2.33.so
    7ffff7f68000 r--p 001bc000 103:02 4859211    12   12  12         12        12  libc-2.33.so
    7ffff7f6b000 rw-p 001bf000 103:02 4859211    12   12  12         12        12  libc-2.33.so
    7ffff7f6e000 rw-p 00000000  00:00       0    36   12  12         12        12  
    7ffff7f77000 r--p 00000000 103:02 4865362    28   28   0         28         0  libpthread-2.33.so
    7ffff7f7e000 r-xp 00007000 103:02 4865362    60   60   0         60         0  libpthread-2.33.so
    7ffff7f8d000 r--p 00016000 103:02 4865362    16   16   0         16         0  libpthread-2.33.so
    7ffff7f91000 ---p 0001a000 103:02 4865362     4    0   0          0         0  libpthread-2.33.so
    7ffff7f92000 r--p 0001a000 103:02 4865362     4    4   4          4         4  libpthread-2.33.so
    7ffff7f93000 rw-p 0001b000 103:02 4865362     4    4   4          4         4  libpthread-2.33.so
    7ffff7f94000 rw-p 00000000  00:00       0    24   12  12         12        12  
    7ffff7fc7000 r--p 00000000  00:00       0    16    0   0          0         0  [vvar]
    7ffff7fcb000 r-xp 00000000  00:00       0     8    4   0          4         0  [vdso]
    7ffff7fcd000 r--p 00000000 103:02 4859198     4    4   0          4         0  ld-2.33.so
    7ffff7fce000 r-xp 00001000 103:02 4859198   144  144   0        144         0  ld-2.33.so
    7ffff7ff2000 r--p 00025000 103:02 4859198    36   36   0         36         0  ld-2.33.so
    7ffff7ffb000 r--p 0002d000 103:02 4859198     8    8   8          8         8  ld-2.33.so
    7ffff7ffd000 rw-p 0002f000 103:02 4859198     8    8   8          8         8  ld-2.33.so
    7ffffffde000 rw-p 00000000  00:00       0   132   12  12         12        12  [stack]
ffffffffff600000 --xp 00000000  00:00       0     4    0   0          0         0  [vsyscall]
                                              ===== ==== === ========== =========  
                                              11300 1652 279       1652       260  KB </pre>

<p align="center">表2-5 进程的地址映射表</p>

<p>程序运行之初会打印出<code>malloc address: 0x482700</code>，可以证明内存确实分配于 heap 上。</p>
<p>表 2-5 中黄色的两行代表，两个线程的 stack 区域，一个位于 heap 区域，另一个位于 mmap 区域。而红色部 rss 和 pss 可以理解为实际占用的物理内存，这部分会不断的增长，意味着我们的线程 stack 一直在扩充，直到发生<code>segmentation fault</code>。</p>
<p>表 2-5 中 heap 段的 size 为 732 KiB，这是因为我在申请 stack 所用的内存之前，连续调用了 5 次 malloc 共申请了 500KiB 的内存。否则，其大小会是 132KiB，这是由 malloc 管理内存的机制决定的，可参照 <span class="exturl" data-url="aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzAyLzEwL3VuZGVyc3RhbmRpbmctZ2xpYmMtbWFsbG9jL2NvbW1lbnQtcGFnZS0xLw==">Understanding glibc malloc<i class="fa fa-external-link-alt"></i></span> 这篇文章。可见 pmap 读取的内容并不能识别出我们申请的每一块内存，对于无法识别的内容，在 smaps 中只会放在一个匿名的条目中，比如这里的 heap 区域。</p>
<p>Finally，我们终于可以画一个全面的 stack 角度的内存布局图了：</p>
<p><img data-src="https://s3.ap-northeast-1.amazonaws.com/qiniu.liupzmin.com/stack-region.png" alt="图 2-11 位于不同区域的线程 stack"></p>
<h2 id="4-函数调用与栈帧"><a href="#4-函数调用与栈帧" class="headerlink" title="4. 函数调用与栈帧"></a>4. 函数调用与栈帧</h2><p>堆栈是一个后进先出的结构，它天然的适用于函数调用这种情况。这一节我们简单来看一下 stack 在函数调用方面的应用，同时也解答一下引发我写此系列文章的 stack 中变量引用的问题。</p>
<p>x86_64 架构的堆栈由高地址向低地址增长，寄存器<code>%rsp</code>始终指向栈顶元素。将堆栈的栈顶指针减小就可以在 stack 上分配空间，将指针增大就可以在 stack 上释放空间。</p>
<h3 id="4-1-利用-stack-进行控制转移"><a href="#4-1-利用-stack-进行控制转移" class="headerlink" title="4.1 利用 stack 进行控制转移"></a>4.1 利用 stack 进行控制转移</h3><p>每一个函数在 stack 分配的空间统称为该函数的栈帧（stack fram），图 2-12 给出了运行时 stack 的通用结构，包括把它划分为栈帧，当前正在执行的函数的帧总是在栈顶。假设 函数 P 在执行过程中调用了函数 Q，当函数 P 调用函数 Q 时，会把返回地址压入栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行。我们把这个返回地址当做 P 的栈帧的一部分，因为它存放的是与 P 相关的状态。</p>
<p><img data-src="https://qiniu.liupzmin.com/stack-frame.png" alt="图 2-12 通用的栈帧结构"></p>
<p>Q 的代码会扩展当前堆栈的边界，为它的栈帧分配所需的空间。在此空间中， Q 可以保存寄存器的值，分配局部变量，如果它还调用其它函数，则为被调用的函数设置参数。函数 P 可以通过寄存器传递最多 6 个参数，如果 Q 的参数个数超过了 6 个，则 P 在调用之前会在自己的栈帧里存储好这些参数。</p>
<p>函数调用需要打破当前 CPU 顺序执行指令的状态，使其跳转至另外一部分代码块。这种控制转移自然是通过修改程序计数器（PC）来达成的，将控制从 P 转移到 Q，仅需将 PC 修改为 Q 的代码的起始位置。不过当 Q 返回的时候，CPU 必须要知道它要在 P 中继续的位置。x86_64 机器中，这个过程是通过 <code>call</code>和<code>ret</code>指令配合完成的。</p>
<p>首先，函数调用通过<code>call Q</code>来进行，该指令会把地址 A 压入堆栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 通常叫做<strong>返回地址</strong>，是紧随 call 指令之后的那条指令的地址。对应的指令 <code>ret</code>会从堆栈中弹出地址 A，并把 PC 设置为 A。</p>
<p>可以看到，这种把返回地址压入堆栈的简单机制能够让函数在稍后返回到程序中正确的位置。函数的调用和返回机制刚好与堆栈提供的后进先出的内存管理方式相吻合。</p>
<h3 id="4-2-需要保存的寄存器"><a href="#4-2-需要保存的寄存器" class="headerlink" title="4.2 需要保存的寄存器"></a>4.2 需要保存的寄存器</h3><p>CPU 中的寄存器是被所有的函数共享的，虽然在一个执行流中，同一时刻只有一个函数是活动的（在 CPU 上执行），但我们必须保证在函数返回时，它不会覆盖或者破坏调用者稍后会使用的寄存器的值。为此，x86_64 采用了一组统一的寄存器使用惯例，所有的函数调用都必须遵循。</p>
<p>依照此管理，寄存器被分为两类：</p>
<ol>
<li><strong>需要被调用者保存的寄存器（callee-saved）</strong>，寄存器 %rbx、%rbp 和 %r12~%r15 属于被调用者保存寄存器，图 2-12 中被保存的寄存器区域就是被调用者栈帧中存放寄存器值的位置。当函数 P 调用函数 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 的时候与 Q 被调用的时候是一样的。要做到这一点，Q 要么不去改变就这些寄存器的值，要么就要把原始值压入堆栈，然后在返回的时候从堆栈中弹出旧的值。我们稍后会看到<code>%rbp</code>寄存器就是这样的一个例子。</li>
<li><strong>需要调用者保存的寄存器（caller-saved）</strong>，事实上除了栈顶指针寄存器 %rsp，所有其它的寄存器都属于调用者保存寄存器。</li>
</ol>
<h3 id="4-3-rbp-和-rsp"><a href="#4-3-rbp-和-rsp" class="headerlink" title="4.3 %rbp 和 %rsp"></a>4.3 %rbp 和 %rsp</h3><p><code>%rsp</code> 是栈顶指针寄存器，其值永远指向 stack 的顶部。<code>%rbp</code> 大家可能会陌生一点，x86_64 代码使用该寄存器作为<code>帧指针（frame pointer）</code>，有时也称为<code>基指针（base pointer）</code>，这也是 %rbp 中 <code>bp</code> 两个字母的由来。看如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">swap_add</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">  <span class="type">long</span> x = *xp;</span><br><span class="line">  <span class="type">long</span> y = *yp;</span><br><span class="line">  *xp = y;</span><br><span class="line">  *yp = x;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">caller</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">long</span> arg1 = <span class="number">534</span>;</span><br><span class="line">  <span class="type">long</span> arg2 = <span class="number">1057</span>;</span><br><span class="line">  <span class="type">long</span> sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">  <span class="type">long</span> diff = arg1 - arg2;</span><br><span class="line">  <span class="keyword">return</span> sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>gcc -S</code> 编译为汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">.LFB1:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp              ;将 %rbp 入栈</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp        ;将此时的栈顶指针设为 rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	subq	$48, %rsp         ;为此函数栈帧申请 48 字节</span><br><span class="line">	movq	%fs:40, %rax      ;获取金丝雀值（堆栈保护机制）</span><br><span class="line">	movq	%rax, -8(%rbp)    ;将金丝雀值存入堆栈</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movq	$534, -40(%rbp)   ;将 534 存入 arg1</span><br><span class="line">	movq	$1057, -32(%rbp)  ;将 1057 存入 arg2</span><br><span class="line">	leaq	-32(%rbp), %rdx   ;将 arg2 的地址存入 %rdx 寄存器</span><br><span class="line">	leaq	-40(%rbp), %rax   ;将 arg1 的地址存入 %rax 寄存器</span><br><span class="line">	movq	%rdx, %rsi        ;将 %rdx 的值存入 %rsi 寄存器</span><br><span class="line">	movq	%rax, %rdi        ;将 %rax 的值存入 %rdi 寄存器</span><br><span class="line">	call	swap_add          ;调用 swap_add 函数</span><br><span class="line">	movq	%rax, -24(%rbp)   ;将函数调用结果 sum 存入 stack 的 -24(%rbp) 处</span><br><span class="line">	movq	-40(%rbp), %rax   ;将 arg1 放入 %rax</span><br><span class="line">	movq	-32(%rbp), %rdx   ;将 arg2 放入 %rdx</span><br><span class="line">	subq	%rdx, %rax        ;计算  diff = arg1 - arg2 将结果 diff 放入 %rax</span><br><span class="line">	movq	%rax, -16(%rbp)   ;将 diff 入栈，放在 -16(%rbp) 处</span><br><span class="line">	movq	-24(%rbp), %rax   ; 将 sum 读入 %rax</span><br><span class="line">	imulq	-16(%rbp), %rax   ; 计算 sum * diff，结果放在 %rax 中准备返回</span><br><span class="line">	movq	-8(%rbp), %rdx    ; 下面检查堆栈结构是否有损坏</span><br><span class="line">	subq	%fs:40, %rdx</span><br><span class="line">	je	.L5</span><br><span class="line">	call	__stack_chk_fail@PLT</span><br><span class="line">.L5:</span><br><span class="line">	leave                     ;释放栈帧</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret                       ; 返回</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure>

<p>此时函数的栈帧如图 2-13 一样：</p>
<p><img data-src="https://qiniu.liupzmin.com/rbp.png" alt="图 2-13 函数 caller 的栈帧结构"></p>
<p>我们可以看到 caller 汇编指令的开始就是保存 %rbp 寄存器的值，因为 %rbp 属于 <strong>callee-saved</strong> 寄存器，它的值要由 <code>caller</code> 函数负责保存（此时的caller看作是被调用者）。在函数结尾，<code>ret</code>返回之前有一句<code>leave</code> 指令，它的作用是释放函数的栈帧，将 %rbp 寄存器恢复到 caller 被调用前的值，它等价于下面两条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq %rbp,%rsp    ;直接将栈顶指针拉回到 %rbp 处</span><br><span class="line">popq %rbp         ;将保存的 %rbp 出栈 放入 %rbp</span><br></pre></td></tr></table></figure>

<p>从图 2-13 可以看出，<code>movq %rbp,%rsp</code>会将 %rbp 的值设置为栈顶，而此时 %rbp 指向栈帧的开始处，即刚保存完旧 %rbp 的位置。紧接着的操作<code>popq %rbp</code>会将栈顶的元素（保存的 %rbp）弹出，并设置到 %rbp 寄存器，这样 caller 函数的调用者的 %rbp 就恢复了。</p>
<p>我们从汇编指令上很容易看出堆栈上的寻址方式：在写入和读取堆栈上的数据时，使用的是类似于**-32(%rbp)<strong>的</strong>基址+偏移量**的寻址方式。毕竟，在一个函数的栈帧生存期中，<code>%rbp</code>是永远固定不变的，使用<code>%rbp</code>来相对寻址也就顺理成章了。</p>
<p>但是，gcc 中的优化选项会对能在编译期确定栈帧大小的函数使用<code>%rsp</code>定位，让我们再对比一下<code>gcc -Og -S</code>生成的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">.LFB1:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	subq	$40, %rsp           ;为此函数栈帧申请 40 字节</span><br><span class="line">	.cfi_def_cfa_offset 48</span><br><span class="line">	movq	%fs:40, %rax        ;获取金丝雀值（堆栈保护机制）</span><br><span class="line">	movq	%rax, 24(%rsp)      ;将金丝雀值存入堆栈</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movq	$534, 8(%rsp)       ;将 534 存入 arg1</span><br><span class="line">	movq	$1057, 16(%rsp)     ;将 1057 存入 arg2</span><br><span class="line">	leaq	16(%rsp), %rsi      ;将 arg2 的地址存入 %rsi 寄存器</span><br><span class="line">	leaq	8(%rsp), %rdi       ;将 arg1 的地址存入 %rdi 寄存器</span><br><span class="line">	call	swap_add            ;调用 swap_add 函数</span><br><span class="line">	movq	8(%rsp), %rdx       ;将 arg1 存入 %rdx 寄存器</span><br><span class="line">	subq	16(%rsp), %rdx      ; 计算  diff = arg1 - arg2</span><br><span class="line">	imulq	%rdx, %rax          ; 计算 sum * diff</span><br><span class="line">	movq	24(%rsp), %rdx      ; 下面检查堆栈结构是否有损坏</span><br><span class="line">	subq	%fs:40, %rdx</span><br><span class="line">	jne	.L5</span><br><span class="line">	addq	$40, %rsp           ; 释放栈帧</span><br><span class="line">	.cfi_remember_state</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	ret                         ;返回</span><br></pre></td></tr></table></figure>

<p>可见此时的汇编代码中，用于定位堆栈内存的寻址方式变成了类似 <strong>8(%rsp)</strong> 的模式，而且使用**-Og**生成的汇编代码更符合 C 代码整体结构，我们的第一版汇编代码的和原始的 C 代码相比就有很大程度的变形，导致汇编代码和源代码之间的关系难以理解。</p>
<p>但是，这种使用栈顶指针定位的方式只适用于在编译期能够确定栈帧大小的情况，如果函数的栈帧是在运行中动态改变的。比如使用了变长数组、alloca等情况下，在堆栈上分配的字节数是任意的，也就无法确定 %rsp 和要寻址的内容之间的地址偏移量，此时便只有 %rbp 一种定位方式了，让我们看下面这个变长数组的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vframe</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> idx, <span class="type">long</span> *q)</span>&#123;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> *p[n];</span><br><span class="line">  p[<span class="number">0</span>] = &amp;i;</span><br><span class="line">  <span class="keyword">for</span>(i =<span class="number">1</span>; i&lt;n;i++)&#123;</span><br><span class="line">    p[i] = q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *p[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况生成的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">vframe:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$72, %rsp</span><br><span class="line">	.cfi_offset 3, -24</span><br><span class="line">	movq	%rdi, -56(%rbp)</span><br><span class="line">	movq	%rsi, -64(%rbp)</span><br><span class="line">	movq	%rdx, -72(%rbp)</span><br><span class="line">	movq	%fs:40, %rax</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movq	%rsp, %rax</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movq	-56(%rbp), %rax</span><br><span class="line">	leaq	-1(%rax), %rdx</span><br><span class="line">	movq	%rdx, -40(%rbp)</span><br><span class="line">	movq	%rax, %rdx</span><br><span class="line">	movq	%rdx, %r8</span><br><span class="line">	movl	$0, %r9d</span><br><span class="line">	movq	%rax, %rdx</span><br><span class="line">	movq	%rdx, %rcx</span><br><span class="line">	movl	$0, %ebx</span><br><span class="line">	leaq	0(,%rax,8), %rdx</span><br><span class="line">	movl	$16, %eax</span><br><span class="line">	subq	$1, %rax</span><br><span class="line">	addq	%rdx, %rax</span><br><span class="line">	movl	$16, %ebx</span><br><span class="line">	movl	$0, %edx</span><br><span class="line">	divq	%rbx</span><br><span class="line">	imulq	$16, %rax, %rax</span><br><span class="line">	subq	%rax, %rsp</span><br><span class="line">	movq	%rsp, %rax</span><br><span class="line">	addq	$7, %rax</span><br><span class="line">	shrq	$3, %rax</span><br><span class="line">	salq	$3, %rax</span><br><span class="line">	movq	%rax, -32(%rbp)</span><br><span class="line">	movq	-32(%rbp), %rax</span><br><span class="line">	leaq	-48(%rbp), %rdx</span><br><span class="line">	movq	%rdx, (%rax)</span><br><span class="line">	movq	$1, -48(%rbp)</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	movq	-48(%rbp), %rdx</span><br><span class="line">	movq	-32(%rbp), %rax</span><br><span class="line">	movq	-72(%rbp), %rcx</span><br><span class="line">	movq	%rcx, (%rax,%rdx,8)</span><br><span class="line">	movq	-48(%rbp), %rax</span><br><span class="line">	addq	$1, %rax</span><br><span class="line">	movq	%rax, -48(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">	movq	-48(%rbp), %rax</span><br><span class="line">	cmpq	%rax, -56(%rbp)</span><br><span class="line">	jg	.L3</span><br><span class="line">	movq	-32(%rbp), %rax</span><br><span class="line">	movq	-64(%rbp), %rdx</span><br><span class="line">	movq	(%rax,%rdx,8), %rax</span><br><span class="line">	movq	(%rax), %rax</span><br><span class="line">	movq	%rsi, %rsp</span><br><span class="line">	movq	-24(%rbp), %rdx</span><br><span class="line">	subq	%fs:40, %rdx</span><br><span class="line">	je	.L5</span><br><span class="line">	call	__stack_chk_fail@PLT</span><br><span class="line">.L5:</span><br><span class="line">	movq	-8(%rbp), %rbx</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure>

<p>vframe 的函数栈帧如图 2 - 14 所示：</p>
<p><img data-src="https://qiniu.liupzmin.com/vframe.png" alt="图 2-14 函数 vframe 的栈帧"></p>
<p>可以看到，在整个函数的执行过程中，使用不变的 %rbp 帧指针寄存器和不同的偏移量来引用堆栈上的内容。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本篇名为《穿越虚拟内存的迷雾》，但并未深入的介绍虚拟内存，只是通过对虚拟内存的溯源来更好的理解 stack。</p>
<p>虚拟内存并非与生俱来，乃是先驱们在计算机的发展过程中总结出的有效的内存管理方式。它通过对存储的抽象为运行在计算机中的每个进程提供了统一的地址空间，并使用交换技术和分页使得计算机可以在有限的物理内存上运行比较大的程序。利用程序的局部性原理，让数据在磁盘和真实的物理内存之间以页的形式换入换出，以此节约了成本，提高了硬件的利用率。</p>
<p>Stack 是进程地址空间中举足轻重的一环，函数的调用与返回、局部变量的存储都依赖于它。但它的位置与大小却并不总是那么明朗，通过对 Linux 下 stack 分布和大小的探查，我们对 stack 的分配问题如管中窥豹，可见一斑。见诸各种资料上的进程地址空间布局图仅仅只是标明了主线程的 stack，并没有在线程概念普及后予以校正。或许这在计算机专家眼中根本不值一提，但它成功迷惑了我。因此我做了这些许微小的工作，以俟夫究察者得焉！</p>
<p>有了这些对于 stack 的基础认识，会更容易理解 Go 语言中协程的 stack，我们下一篇文章见😙~</p>
<p>在撰写此文时，深深感受到自身学识之匮乏、能力之浅薄，因此行文中定有疏漏讹误之处，也请阅读此文的朋友热情斧正。</p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMzQ2MzkzMC8=">操作系统导论<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjkxMjc2Ny8=">深入理解计算机系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zNjUyMzg4Lw==">程序员的自我修养<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTgwOTMzMC8=">Linux&#x2F;UNIX系统编程手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC80ODQzNTY3Lw==">深入 Linux 内核架构<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNzA5NjY2NS8=">现代操作系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi94ODYveDg2XzY0L21tLnR4dA==">mm<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA4MzE3Mi9ob3ctdG8tbW1hcC10aGUtc3RhY2stZm9yLXRoZS1jbG9uZS1zeXN0ZW0tY2FsbC1vbi1saW51eA==">How to mmap the stack for the clone() system call on linux?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhdHRlcmEvZ2xpYmMvYmxvYi9hMmYzNDgzM2IxMDQyZDVkOGVlYjI2M2I0Y2Y0Y2FhZWExMzhjNGFkL25wdGwvYWxsb2NhdGVzdGFjay5j">allocatestack.c<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzAyLzEwL3VuZGVyc3RhbmRpbmctZ2xpYmMtbWFsbG9jL2NvbW1lbnQtcGFnZS0xLw==">Understanding glibc malloc<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2021/06/27/theory/stack-insight-01-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/theory/stack-insight-01-md/" class="post-title-link" itemprop="url">Stack 顿悟三部曲（1）：从CPU的视角说起</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 09:56:28" itemprop="dateCreated datePublished" datetime="2021-06-27T09:56:28+08:00">2021-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么会有这篇文章"><a href="#为什么会有这篇文章" class="headerlink" title="为什么会有这篇文章"></a>为什么会有这篇文章</h2><p>我在啃 rust 圣经英文原版时，<code>所有权</code>那一章就反复看了几遍，作者简要介绍了 <code>stack</code> 和 <code>heap</code> 的使用区别，这引起了我以前从未有过的一个思考：<code>stack</code> 上的数据是如何被引用的？</p>
<p><em>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap and is sometimes abbreviated as just allocating. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</em></p>
<p>简要翻译一下：</p>
<p><strong>所有存储在 stack 上的数据，其 size 必须是固定不变且在编译期已知的。如果数据的大小不能在编译期决定，亦或是在运行时其大小会发生改变，那么这样的数据就应该放在 heap 上。heap 是一个组织比较松散的区域：当你想把数据放置在 heap 上时，你必须先请求一块存储空间才行。专门的内存分配器会去寻找一块空余的、大小足够的空间，并将其标记为已用，之后返回指向这块区域的指针。这个过程就是在 heap 上分配内存，有时会简称为 allocating。将数据推入 stack（入栈）不会被叫做 allocating（因为 stack 的空间在线程创建时就已分配并初始化）。因为指针类型的大小固定且已知，因此你可以将指针入栈，但是当你想使用数据本身时，你必须追踪跟指针（解引用）。</strong></p>
<p>正如我开篇所言，让我心头一震的并不是这些随处可见的关于 <code>stack</code> 和 <code>heap</code> 区别的论述，而是我从未深入思考过的一个问题：<strong>stack 上的数据是如何被引用的？</strong></p>
<p>以前对堆栈的认知就是 <code>PUSH</code> 入栈，使用时 <code>POP</code> 出栈，这大概源于对数据结构课程中 <code>stack</code> 数据结构认知的根深蒂固。所以当我读到 stack 上的数据都是固定大小且日后不会改变、不会增长时，才后知后觉：为何以前没有去想这个细节呢？</p>
<p><code>CPU</code> 把一块内存当做 stack 使用时，参数和局变量入栈之后仍会被使用，并不像我们数据结构课程中的 stack，只在用的时候才去 POP。CPU中的 stack 机制只有在函数结束时才释放该函数的栈帧，那栈上的数据在没有弹出时是如何被引用到的呢？</p>
<p>其实，这个问题很好回答，从编译之后的汇编指令上看，是使用的相对定位。<strong>大致是利用 ebp（帧指针寄存器或基指针寄存器） 和 esp（栈顶指针寄存器）中的一个或两个来达到定位的目的。</strong></p>
<p>以此为由，我深入调查并思考了很多关于 stack 的内容，主要涉及有如下几点：</p>
<ol>
<li>CPU 的 stack 机制是如何工作的？</li>
<li>函数调用是如何利用 stack 的？</li>
<li>进、线程在创建时 stack 如何分配，虚拟内存中的 stack 区域是线程共有的么？</li>
<li>从指令级别理解 Go 语言的 goroutine 是如何调度和分配 stack 的？</li>
</ol>
<p>因此，我将分几篇文章分别对这些内容进行叙述，虽然我是围绕着 stack 来进行思考的，但文章内容也会谈及很多 stack 之外的东西，比如虚拟内存、线程调度，上下文切换等等。</p>
<p>友情提醒一下，因个人能力有限，我并不会去深抠相关的源码细节，<strong>我目前所寻求的信息，意在建立计算机系统的世界观与 Go 语言的世界观，是在陷入具体细节之前为自己提供一个大致的轮廓，让自己对计算机运行的脉络有一个关键性的认识。</strong></p>
<p>这是这个系列的第一篇，本篇我主要从 CPU 的视角来带大家一起复习一下理论知识，看一看 CPU 是如何执行指令，如何将一块内存当做 stack 来使用。</p>
<p>因 stack 一般会被翻译为堆栈，因此后续文章内容能使用英文原文 stack 的地方，我会尽量使用 stack，需要中文的地方我会使用堆栈一词，如果堆栈一词放上去比较突兀的话，我会直接使用栈这个字。所以，无论是 stack、堆栈、栈，我希望阅读文章的你能铭记我指的就是 stack！</p>
<h2 id="内存和它里面的东西"><a href="#内存和它里面的东西" class="headerlink" title="内存和它里面的东西"></a>内存和它里面的东西</h2><p>众所周知，计算机内部用二进制表示一切。从应用的角度而言，内存中存放的信息大致可分为指令和数据，然而在内存看来，这些信息并没有什么区别。一段信息是指令还是数据，全看 CPU 如何使用它们。CPU 在工作的时候，把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。那这是如何做到的呢？我们以 <code>8086 CPU</code> 为例来简要说明。</p>
<p><img data-src="https://qiniu.liupzmin.com/bus.jpeg" alt="CPU与内存之间的总线"></p>
<p>如图所示，CPU 与内存之间有三类总线，分别为地址总线、控制总线和数据总线。数据的读、写就是靠这三类总线配合完成的。我们来看一下 CPU 从内存 3 号单元中读取数据的过程。</p>
<p><img data-src="https://qiniu.liupzmin.com/cpu-read-data-from-memory.png" alt="CPU 从内存读取数据"></p>
<ol>
<li>CPU 通过地址线将地址信息 3 发出。</li>
<li>CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</li>
<li>存储器将 3 号单元中的数据 08 通过数据线送入 CPU。</li>
</ol>
<p>写操作与读操作的步骤相似。如向 3 号单元写入数据 26 ：</p>
<ol>
<li>CPU 通过地址线将地址信息 3 发出。</li>
<li>CPU 通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。</li>
<li>CPU 通过数据线将数据 26 送入内存的 3 号单元中。</li>
</ol>
<p>当然，现实当中地址并不总是像 3 这样简单，我们可以把每个字节当成一个小盒子，内存就是一堆小盒子的线性排列，如果从第一个盒子开始给他们都编上号，那么每个盒子的号码就是对应内存空间的地址，也就是说在计算机主存当中，每一个字节都有它的地址。你可以把内存想象成下面这样（图中每一行代表前文论述的盒子）：</p>
<p><img data-src="https://qiniu.liupzmin.com/memory-byte.jpeg" alt="memory"></p>
<p>有一点很明显，就是 CPU 能寻址的空间大小是受地址总线导线数量限制的。在 8086 中，其地址总线是 20 根，也就是它能用 20 个 bit 来表示一个地址，算来它最大的寻址空间就是 2 的 20 次方，即 1M 大小。</p>
<p>但问题是，在 8086 内部用于倒腾数据的寄存器都是 16 位的， 16 位最大寻址空间只有 64K，那如何用 16 位的寄存器组合成 20 位的地址呢？8086 的处理方法是使用 2 个 16 位地址，通过一个地址加法器的运算来得出 20 位的物理地址。运算的逻辑就是一个 16 位的段地址左移 4 位再加上偏移地址：<strong>物理地址&#x3D;段地址*16 + 偏移地址</strong>。此处不再举例描述细节，有兴趣的可以参考任意讲解段地址和偏移地址的资料，此处只需要记住，8086 CPU 下读写内存时，都需要一个段地址的辅助，这个段地址就放在段寄存器中。</p>
<p>8086 有 4 个段寄存器，CS、DS、SS、ES，分别是代码段寄存器、数据段寄存器、堆栈段寄存器以及扩展段寄存器，本文主要涉及代码段和堆栈段，那么先从 CS 代码段寄存器说起吧。</p>
<h2 id="CPU-是如何执行指令的"><a href="#CPU-是如何执行指令的" class="headerlink" title="CPU 是如何执行指令的"></a>CPU 是如何执行指令的</h2><p>我们都知道，CPU 的任务说起来很简单，就是从程序计数器（PC）中拿到地址，将该地址处的数据看作指令并读入指令缓冲器，之后指令缓冲器中的指令便会进入执行控制器执行。当PC中的地址所指向的数据被读取之后，PC中的值会自动增加为下一条指令的地址，接下来就会重复之前的内容。</p>
<p>但在 8086 中， PC 是由两个寄存器来共同表示的，那就是 CS 和 IP，CS是代码段寄存器，IP是指令指针寄存器。任意时刻，设 CS 中的内容为 M，IP 中的内容为 N，8086 CPU 将从内存单元 <code>M*16 + N</code> 开始，读取一条指令并执行。换句话说，任意时刻，CPU 将 <code>CS:IP</code> 指向的内容当作指令执行。</p>
<p>下图为CPU执行一条指令的过程拆解，其中 CS 寄存器的值为 <code>2000H</code>，<code>IP 寄存器</code>的值为 <code>0000H</code>，内存 <code>20000H~20009H</code> 单元存放着可执行的机器码。</p>
<p><img data-src="https://qiniu.liupzmin.com/cpu-exec-ins.png" alt="CPU 执行指令"></p>
<p>CPU 会将<code>CS、IP</code>中的内容送入加法器得出物理地址 <code>2000H*16+0000H（20000H）</code>，之后 <code>20000H</code> 送入地址总线，位于 <code>20000H</code> 单元处的指令 <strong>B8 23 01</strong> 会被读入指令缓冲器并增加 IP 的值（增加的值为本次读取的指令的长度，此处为 3 个字节），接下来就会进入执行阶段。因为此时 <code>CS:IP</code> 中的内容已经是下一条指令的地址（<code>mov bx,0003H</code>），CPU 便进入下一次循环，如此往复。</p>
<p>上图执行完第一条指令之后 AX 寄存器的内容已变为 <strong>0123H</strong>。</p>
<p>更详细的内容，请参考<code>王爽《汇编语言》2.10 章节</code>。在这里描述 CPU 指令的执行过程是为了在后面的文章中方便描述线程调度，其实线程切换的原理很简单，就是修改 <strong>CS:IP</strong> 的值让 CPU 去执行另外一个地方的指令，而这个地方就是新线程的函数指令入口。</p>
<h2 id="CPU-提供的stack机制"><a href="#CPU-提供的stack机制" class="headerlink" title="CPU 提供的stack机制"></a>CPU 提供的stack机制</h2><p>如今的 CPU 都有堆栈的设计，提供相关的指令来以堆栈的方式访问内存空间。这意味着在编程的时候，可以将一段内存当作堆栈来使用。CPU 提供了以堆栈方式访问内存的机制，操作系统用这种机制实现了函数调用。</p>
<p>CPU 提供了入栈和出栈的指令，最基本的就是 <strong>PUSH</strong> 和 <strong>POP</strong> 指令，比如 <code>PUSH AX</code> 表示将寄存器AX中的内容送入堆栈，<code>POP AX</code> 就是将栈顶的元素送入 AX 寄存器，并移动栈顶。那么，CPU 是如何知道一段内存被当做栈来用的呢？答案是 <strong>SS 堆栈寄存器</strong>和 <strong>SP 栈顶寄存器</strong>。</p>
<p>任意时刻，<code>SS:SP</code> 指向栈顶元素，PUSH 和 POP 指令执行的时候，CPU 从 SS 和 SP 处获取栈顶地址，并在执行过程中自动加减SP寄存器中的值，是的 SS:SP 永远指向栈顶。</p>
<p><strong>PUSH AX</strong> 的指令，由以下两步完成。</p>
<ol>
<li>SP&#x3D;SP-2, SS:SP 指向当前栈顶的下方的单元，以当前栈顶下方的单元为新的栈顶；</li>
<li>将 AX 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新的栈顶。</li>
</ol>
<p>下图描述了 8086CPU 对 PUSH 指令的执行过程。</p>
<p><img data-src="https://qiniu.liupzmin.com/push.jpeg" alt="PUSH"></p>
<p><strong>POP AX</strong> 的指令更好相反，由以下两步完成。</p>
<ol>
<li>将 SS:SP 指向的内存单元的数据送入 AX 中；</li>
<li>SP&#x3D;SP+2，SS:SP 指向当前栈顶上方的单元，以当前栈顶上方的单元为新的栈顶。</li>
</ol>
<p>下图描述了 8086CPU 对 POP 指令的执行过程。</p>
<p><img data-src="https://qiniu.liupzmin.com/pop.jpeg" alt="POP"></p>
<p>注意，栈由高地址向低地址增长，这两幅图相当于倒置的状态。</p>
<p>从中我们可以得出一点结论，将一段内存当做栈，仅仅是我们在编程时的一种安排，CPU 并不在乎这段内存在哪，也不在乎内存放的到底是指令还是数据。换句话说，内存并无区别，区别只在 CPU 如何看待它们。我们会在后面讲述线程或协程堆栈使用的内存，只要将一块内存的地址设置为 SS:SP 那么这段内存就会在你使用 PUSH、POP 的时候作为堆栈来用。</p>
<p>我们在学习虚拟内存的时候（下一章会简单介绍虚拟内存）容易被其划分的各种区域迷惑，某段区域用于 stack ，某块区域用于 heap。很容易让人产生这些区域都有各自特殊之处的错觉。加上一些盛行理论的影响，让问题更加扑朔迷离，常见的如：数据放在 stack 上要比 heap 上快，因为入栈只需要一条指令，而在 heap 上申请内存则十分耗时，简言之使用 stack 廉价，使用 heap 昂贵。</p>
<p>其实这种说法不严谨，除了会迷惑初学者之外，别无益处。试想一下，stack 与 heap 有什么区别？区别只在 stack 已经分配，且使用方式不同；heap 只在需要的时候去分配，耗时的是分配的过程，而不是访问的过程；<strong>CPU 访问 stack 中的内容和 heap 中内容的方式并无二致，都是使用的标准的内存寻址方式</strong>（注：stack 相对 heap 对 cpu cache 更加友好，从程序运行的空间局部性来讲，CPU Cache 命中率会高一些）。</p>
<p>CPU 把主存当做什么用，完全看我们的规划以及使用的指令，比如设置了代码段之后，代码段部分保存的数据就被 CPU 看做指令，当设置了 DS 数据段之后，使用 mov 等操作时 CPU 即将内存中的内容视作数据，当设置了 SS 段之后，使用 PUSH 和 POP 时 CPU 就把那块内存当做堆栈来使用。</p>
<p>CPU 对主存的一视同仁可以在另外一个现象上得到印证，如果使用现代的编译器编译为汇编文件，你会发现很多理论上应该使用 PUSH 的地方却使用了 MOV，这是因为编译器做了优化，PUSH 隐含了两个操作，一个是移动数据，一个是维护堆栈指针。当操作较多时，指针维护较为频繁，为性能计转而使用 mov 来达到目的，并在必要的时候手动维护栈顶指针。这间接说明了堆栈段的内存并无甚特别之处，其特别只在于使用的方式（入栈和出栈的操作同样可以用 mov 和数据段来配合达到）。</p>
<h2 id="现代-CPU-中的段"><a href="#现代-CPU-中的段" class="headerlink" title="现代 CPU 中的段"></a>现代 CPU 中的段</h2><p>8086 采用了段的方式来增加寻址空间，使得最大寻址空间达到 1M，但它并没有对内存访问做寻址检查，也不支持现在广为流行的虚拟内存（虚拟内存的内容，我们在下一篇探讨函数栈帧的时候详述）。这意味着 8086 没有内存保护功能，且此种寻址方式无法对多道程序提供支持，这种使用段直接生成物理地址的模式被称为实模式。</p>
<p>Intel 在 8086 的继任者身上实现了保护模式，对虚拟内存提供了硬件上的支持。保护模式依然使用段来加强寻址，且方案设计非常复杂精巧，这种方式人们将其称为 IA-32 保护模式，但是此种模式应用甚少，进入 64 bit 时代后，CPU 仅仅作为兼容需要予以保留。</p>
<p>AMD 是第一个吃螃蟹的，首次从架构上将 CPU 的虚拟寻址空间带入 64 bit 模式（可参考 wiki <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWDg2LTY0I09wZXJhdGluZ19tb2Rlcw==">x86-64<i class="fa fa-external-link-alt"></i></span> 的描述，内容还算详实），虽然在架构上已支持 64 bit，但是 AMD 在处理器的实现上实际仅支持 48 bit 的虚拟寻址空间，以及 40 bit 的物理寻址空间；对应的 Intel i7 实现为 48 bit 虚拟寻址空间 和 52 bit 的物理寻址空间。这主要是出于经济上的考虑，并在架构设计上做了功夫，使得日后可以很容易扩展到真正的 64 位。不要小看 48 bit 的寻址空间，这意味着当前实现的 CPU 最大支持 256 TB 的内存寻址，然而当下几乎没有场景会达到这一临界点。更详细的内容可以参考这两篇讨论：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjM5NzU0NDcvd2h5LXZpcnR1YWwtYWRkcmVzcy1hcmUtNDgtYml0cy1ub3QtNjQtYml0cw==">why virtual address are 48 bits not 64 bits?<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjcxNjk0Ni93aHktZG8teDg2LTY0LXN5c3RlbXMtaGF2ZS1vbmx5LWEtNDgtYml0LXZpcnR1YWwtYWRkcmVzcy1zcGFjZQ==">Why do x86-64 systems have only a 48 bit virtual address space?<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>在这里有必要提一下 64 bit 模式下与寻址相关的<code>Canonical form addresses</code>，AMD 标准规定：虚拟地址的高 16 位 也就是从 48 位到 63 位必须拷贝第 47 位的值。<code>Canonical form addresses</code> 规定有效的地址空间为 <strong>0</strong> 到 <strong>00007FFF&#39;FFFFFFFF</strong>，以及 <strong>FFFF8000&#39;00000000</strong> 到 <strong>FFFFFFFF&#39;FFFFFFFF</strong>，可以看下图形象的表示：</p>
<p><img data-src="https://qiniu.liupzmin.com/canonical.png" alt="Canonical form addresses"></p>
<p><code>Canonical form addresses</code> 将空间分为上下两部分，可见 48 bit 寻址空间下中间有很大的的空洞。Linux 将上部 128TB 用于内核空间，下部 128TB 用于用户空间，即可以寻址 256 TB 的内存空间。无论如何地址已经是 64 bit 的了，不再需要借助段寄存器。</p>
<p>如果上面这些内容难以理解，那么你只需要明晰一点：<strong>在汇编语言中，修改指令寄存器和栈顶寄存器的时候，只需设置一个寄存器即可，已不再需要段的参与！</strong></p>
<p><em><strong>程序调度、堆栈初始化无非就是修改 CPU 对应的寄存器，之后就可以控制进程执行流的走向，以及进程用到的 stack。这一点也是本系列文章围绕的核心所在，故不厌其烦的简述其原理于此。</strong></em></p>
<p><em><strong>参考文献</strong></em></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTcyNjAxOS8=">汇编语言<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjkxMjc2Ny8=">深入理解计算机系统<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zNjUyMzg4Lw==">程序员的自我修养<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yMDQ1MjM4Ny8=">计算机体系结构：量化研究方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjM5NzU0NDcvd2h5LXZpcnR1YWwtYWRkcmVzcy1hcmUtNDgtYml0cy1ub3QtNjQtYml0cw==">why virtual address are 48 bits not 64 bits?<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjcxNjk0Ni93aHktZG8teDg2LTY0LXN5c3RlbXMtaGF2ZS1vbmx5LWEtNDgtYml0LXZpcnR1YWwtYWRkcmVzcy1zcGFjZQ==">Why do x86-64 systems have only a 48 bit virtual address space?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWDg2LTY0I09wZXJhdGluZ19tb2Rlcw==">x86-64<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg5Nzc3NTUvYWRkcmVzcy1jYW5vbmljYWwtZm9ybS1hbmQtcG9pbnRlci1hcml0aG1ldGlj">Address canonical form and pointer arithmetic<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExNjU2Nzgvd2h5LTY0LWJpdC1tb2RlLWxvbmctbW9kZS1kb2VzbnQtdXNlLXNlZ21lbnQtcmVnaXN0ZXJz">Why 64 bit mode ( Long mode ) doesn&#39;t use segment registers?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZXZlcnNlZW5naW5lZXJpbmcuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIwMDYvaG93LWFyZS10aGUtc2VnbWVudC1yZWdpc3RlcnMtZnMtZ3MtY3Mtc3MtZHMtZXMtdXNlZC1pbi1saW51eA==">How are the segment registers (fs, gs, cs, ss, ds, es) used in Linux?<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2021/02/28/golang/explore-io-fs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/golang/explore-io-fs/" class="post-title-link" itemprop="url">译:探索 Go1.16 io/fs 包以提高测试性能和可测试性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-28 10:08:30" itemprop="dateCreated datePublished" datetime="2021-02-28T10:08:30+08:00">2021-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文出处：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29waGVyZ3VpZGVzLmNvbS9hcnRpY2xlcy9nb2xhbmctMS4xNi1pby1mcy1pbXByb3ZlLXRlc3QtcGVyZm9ybWFuY2U=">Exploring &quot;io&#x2F;fs&quot; to Improve Test Performance and Testability<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="io-fs概述及其存在的必要性"><a href="#io-fs概述及其存在的必要性" class="headerlink" title="io/fs概述及其存在的必要性"></a><code>io/fs</code>概述及其存在的必要性</h2><p>​要理解为什么 <code>Go</code>在<code>1.16</code> 版本引入<code>io/fs</code>，就必须先要理解 <strong>embedding（内嵌）</strong>的基本原理。当开发一个工具的时候，嵌入那些日后需要被访问（寻址）的内容涉及到很多方面，但本文仅仅讨论其中之一。</p>
<p>​对于每个要嵌入静态文件的工具来说，其工作本质都大同小异。当它们运行的时候，每个静态文件都会被转换为字节，放入一个<code>.go</code>文件之中，最后被编译成二进制文件。一旦进行编译，工具本身就必须负责将<strong>针对文件系统的调用转换为对一个虚拟文件系统的调用</strong>。</p>
<p>​当运行嵌入了<code>assets</code>静态文件的程序后，代码访问这些文件的方式依然是针对文件系统的调用，我们必须把这种调用转换为一种虚拟调用（因为实际访问的文件内容已被转换为字节，并编译进程序本身）。此时，我们面临一个问题：如何在代码中确定一个调用是针对虚拟的<code>assets</code>还是真实的文件系统？</p>
<p>​想象一下这样一个工具：它会遍历一个目录，并返回所能找到的所有以<code>.go</code>结尾的文件名称。如果此工具不能和文件系统交互，那么它将毫无用处。现在，假设有一个 web 应用，它内嵌了一些静态文件，比如<code>images, templates, and style sheets</code>等等。那这个 Web 应用程序在访问这些相关<code>assets</code>时应使用虚拟文件系统，而不是真实文件系统。</p>
<p>​要分辨出这两种不同的调用，就需要引入一个供开发人员使用的API，该API可以指导该工具何时访问虚拟化，何时访问文件系统。这类API都各有特色，像早期的嵌入工具  <span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2dpdGh1Yi5jb20vZ29idWZmYWxvL3BhY2tyL3Yy">Packr<i class="fa fa-external-link-alt"></i></span>，它使用的就是自定义的 API。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Box</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">Folder</span><span class="params">(path <span class="type">string</span>)</span></span> *Box</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(name <span class="type">string</span>, path <span class="type">string</span>)</span></span> *Box</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">NewBox</span><span class="params">(path <span class="type">string</span>)</span></span> *Box</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> AddBytes(path <span class="type">string</span>, t []<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> AddString(path <span class="type">string</span>, t <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> Bytes(name <span class="type">string</span>) []<span class="type">byte</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> Find(name <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> FindString(name <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> Has(name <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> HasDir(name <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> List() []<span class="type">string</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> MustBytes(name <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> MustString(name <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> Open(name <span class="type">string</span>) (http.File, <span class="type">error</span>)</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> Resolve(key <span class="type">string</span>) (file.File, <span class="type">error</span>)</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetResolver(file <span class="type">string</span>, res resolver.Resolver)</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> String(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> Walk(wf WalkFunc) <span class="type">error</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> WalkPrefix(prefix <span class="type">string</span>, wf WalkFunc) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>​使用自定义 API 的好处就是工具开发者可以完全掌控用户体验。这包括使开发人员更轻松地管理需要在幕后维护的复杂关系。缺点也很明显，那就是使用者需要去学习这种新的 API。其代码也就严重依赖于这种自定义的 API，这使得它们难以随时间升级。</p>
<p>​另一种方式就是提供一种模拟标准库的 API ， <span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2dpdGh1Yi5jb20vbWFya2JhdGVzL3BrZ2VyQHYwLjE3LjEvcGtnaW5nI0ZpbGU=">Pkger<i class="fa fa-external-link-alt"></i></span> 就是此例之一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">	Open(name <span class="type">string</span>) (http.File, <span class="type">error</span>)</span><br><span class="line">	Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">	Readdir(count <span class="type">int</span>) ([]os.FileInfo, <span class="type">error</span>)</span><br><span class="line">	Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">	Stat() (os.FileInfo, <span class="type">error</span>)</span><br><span class="line">	Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​这种方式使用已知的、大家都熟悉的 API，会更容易吸引用户，而且也避免了再去学习新的 API 。</p>
<p><code>​Go 1.16</code>标准库引入的<code>io/fs</code>包就采用了此种方式，其优点就是使用了用户熟知的 API 接口，因此也就降低了学习成本，使得用户更加容易接受。</p>
<p>​但有其利必有其弊，虽然使用现有 API 迎合了用户使用习惯、增加了程序的兼容性，但同时也导致了大而复杂的接口。这亦是<code>io/fs</code>所面临的问题，不幸的是，要正确模拟对文件系统的调用，需要很大的接口占用空间，我们很快就会看到。</p>
<h2 id="测试基于文件系统的代码"><a href="#测试基于文件系统的代码" class="headerlink" title="测试基于文件系统的代码"></a>测试基于文件系统的代码</h2><p><code>io/fs</code>包不仅仅只是支撑<code>1.16</code> 版本<strong>嵌入</strong>功能这么简单，它带来的最大便利之一就是丰富了单元测试，它可以让我们编写更加易于测试的文件系统交互方面的代码。</p>
<p>除了增加代码的可测试性之外，<code>io/fs</code>还可以帮助我们编写更加易读的测试用例，并且在我们测试文件系统交互代码时拥有不寻常的性能表现。</p>
<p>为了更深入地了解<code>io/fs</code>包，我们来实现一段代码，它的功能是遍历一个给定的根目录，并从中搜索以<code>.go</code>结尾的文件。在循环遍历过程中，程序需要跳过一些符合我们预先设定前缀的目录，比如<code>.git</code> , <code>node_modules</code> , <code>testdata</code>等等。我们没必要去搜寻<code>.git</code> , <code>node_modules</code>文件夹，因为我们清楚它们肯定不会包含<code>.go</code>文件。一旦我们找到了符合要求的文件，我们就把文件的路径加入到一个列表中然后继续搜索。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoFiles</span><span class="params">(root <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	err := filepath.Walk(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		base := filepath.Base(path)</span><br><span class="line">		<span class="keyword">for</span> _, sp := <span class="keyword">range</span> SkipPaths &#123;</span><br><span class="line">			<span class="comment">// if the name of the folder has a prefix listed in SkipPaths</span></span><br><span class="line">			<span class="comment">// then we should skip the directory.</span></span><br><span class="line">			<span class="comment">// e.g. node_modules, testdata, _foo, .git</span></span><br><span class="line">			<span class="keyword">if</span> strings.HasPrefix(base, sp) &#123;</span><br><span class="line">				<span class="keyword">return</span> filepath.SkipDir</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// skip non-go files</span></span><br><span class="line">		<span class="keyword">if</span> filepath.Ext(path) != <span class="string">&quot;.go&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data = <span class="built_in">append</span>(data, path)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的执行结果将产生一个类似于下面这样的<code>slice</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	<span class="string">&quot;benchmarks_test.go&quot;</span>,</span><br><span class="line">	<span class="string">&quot;cmd/fsdemo/main.go&quot;</span>,</span><br><span class="line">	<span class="string">&quot;cmd/fsdemo/main_test.go&quot;</span>,</span><br><span class="line">	<span class="string">&quot;fsdemo.go&quot;</span>,</span><br><span class="line">	<span class="string">&quot;fsdemo_test.go&quot;</span>,</span><br><span class="line">	<span class="string">&quot;mock_file.go&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我现在提出的问题是：<strong>我们该如何测试这段代码？</strong>因为这段代码直接和文件系统交互，我们该如何保证在文件系统上呈现一个准确无误的测试场景呢？</p>
<p>鉴于测试方法会有很多种，在深入<code>io/fs</code>之前，我们先看一下最常见的两种方法，从而对比一下<code>io/fs</code>能带给我们怎样的便利。</p>
<h2 id="JIT-Test-File-Creation"><a href="#JIT-Test-File-Creation" class="headerlink" title="JIT Test File Creation"></a>JIT Test File Creation</h2><p>第一个测试文件系统代码的方法就是在运行时刻创建必须的文件夹结构。</p>
<blockquote>
<p>本文将以<code>benchmark</code>的方式呈现单元测试，如此我们就可以对比各种测试方法的性能。这也是为何<code>setup</code>（创建测试用的文件结构）的代码会被包含在基准代码当中，我们基准测试的目标就是<code>setup</code>的过程。在此情况下，各种测试方法都不会改变<code>setup</code>的底层函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGoFilesJIT</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line">		dir, err := ioutil.TempDir(<span class="string">&quot;&quot;</span>, <span class="string">&quot;fsdemo&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		names := []<span class="type">string</span>&#123;<span class="string">&quot;foo.go&quot;</span>, <span class="string">&quot;web/routes.go&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> SkipPaths &#123;</span><br><span class="line">			<span class="comment">// ex: ./.git/git.go</span></span><br><span class="line">			<span class="comment">// ex: ./node_modules/node_modules.go</span></span><br><span class="line">			names = <span class="built_in">append</span>(names, filepath.Join(s, s+<span class="string">&quot;.go&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, f := <span class="keyword">range</span> names &#123;</span><br><span class="line">			<span class="keyword">if</span> err := os.MkdirAll(filepath.Join(dir, filepath.Dir(f)), <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				b.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := ioutil.WriteFile(filepath.Join(dir, f), <span class="literal">nil</span>, <span class="number">0666</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				b.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list, err := GoFiles(dir)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lexp := <span class="number">2</span></span><br><span class="line">		lact := <span class="built_in">len</span>(list)</span><br><span class="line">		<span class="keyword">if</span> lact != lexp &#123;</span><br><span class="line">			b.Fatalf(<span class="string">&quot;expected list to have %d files, but got %d&quot;</span>, lexp, lact)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort.Strings(list)</span><br><span class="line"></span><br><span class="line">		exp := []<span class="type">string</span>&#123;<span class="string">&quot;foo.go&quot;</span>, <span class="string">&quot;web/routes.go&quot;</span>&#125;</span><br><span class="line">		<span class="keyword">for</span> i, a := <span class="keyword">range</span> list &#123;</span><br><span class="line">			e := exp[i]</span><br><span class="line">			<span class="keyword">if</span> !strings.HasSuffix(a, e) &#123;</span><br><span class="line">				b.Fatalf(<span class="string">&quot;expected %q to match expected %q&quot;</span>, list, exp)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​在<code>BenchmarkGoFilesJIT</code>测试用例中，我们使用<code>io/ioutil</code>包来为测试创建满足需求场景的临时文件夹和文件。此刻，意味着要创建包含<code>.go</code>文件的<code>node_modules</code>和<code>.git</code>目录，以便于确认这些<code>.go</code>文件不会出现在处理结果中。如果<code>GoFiles</code>函数正常工作的话，我们在结果集中将看到两个条目，<code>foo.go</code> 以及 <code>web/routes.go</code>。</p>
<p>​这种<code>JIT</code>方式有两大缺点：其一，随着时间的推移，编写和维护<code>setup</code>部分的代码将会变得非常麻烦，为测试用例做大量的<code>setup</code>本身也会引入更多的 bug。其二，也是最大的弊端，<code>JIT</code>测试会创建大量的文件和文件夹，这势必会在文件系统上产生大量的<code>i/o</code>竞争和<code>i/o</code>操作，从而让我们的任务性能非常低效。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: fsdemo</span><br><span class="line">cpu: Intel(R) Xeon(R) W-2140B CPU @ 3.20GHz</span><br><span class="line">BenchmarkGoFilesJIT-16							1470			819064 ns/op</span><br></pre></td></tr></table></figure>

<h2 id="Pre-Existing-File-Fixtures"><a href="#Pre-Existing-File-Fixtures" class="headerlink" title="Pre-Existing File Fixtures"></a>Pre-Existing File Fixtures</h2><p>另一种测试<code>GoFiles</code>的方法是创建一个名为<code>testdata</code>的目录，并且在里面创建好测试场景所需的全部文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">testdata</span><br><span class="line">└── scenario1</span><br><span class="line">		├── _ignore</span><br><span class="line">		│   └── ignore.go</span><br><span class="line">		├── foo.go</span><br><span class="line">		├── node_modules</span><br><span class="line">		│   └── node_modules.go</span><br><span class="line">		├── testdata</span><br><span class="line">		│   └── testdata.go</span><br><span class="line">		└── web</span><br><span class="line">				└── routes.go</span><br><span class="line"></span><br><span class="line">5 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>使用这种方法，我们就可以清理掉很多我们的测试代码，让<code>GoFiles</code>函数指向事先准备好的已包含相应测试场景的文件夹。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGoFilesExistingFiles</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"></span><br><span class="line">		list, err := GoFiles(<span class="string">&quot;./testdata/scenario1&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lexp := <span class="number">2</span></span><br><span class="line">		lact := <span class="built_in">len</span>(list)</span><br><span class="line">		<span class="keyword">if</span> lact != lexp &#123;</span><br><span class="line">			b.Fatalf(<span class="string">&quot;expected list to have %d files, but got %d&quot;</span>, lexp, lact)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort.Strings(list)</span><br><span class="line"></span><br><span class="line">		exp := []<span class="type">string</span>&#123;<span class="string">&quot;foo.go&quot;</span>, <span class="string">&quot;web/routes.go&quot;</span>&#125;</span><br><span class="line">		<span class="keyword">for</span> i, a := <span class="keyword">range</span> list &#123;</span><br><span class="line">			e := exp[i]</span><br><span class="line">			<span class="keyword">if</span> !strings.HasSuffix(a, e) &#123;</span><br><span class="line">				b.Fatalf(<span class="string">&quot;expected %q to match expected %q&quot;</span>, list, exp)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法大大减少了测试的消耗，从而提高了测试的可靠性和可读性。与JIT方法相比，此方法呈现的测试速度也快得多。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: fsdemo</span><br><span class="line">cpu: Intel(R) Xeon(R) W-2140B CPU @ 3.20GHz</span><br><span class="line">BenchmarkGoFilesExistingFiles-16                        9795            120648 ns/op</span><br><span class="line">BenchmarkGoFilesJIT-16                                  1470            819064 ns/op</span><br></pre></td></tr></table></figure>

<p>这种方法的缺点是为GoFiles函数创建可靠测试所需的文件&#x2F;文件夹的数量和组合（意指数量和组合可能都很巨大）。到目前为止，我们仅仅测试了“成功”的情况，我们还没有为错误场景或其它潜在的情况编写测试。</p>
<p>使用这种方式，一个很常见的问题就是，开发者会逐渐的为多个测试重复使用这些场景（指testdata中的测试场景）。随时间推移，开发者并非为新的测试创建新的结构，而是去更改现有的场景以满足新的测试。这将测试全部耦合在了一起，使测试代码变得异常脆弱。</p>
<p>使用<code>io/fs</code>重写<code>GoFiles</code>函数，我们将会解决所有的问题！</p>
<h2 id="使用-FS"><a href="#使用-FS" class="headerlink" title="使用  FS"></a>使用  FS</h2><p>​通过上面的了解，我们知道<code>io/fs</code>包支持针对<code>virtual file system</code>的实现（译者注：意指<code>io/fs</code>包提供了很多针对<code>fs.FS</code>的功能）。为了利用<code>io/fs</code>提供的功能，我们可以通过重写<code>GoFiles</code>函数让它接受一个<code>fs.FS</code>作为参数。在正式的代码中，我们可以调用<a target="_blank" rel="noopener" href="https://pkg.go.dev/os/#DirFS"><code>os.DirFS</code></a>来获得一个由底层文件系统支持的<code>fs.FS</code>接口的实现。</p>
<p>​为了遍历一个<code>fs.FS</code>的实现，我们需要使用<code>fs.WalkDir </code>函数，<code>fs.WalkDir </code>函数的功能近乎等同于<code>filepath.Walk</code>函数。尽管这些差异很值得推敲一番，但这超出了本文的范围，因此我们将在以后的文章中另行阐述。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoFilesFS</span><span class="params">(root <span class="type">string</span>, sys fs.FS)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	err := fs.WalkDir(sys, <span class="string">&quot;.&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, de fs.DirEntry, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		base := filepath.Base(path)</span><br><span class="line">		<span class="keyword">for</span> _, sp := <span class="keyword">range</span> SkipPaths &#123;</span><br><span class="line">			<span class="comment">// if the name of the folder has a prefix listed in SkipPaths</span></span><br><span class="line">			<span class="comment">// then we should skip the directory.</span></span><br><span class="line">			<span class="comment">// e.g. node_modules, testdata, _foo, .git</span></span><br><span class="line">			<span class="keyword">if</span> strings.HasPrefix(base, sp) &#123;</span><br><span class="line">				<span class="keyword">return</span> filepath.SkipDir</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// skip non-go files</span></span><br><span class="line">		<span class="keyword">if</span> filepath.Ext(path) != <span class="string">&quot;.go&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data = <span class="built_in">append</span>(data, path)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得益于<code>io/fs</code>包兼容性API带来的便利，<code>GoFilesFS</code>函数避免了昂贵的重写，仅需要很小的修改就可完工。</p>
<h2 id="实现-FS"><a href="#实现-FS" class="headerlink" title="实现 FS"></a>实现 FS</h2><p>现在，该函数已更新为使用<code>fs.FS</code>，让我们看看如何为它编写测试。在此之前，我们先来实现<code>fs.FS</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FS <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Open opens the named file.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// When Open returns an error, it should be of type *PathError</span></span><br><span class="line">	<span class="comment">// with the Op field set to &quot;open&quot;, the Path field set to name,</span></span><br><span class="line">	<span class="comment">// and the Err field describing the problem.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Open should reject attempts to open names that do not satisfy</span></span><br><span class="line">	<span class="comment">// ValidPath(name), returning a *PathError with Err set to</span></span><br><span class="line">	<span class="comment">// ErrInvalid or ErrNotExist.</span></span><br><span class="line">	Open(name <span class="type">string</span>) (File, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Open</code>函数接收一个文件的路径，然后返回一个<code>fs.File</code>和一个<code>error</code>。如文档所述，需要满足某些关于错误的需求。</p>
<p>对于我们的测试来说，我们将会使用一个模拟文件类型的切片，并稍后将其实现为<code>fs.FS</code>，该切片还将实现所有本次测试所需的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MockFS []*MockFile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mfs MockFS)</span></span> Open(name <span class="type">string</span>) (fs.File, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> mfs &#123;</span><br><span class="line">		<span class="keyword">if</span> f.Name() == name &#123;</span><br><span class="line">			<span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(mfs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mfs[<span class="number">0</span>].FS.Open(name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, &amp;fs.PathError&#123;</span><br><span class="line">		Op:   <span class="string">&quot;read&quot;</span>,</span><br><span class="line">		Path: name,</span><br><span class="line">		Err:  os.ErrNotExist,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>MockFS.Open</code>中，我们在已知文件列表中循环匹配请求的名称，如果匹配成功则返回该文件；如果没有找到，则尝试在第一个文件中递归打开。最后，如果没有找到，则按文档要求返回适当的<code>error</code>。</p>
<p>我们的<code>MockFS</code>目前还未实现完整，我们还需要实现<code>fs.ReadDirFS</code>接口来模拟文件。尽管<code>fs.ReadDirFS</code>文档未提及以下约束，但<code>fs.ReadDirFile</code>和<code>File.ReadDir</code>则需要它们。因此，它们也值得留意和实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadDir reads the contents of the directory and returns</span></span><br><span class="line"><span class="comment">// a slice of up to n DirEntry values in directory order.</span></span><br><span class="line"><span class="comment">// Subsequent calls on the same file will yield further DirEntry values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n &gt; 0, ReadDir returns at most n DirEntry structures.</span></span><br><span class="line"><span class="comment">// In this case, if ReadDir returns an empty slice, it will return</span></span><br><span class="line"><span class="comment">// a non-nil error explaining why.</span></span><br><span class="line"><span class="comment">// At the end of a directory, the error is io.EOF.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n &lt;= 0, ReadDir returns all the DirEntry values from the directory</span></span><br><span class="line"><span class="comment">// in a single slice. In this case, if ReadDir succeeds (reads all the way</span></span><br><span class="line"><span class="comment">// to the end of the directory), it returns the slice and a nil error.</span></span><br><span class="line"><span class="comment">// If it encounters an error before the end of the directory,</span></span><br><span class="line"><span class="comment">// ReadDir returns the DirEntry list read until that point and a non-nil error.</span></span><br></pre></td></tr></table></figure>

<p>尽管这些规则听起来令人困惑，但实际上，这种逻辑非常简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mfs MockFS)</span></span> ReadDir(n <span class="type">int</span>) ([]fs.DirEntry, <span class="type">error</span>) &#123;</span><br><span class="line">	list := <span class="built_in">make</span>([]fs.DirEntry, <span class="number">0</span>, <span class="built_in">len</span>(mfs))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> mfs &#123;</span><br><span class="line">		list = <span class="built_in">append</span>(list, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort.Slice(list, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> list[a].Name() &gt; list[b].Name()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="built_in">len</span>(list) &#123;</span><br><span class="line">		<span class="keyword">return</span> list, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list[:n], io.EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-File-接口"><a href="#实现-File-接口" class="headerlink" title="实现 File 接口"></a>实现 File 接口</h2><p>我们已经完成了<code>fs.FS</code>的实现，但仍需要实现一组接口来满足<code>fs</code>包的需要。幸运的是，我们可以将所有接口实现到一个类型当中，从而使我们的测试更加简便。</p>
<blockquote>
<p>继续之前，我要申明一点：我故意没有完全实现接口的文件读取部分，因为这将增加不必要的复杂度，而这些复杂度不是本文所需要的。所以我们将在后续的文章中探讨相关主题。</p>
</blockquote>
<p>为了测试我们的代码，我们将要实现四个接口： <code>fs.File</code> , <code>fs.FileInfo</code> , <code>fs.ReadDirFile</code> , and <code>fs.DirEntry</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">	Stat() (FileInfo, <span class="type">error</span>)</span><br><span class="line">	Read([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">	Size() <span class="type">int64</span></span><br><span class="line">	Mode() FileMode</span><br><span class="line">	ModTime() time.Time</span><br><span class="line">	IsDir() <span class="type">bool</span></span><br><span class="line">	Sys() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadDirFile <span class="keyword">interface</span> &#123;</span><br><span class="line">	File</span><br><span class="line">	ReadDir(n <span class="type">int</span>) ([]DirEntry, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DirEntry <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">	IsDir() <span class="type">bool</span></span><br><span class="line">	Type() FileMode</span><br><span class="line">	Info() (FileInfo, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍看之下，这些接口的体量之大似乎压人心魄。但是不用多虑，因为它们很多重叠的功能，所以我们可以把他们凝聚到一个类型当中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MockFile <span class="keyword">struct</span> &#123;</span><br><span class="line">	FS      MockFS</span><br><span class="line">	isDir   <span class="type">bool</span></span><br><span class="line">	modTime time.Time</span><br><span class="line">	mode    fs.FileMode</span><br><span class="line">	name    <span class="type">string</span></span><br><span class="line">	size    <span class="type">int64</span></span><br><span class="line">	sys     <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MockFile</code>类型包含一个<code>fs.FS</code>的实现<code>MockFS</code>，它将持有我们测试用到的所有文件。<code>MockFile</code> 类型中的其余字段供我们设置为其相应功能的返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> IsDir() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.isDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MockFile)</span></span> Info() (fs.FileInfo, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> mf.Stat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MockFile)</span></span> Stat() (fs.FileInfo, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> mf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> Size() <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> Mode() os.FileMode &#123;</span><br><span class="line">	<span class="keyword">return</span> m.mode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> ModTime() time.Time &#123;</span><br><span class="line">	<span class="keyword">return</span> m.modTime</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> Sys() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> m.sys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> Type() fs.FileMode &#123;</span><br><span class="line">	<span class="keyword">return</span> m.Mode().Type()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MockFile)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;not implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MockFile)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockFile)</span></span> ReadDir(n <span class="type">int</span>) ([]fs.DirEntry, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> !m.IsDir() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.ErrNotExist</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> m.FS == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m.FS.ReadDir(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像<code>Stat() (fs.FileInfo, error)</code>方法可以返回<code>MockFile </code>本身，因为它已经实现了<code>fs.FileInfo</code>接口，此为我们如何用一个<code>MockFile</code>类型实现众多所需的接口的一个例证！</p>
<h2 id="使用-FS-进行测试"><a href="#使用-FS-进行测试" class="headerlink" title="使用 FS 进行测试"></a>使用 FS 进行测试</h2><p>鉴于我们已经拥有了<code>MockFS</code> 和 <code>MockFile</code>，那么是时候为<code>GoFilesFS</code>函数编写测试了。依例，我们首先要为测试设置文件夹和文件结构。通过两个辅助函数<code>NewFile</code>和<code>NewDir</code>、以及使用切片直接构建一个<code>fs.FS</code>（指 <code>MockFS</code>）的便捷性，我们可以在内存中快速的构建出复杂的文件夹和文件结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(name <span class="type">string</span>)</span></span> *MockFile &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MockFile&#123;</span><br><span class="line">		name: name,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDir</span><span class="params">(name <span class="type">string</span>, files ...*MockFile)</span></span> *MockFile &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MockFile&#123;</span><br><span class="line">		FS:    files,</span><br><span class="line">		isDir: <span class="literal">true</span>,</span><br><span class="line">		name:  name,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGoFilesFS</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		files := MockFS&#123;</span><br><span class="line">			<span class="comment">// ./foo.go</span></span><br><span class="line">			NewFile(<span class="string">&quot;foo.go&quot;</span>),</span><br><span class="line">			<span class="comment">// ./web/routes.go</span></span><br><span class="line">			NewDir(<span class="string">&quot;web&quot;</span>, NewFile(<span class="string">&quot;routes.go&quot;</span>)),</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> SkipPaths &#123;</span><br><span class="line">			<span class="comment">// ex: ./.git/git.go</span></span><br><span class="line">			<span class="comment">// ex: ./node_modules/node_modules.go</span></span><br><span class="line">			files = <span class="built_in">append</span>(files, NewDir(s, NewFile(s+<span class="string">&quot;.go&quot;</span>)))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mfs := MockFS&#123;</span><br><span class="line">			<span class="comment">// ./</span></span><br><span class="line">			NewDir(<span class="string">&quot;.&quot;</span>, files...),</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list, err := GoFilesFS(<span class="string">&quot;/&quot;</span>, mfs)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lexp := <span class="number">2</span></span><br><span class="line">		lact := <span class="built_in">len</span>(list)</span><br><span class="line">		<span class="keyword">if</span> lact != lexp &#123;</span><br><span class="line">			b.Fatalf(<span class="string">&quot;expected list to have %d files, but got %d&quot;</span>, lexp, lact)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort.Strings(list)</span><br><span class="line"></span><br><span class="line">		exp := []<span class="type">string</span>&#123;<span class="string">&quot;foo.go&quot;</span>, <span class="string">&quot;web/routes.go&quot;</span>&#125;</span><br><span class="line">		<span class="keyword">for</span> i, a := <span class="keyword">range</span> list &#123;</span><br><span class="line">			e := exp[i]</span><br><span class="line">			<span class="keyword">if</span> e != a &#123;</span><br><span class="line">				b.Fatalf(<span class="string">&quot;expected %q to match expected %q&quot;</span>, list, exp)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本次<code> setup</code>的代码非常简单高效地完成了我们所需的工作，如果我们需要在测试中增加文件或文件夹，可以通过插入一行或两行来迅速完成。更重要的是，在尝试编写测试时，我们不会因复杂的<code>setup</code>代码而分心。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGoFilesFS-16										432418				2605 ns/op</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​使用<code>BenchmarkGoFilesJIT</code>方式，我们有很多直接操作<code>filesystem</code>的文件<code>setup</code>和<code>teardown </code>代码（译者注：指文件结构的创建和销毁），这会让测试代码本身引入很多潜在的<code>error</code>和<code>bug</code>。<code>setup</code>和<code>teardown </code>代码会让测试的重心偏移，其复杂性使得很难对测试方案进行更改。而且，这种方式的基准测试性能最差。</p>
<p>​不同的是，<code>BenchmarkGoFilesExistingFiles</code>方式使用预先在<code>testdata</code>中准备好的文件结构场景。这使得测试过程不再需要<code>setup</code>代码，仅仅需要为测试代码指明场景在磁盘中的位置。这种方式还有其它便利之处，例如其使用的是可以用标准工具轻松编辑和操纵的真实文件。与<code>JIT</code>方式相比，因其使用了已存在的场景数据，这极大地增加了测试的性能。其成本是需要在<code>repo</code>中创建和提交很多的场景数据，而且这些场景数据很容易被其他的测试代码滥用，最终导致测试用例变得脆弱不堪。</p>
<p>​这两种方式都有其它的一些缺陷，比如难以模拟大文件、文件的权限、错误等等，而<code>io/fs</code>，可以帮我们解决这些问题！</p>
<p>​我们已经看到了如何通微小的代码改动来使用<code>io/fs</code>包，得益于此，我们的测试代码变得更易于编写。这种方式不需要<code>teardown</code>代码，设置场景数据就像为切片追加数据一样简单，测试中的修改也变得游刃有余。我们的<code>MockFile</code>类型可以让我们像<code>MockFS</code>类型一样模拟出文件的大小、文件的权限、错误甚至更多。最重要的是，我们看到，通过使用io &#x2F; fs并实现其接口，与JIT测试相比，我们可以将文件系统测试的速度提高300％以上。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: fsdemo</span><br><span class="line">cpu: Intel(R) Xeon(R) W-2140B CPU @ 3.20GHz</span><br><span class="line">BenchmarkGoFilesFS-16                               432418                          2605 ns/op</span><br><span class="line">BenchmarkGoFilesExistingFiles-16                      9795                        120648 ns/op</span><br><span class="line">BenchmarkGoFilesJIT-16                                1470                        819064 ns/op</span><br></pre></td></tr></table></figure>

<p>​虽然本文介绍了如何使用新的<code>io/fs</code>包来增强我们的测试，但这只是该包的冰山一角。比如，考虑一个文件转换管道，该管道根据文件的类型在文件上运行转换程序。再比如，将.md文件从Markdown转换为HTML，等等。使用<code>io/fs</code>包，您可以轻松创建带有接口的管道，并且测试该管道也相对简单。 Go 1.16有很多令人兴奋的地方，但是，对我来说，<code>io/fs</code>包是最让我兴奋的一个。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2021/02/27/essay/sudongpo-lin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/27/essay/sudongpo-lin/" class="post-title-link" itemprop="url">此间有什么歇不得处</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-27 17:17:59" itemprop="dateCreated datePublished" datetime="2021-02-27T17:17:59+08:00">2021-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>这一篇无关技术，仅仅是在读完林语堂版《苏东坡传》之后的随笔小记。从最近开始，我要求自己尽量做到每读完一本书、一篇有感想的文章、研究过某种技术、亦或某件我认为有趣的事之后，都要写一写感受，以此磨炼一下思想、锻炼一下笔触。</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            江城子</span><br><span class="line">            </span><br><span class="line">自古相知无憎由，别离恨，不可求。如是如云，只道言曾旧。烟雨几度任回首，长东事，懒回头；</span><br><span class="line"></span><br><span class="line">生老死病却陈游，多少苦，又逢秋。今逢自杜，莫道水难流。相逢只教一碗酒，饮长孤，笑短愁。</span><br></pre></td></tr></table></figure>

<p>​	我所读诗词之中，数苏东坡的诗最多。然读诗时年少，于诗中所寄体悟不多，却年少气盛，好学东坡题词，所以很多苏东坡写过的词牌，我都附庸风雅过。上面这首《江城子》便是我18岁时写下的，从中依然能看出遣词多浮于表面，大有为赋新词强说愁的少年气。</p>
<p>​	林著《苏东坡传》原书为英文版，我读的版本是张振玉的译本。坦白讲，我是耐着性子读完这本书的，断断续续读了一年之久。感觉应该是翻译的缘故，通篇下来都是流水式的叙述，很大的篇幅都是描述作者眼中的苏东坡。私以为，这种平铺直叙式的文章，很难拉近读者的距离，也并未让作者和主人公的感情交织融合，从而也就很难引起共鸣。</p>
<p>​	林为文学大家，但我却知之甚少，此处不宜置喙。然李一冰所著《苏东坡新传》出自林书之后，文学界却评论其是意外胜过林书。所以，我在读完林书后，将继续拜读李一冰的《苏东坡新传》。</p>
<p>​	我少年时读苏诗，都是敬其诗才绝艳。诗中有不少好句子，简单易懂，郎朗上口。但囿于当时阅历尚浅，自然未能完全体会其中深意。然而，总是听人讲苏东坡乃古今文人中性情最为豁达、看世事最为通透的人，又称其在佛道方面也有不少造诣。每次听到这些评论时，我脑海中除了浮现出“竹杖芒鞋轻胜马”的诗句之外，别无其他。我才发现，对苏东坡竟一无所知！因此，我也是抱着解开心中疑问的想法去阅读林书的，很可惜我未能从中得到答案。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">心似已灰之木，</span><br><span class="line">身如不系之舟。</span><br><span class="line">问汝平生功业，</span><br><span class="line">黄州惠州儋州。</span><br></pre></td></tr></table></figure>

<p>​	这首《自题金山画像》是苏东坡临终前所作，虽是自嘲，亦是自身写照。以前读书，文人遭谪似是家常便饭，彼时也不做他想。而今读林书方才知道，苏轼的一生经历了北宋仁宗、英宗、神宗、哲宗、徽宗五朝，官至正三品，是仅次于宰相的朝中大员。授翰林学士、端明殿侍读学士，还做过兵部和礼部尚书。他的一生担任过30多个官职，遭过三次贬谪，辗转奔波于凤翔、杭州、密州、徐州、湖州、黄州、登州、颖州、扬州、定州、惠州、儋州等地，足迹踏遍大半个中国。</p>
<p>​	如此起落的人生，如此崎岖坎坷的经历，若不是有非常的旷达之心，怎能经受？若不是看破了得失荣辱，历尽了艰难困苦，又怎么会写出“此间有什么歇不得处”之句呢？</p>
<p>​	我读林书，唯一所获，便是这句：“此间有什么歇不得处？由是如挂勾之鱼，忽得解脱。”</p>
<p>​	原文如下：</p>
<p><strong>余尝寓居惠州嘉佑寺，纵步松风亭下。足力疲乏，思欲就亭止息。望亭宇尚在木末，意谓是如何得到？良久，忽曰：“此间有什么歇不得处？”由是如挂勾之鱼，忽得解脱。若人悟此，虽兵阵相接，鼓声如雷霆，进则死敌，退则死法，当恁么时也不妨熟歇。</strong></p>
<p>​	文章题目标明“记游”，本可记述游历经过和松风亭的由来及四周的景物。但苏东坡非为叙事，而是明理。从“意谓如何得到”，悟出世间“有甚么歇不得处”的道理。这种即时放下，随遇而安，“当恁么时，也不妨熟歇”的旷达态度，正是苏轼从自己丰富的人生磨砺中，触动外物，偶然得之的。一件本来令人沮丧的遭遇，换个角度想，豁然开朗，“由是如挂钩之鱼，忽得解脱”。</p>
<p>​	这种思考方式，在后来贬谪过程中不断从苏轼笔下表现出来，这既是苏轼对自己生活困境的一种积极反抗——以乐处哀，又是苏轼在具体现实中始终不堕其精神品格、自我提升到一种旷远开阔境地的呈示。</p>
<p>​	我们读书要讲究向自家身心上用工夫，遂由此联想到自己。我本是一个平庸之人，奈何却不甘平庸，因此平白多了些烦恼。一边面对的是人外有人、天外有天的事实，所见之处都是比自己优秀的人；另一边面对的是从小所受的“世上无难事，只要肯攀登“的教育思想。便时常夹在其中，备受煎熬。直至读东坡此语，我的心亦如那挂钩之鱼，终得解脱！</p>
<p>​	是啊，此间有什么歇不得处？对于东坡而言，放下顾虑，此间便可好好休息，放下顾虑，此处亦是值得珍惜的人生。对我而言，放下顾虑，此间便可好好做事，可读一本没读过的书，可学一门新的语言，可以陪女儿度过一个愉快的周末，而不必担心还有未完成的博文......</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">亭楼非我驻,</span><br><span class="line">林下亦可留。</span><br><span class="line">去就随我意，</span><br><span class="line">不戚亦不求。</span><br></pre></td></tr></table></figure>



<p>后记：写这篇随笔的时候，香港演员吴孟达因病离世，陪伴我们成长的达叔永远的离开了我们。它曾带给年少的我们欢笑和泪水，是一个在喜剧中留下深情的人...</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2021/01/15/design_patterns/strategy-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/15/design_patterns/strategy-go/" class="post-title-link" itemprop="url">策略模式（下）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-15 18:22:55" itemprop="dateCreated datePublished" datetime="2021-01-15T18:22:55+08:00">2021-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DesignPatterns/" itemprop="url" rel="index"><span itemprop="name">DesignPatterns</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DesignPatterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>​	我在上一篇 <a href="https://liupzmin.com/2021/01/03/design_patterns/strategy/">策略模式（上）</a> 中介绍了<code>策略模式</code>的概念，并使用传统的<code>OO</code>语言<code>Java</code>实现了一个模拟鸭子游戏的例子。而当今一些新兴的编程语言，并不算严格意义上的<strong>面向对象</strong>语言，比如<code>Go</code>、<code>Rust</code> 等。若从面向对象严格的定义上讲，它们并没有<strong>类、继承</strong>等特性，没有严格遵守<code>OO</code>的四大特性，也就是非严格意义上的面向对象语言。</p>
<p>​	实际上，对于什么是面向对象编程、什么是面向对象编程语言，并没有一个官方的、统一的定义。而且，从 <code>1960</code> 年，也就是 <code>60</code> 年前面向对象编程诞生开始，这两个概念就在不停地演化，所以，也无法给出一个明确的定义，也没有必要给出一个明确定义。</p>
<p>​	在此，我们不做学院派，也不替圣人争长短，揪住概念不放。我们仅仅从语言的特性上来考虑问题，看同样的设计模式，在新时代的语言中会带给我们怎样的惊喜。接下来我以<code>Go</code>语言为例，重新使用<code>策略模式</code>实现我们上一篇中的模拟鸭子的游戏。</p>
<h2 id="超类在哪里"><a href="#超类在哪里" class="headerlink" title="超类在哪里"></a>超类在哪里</h2><p>​	我们在上一篇文章中使用抽象类和继承来实现多态，超类就是抽象类。但是<code>Go</code>并没有提供经典<code>OO</code>语言中的类和继承，那么要实现多态我们只有<code>接口</code>可用，因此这里可以将接口视为<code>超类</code>。但是<code>Go</code>的接口又不完全等同于<code>Java</code>的接口，<strong>Go的接口实现是完全隐式的</strong>。</p>
<p>​	<code>interface</code>是<code>Go</code>语言中真正的魔法，是<code>Go</code>语言的一个创新设计，它只是方法集合，并且它与实现者之间的关系是隐式的。它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间“纽带”。隐式的<code>interface</code>实现会不经意间满足：依赖抽象、里氏替换、接口隔离等原则，这在其他语言中是需要很&quot;刻意&quot;的设计谋划才能实现的，但在<code>Go interface</code>来看，一切却是自然而然的。</p>
<p>​	我们首先定义一个鸭子接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">    Display()</span><br><span class="line">    Fly()</span><br><span class="line">    Quack()</span><br><span class="line">    Swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	按照鸭子的抽象，我们定义了<code>Display</code>、<code>Swim</code>、<code>Fly</code>和<code>Quack</code>四个方法，意在每个接口的实现者都提供自己独立的方法实现。根据上一篇的讨论，这里面混合了<strong>不变的、可能会变的、一定会变</strong>的内容，根据这样的接口去实现会带来代码无法复用和维护上的难题。</p>
<p>​	这里面只有<code>Display</code>是一定会变的，所以可以继续留在<code>Duck</code>接口中。而<code>Fly</code>和<code>Quack</code>是可能会变的，根据我们上一篇总结的原则，应该把可能会变的内容抽离出去，用单独的类实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Flier 接口</span></span><br><span class="line"><span class="keyword">type</span> Flier <span class="keyword">interface</span> &#123;</span><br><span class="line">	Fly()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FlyWithWings 实现了 Flier 接口</span></span><br><span class="line"><span class="keyword">type</span> FlyWithWings <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FlyWithWings)</span></span> Fly() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I am flying with my  wings!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlyNoWay 实现了 Flier 接口</span></span><br><span class="line"><span class="keyword">type</span> FlyNoWay <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FlyNoWay)</span></span> Fly() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I can not fly!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlyWithRocket 实现了 Flier 接口</span></span><br><span class="line"><span class="keyword">type</span> FlyWithRocket <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FlyWithRocket)</span></span> Fly() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I am flying with a rocket!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Quacker 接口</span></span><br><span class="line"><span class="keyword">type</span> Quacker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QuackNormal 实现了 Quacker 接口</span></span><br><span class="line"><span class="keyword">type</span> QuackNormal <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q QuackNormal)</span></span> Quack() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Quack Quack!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Squeak 实现了 Quacker 接口</span></span><br><span class="line"><span class="keyword">type</span> Squeak <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Squeak)</span></span> Quack() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Squeak Squeak!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// QuackMute 实现了 Quacker 接口</span></span><br><span class="line"><span class="keyword">type</span> QuackMute <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q QuackMute)</span></span> Quack() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I can not Quack!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前的 Duck 接口</span></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">    Display()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们分别定义了<code>Flier</code>和<code>Quacker</code>接口，并分别为之提供了多种对应的实现。根据<code>Java</code>的经验， 这时候应该在抽象类里面声明接口成员变量，将行为委托出去，但是<code>Go</code>中的接口仅仅定义了行为方法，无法定义成员，我们该如何将<code>Fly</code>和<code>Quack</code>的行为委托出去呢？</p>
<p>​	而且，接口中也无法定义方法实现，那么我们又该如何继承<code>Swim</code>的行为呢？</p>
<h2 id="忘掉继承，使用组合"><a href="#忘掉继承，使用组合" class="headerlink" title="忘掉继承，使用组合"></a>忘掉继承，使用组合</h2><p>​	<code>Go</code>语言提供了的最为直观的组合的语法元素就是<strong>type embedding</strong>，即<strong>类型嵌入</strong>。通过类型嵌入，我们可以将已经实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有些类似经典<code>OO</code>的“继承”，但在原理上与经典<code>OO</code>的继承完全不同。这是一种<code>Go</code>精心设计的“语法糖”，被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典<code>OO</code>那种父类、子类的关系以及向上、向下转型(<code>type casting</code>)。</p>
<p>​	通过新类型实例调用方法时，<strong>方法的匹配取决于方法名字，而不是类型</strong>。这种组合方式，我称之为“垂直组合”，即通过类型嵌入，快速让一个新类型“复用”其他类型已经实现的能力，实现功能的垂直扩展。</p>
<p>​	利用类型嵌入，我们可以定义一个基础的鸭子结构，并在其中嵌入<code>Flier</code>和<code>Quacker</code>接口，以达到行为委托的目的。而在接下来实现具体鸭子时将基础结构体嵌入，即可达到了垂直组合的效果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DuckBase <span class="keyword">struct</span> &#123;</span><br><span class="line">	Flier</span><br><span class="line">	Quacker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DuckBase)</span></span> SetFlyBehaviro(f Flier) &#123;</span><br><span class="line">	d.Flier = f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DuckBase)</span></span> SetQuackBehaviro(q Quacker) &#123;</span><br><span class="line">	d.Quacker = q</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述代码定义了<code>DuckBase</code>结构体，并在其中嵌入了<code>Flier</code>和<code>Quacker</code>接口（我们还提供了设置行为的方法），如果要初始化<code>DuckBase</code>就必须使用<code>Flier</code>和<code>Quacker</code>的实现来构造；根据类型嵌入的规则：<strong>将已经实现的功能嵌入到新类型中，新类型便会获得被嵌入类型的功能</strong>，这相当于<code>DuckBase</code>也实现了<code>Flier</code>和<code>Quacker</code>接口。</p>
<p>​	我们来看一个具体的鸭子实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MallardDuck <span class="keyword">struct</span> &#123;</span><br><span class="line">	*DuckBase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MallardDuck)</span></span> Display() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;my head is green!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedheadDuck <span class="keyword">struct</span> &#123;</span><br><span class="line">	*DuckBase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r RedheadDuck)</span></span> Display() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;my head is red!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RubberDuck <span class="keyword">struct</span> &#123;</span><br><span class="line">	*DuckBase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r RubberDuck)</span></span> Display() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I am rubber duck!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上述代码片段提供了三种鸭子的实现，它们都嵌入了<code>*DuckBase</code>结构（因为我们的行为设置方法是指针接收器），并且分别实现了<code>Duck</code>接口。</p>
<p>​	既然可以通过类型嵌入来达到类似于“继承”的效果，那么我们完全可以让<code>DuckBase</code>结构体实现<code>Swim</code>方法，这样一来，每一个鸭子的实现都可以复用<code>Swim</code>的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d DuckBase)</span></span> Swim() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I am swimming!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	现在，请仔细回想，让我们沿着回忆的小路再多走几遍：</p>
<ol>
<li><code>*DuckBase</code> 嵌入了<code>Flier</code>、<code>Quacker</code>接口，并实现了<code>Swim</code>方法</li>
<li>等于<code>*DuckBase</code> 实现了<code>Flier</code>、<code>Quacker</code>接口和<code>Swim</code>方法</li>
<li><code>具体的鸭子实现</code>嵌入了<code>*DuckBase</code> 结构</li>
<li>等于<code>具体的鸭子实现</code>实现了<code>Flier</code>和<code>Quacker</code>接口，以及<code>Swim</code>方法</li>
</ol>
<p>我们就可以回到最初的<code>Duck</code>接口了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">    Display()</span><br><span class="line">    Fly()</span><br><span class="line">    Quack()</span><br><span class="line">    Swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Go</code>提供了接口组合的功能，也就是可以通过接口嵌入达到用小接口组合为大接口的目的，所以我们可以修改为接口嵌入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Flier</span><br><span class="line">	Quacker</span><br><span class="line">	Display()</span><br><span class="line">	Swim()</span><br><span class="line">	SetFlyBehaviro(Flier)</span><br><span class="line">	SetQuackBehaviro(Quacker)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过组合和类型嵌入的方式构建了一个大而全、抽象度低的<code>Duck</code>接口，且完全避免了之前用继承带来的弊端。我们可以自由替换行为，也可以利用多态，且合理的实现了代码复用，同时又不会有维护上的困扰。最关键的是，我们有了一个无比自然的<code>Duck</code>接口，我们上一篇所有的努力都是在构建一个我们逻辑认知上的一个自然的<code>Duck</code>接口。</p>
<p>现在，<code>Go</code>很轻松就做到了！</p>
<h2 id="游戏时刻"><a href="#游戏时刻" class="headerlink" title="游戏时刻"></a>游戏时刻</h2><p>继续使用上一篇的例子来测试一下我们的成果吧：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mo := MallardDuck&#123;&amp;DuckBase&#123;Flier: FlyWithWings&#123;&#125;, Quacker: QuackNormal&#123;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">	mo.Display()</span><br><span class="line">	mo.Fly()</span><br><span class="line">	mo.Quack()</span><br><span class="line">	mo.Swim()</span><br><span class="line"></span><br><span class="line">	mo.SetFlyBehaviro(FlyWithRocket&#123;&#125;)</span><br><span class="line">	mo.Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my head is green!</span><br><span class="line">I am flying with my  wings!</span><br><span class="line">Quack Quack!</span><br><span class="line">I am swimming!</span><br><span class="line">I am flying with a rocket!</span><br></pre></td></tr></table></figure>

<p>文章中的代码见：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL0xlYXJuaW5nL2Jsb2IvbWFzdGVyL2Rlc2lnbi1wYXR0ZXJucy9zdHJhdGVneS9zdHJhdGVneS5nbw==">strategy-go<i class="fa fa-external-link-alt"></i></span></p>
<p>有一点差点忘记，我们实现了<strong>策略模式</strong>！</p>
<h2 id="接下来是什么"><a href="#接下来是什么" class="headerlink" title="接下来是什么"></a>接下来是什么</h2><p>还记得我们的“针对接口编程，而不是针对实现编程”的设计准则么？</p>
<p>我们在上一篇<code>Java</code>的实现中使用多态时是通过new来实例化一个实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Duck</span> <span class="variable">mallard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MallardDuck</span>();</span><br><span class="line">mallard.performQuack();</span><br><span class="line">mallard.performFly();</span><br><span class="line">   </span><br><span class="line"><span class="type">Duck</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelDuck</span>();</span><br><span class="line">model.performFly();</span><br><span class="line">model.setFlyBehavior(<span class="keyword">new</span> <span class="title class_">FlyRocketPowered</span>());</span><br><span class="line">model.performFly();</span><br></pre></td></tr></table></figure>
<p>在本篇中，我们直接使用实现类型的字面量初始化的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mo := MallardDuck&#123;&amp;DuckBase&#123;Flier: FlyWithWings&#123;&#125;, Quacker: QuackNormal&#123;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这似乎违反了针对接口编程的设计准则，因为我们的代码里包含了具体实现的代码。所以，接下来我们会进入<code>工厂模式</code>的学习，在此之前先解释一点：虽然是针对接口编程，但是我们不能把实现完全消灭，因为程序的运行最后依然靠的是具体实现。那么，我们就需要有一个很好的方法将其组织起来，这就是<code>工厂模式</code>！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"liupzmin","repo":"liupzmin.github.io","client_id":"77654195445087c01c56","client_secret":"eda09eecd05b86f0ef995d8067ec751abeb753d9","admin_user":"liupzmin","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","ClientID":"ae0756501dfc5de89d35","ClientSecret":"26befb359f7a466031bb96b4b7e0715c41c63fb8","owner":"liupzmin","adminUser":"['liupzmin']","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","createIssueManually":true,"distractionFreeMode":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"c853ec00cc9d13bc22336b7d45d1416e"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
