<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liupzmin.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="左手人文 | 右手科技">
<meta property="og:type" content="website">
<meta property="og:title" content="兔子先生">
<meta property="og:url" content="http://liupzmin.com/page/4/index.html">
<meta property="og:site_name" content="兔子先生">
<meta property="og:description" content="左手人文 | 右手科技">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="巴流">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://liupzmin.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>兔子先生 - 探寻计算机的历史与哲学密码</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="兔子先生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">兔子先生</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探寻计算机的历史与哲学密码</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">63</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="巴流"
      src="/images/gzh.jpg">
  <p class="site-author-name" itemprop="name">巴流</p>
  <div class="site-description" itemprop="description">左手人文 | 右手科技</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liupzmin"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdXB6bWluQGdtYWlsLmNvbQ==" title="E-Mail → mailto:liupzmin@gmail.com"><i class="envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/10/18/golang/golang-new-make/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/18/golang/golang-new-make/" class="post-title-link" itemprop="url">Go语言中的new和make-从函数阻击战到nil遭遇战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-18 09:30:46" itemprop="dateCreated datePublished" datetime="2019-10-18T09:30:46+08:00">2019-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go语言中有两个<code>builtin</code>函数<code>new</code>和<code>make</code>，这个两个函数经常让初学者摸不着头脑，也许使用过程中并未有什么阻碍，但回过头看细想又难以说清道明。本文将针对这两个函数进行分析，希望能抽丝剥茧，彻底搞清楚他们的区别。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>当然，我们先看Go官方对这两个函数的解释：</p>
<h3 id="func-new-Type-Typel"><a href="#func-new-Type-Typel" class="headerlink" title="func new(Type) *Typel"></a>func new(Type) *Typel</h3><blockquote>
<p>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</p>
</blockquote>
<p><strong>大意：new函数会分配内存，它唯一的一个参数是<code>type</code>不是value，返回值是一个指针，指向刚刚分配的那块内存，并且这块内存中存储着<code>type</code>的<code>零值（zero value）</code>。</strong></p>
<p>重点：</p>
<ol>
<li>分配内存</li>
<li>返回指向这块内存的指针</li>
<li>内存存储<code>type</code>的<code>零值</code></li>
</ol>
<h3 id="func-make-t-Type-size-IntegerType-Type"><a href="#func-make-t-Type-size-IntegerType-Type" class="headerlink" title="func make(t Type, size ...IntegerType) Type"></a>func make(t Type, size ...IntegerType) Type</h3><blockquote>
<p>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make&#39;s return type is the same as the type of its argument, not a pointer to it.</p>
</blockquote>
<p><strong>大意：make仅用于分配和初始化<code>slice、map、chanel</code>，同new一样，第一个参数要传入一个<code>type</code>；不同的是，make返回的是初始化过之后的<code>type</code>的一个值，而不是指针。</strong></p>
<p>重点：</p>
<ol>
<li>分配内存并初始化</li>
<li>仅用于<code>slice</code>、<code>map</code>、<code>chanel</code></li>
<li>返回的是值，不是指针</li>
</ol>
<h2 id="zero-value"><a href="#zero-value" class="headerlink" title="zero value"></a>zero value</h2><p>上文提到<code>new()</code>会分配内存，并且为相应的<code>Type</code>存储<code>零值</code>，<code>那什么是零值呢？</code>官方对于<code>zero value</code>的描述如下：</p>
<blockquote>
<p>When storage is allocated for a variable, either through a declaration or a call of new, or when a new value is created, either through a composite literal or a call of make, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: false for booleans, 0 for numeric types, &quot;&quot; for strings, and nil for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.</p>
</blockquote>
<p><strong>大意：当通过声明或调用new为变量分配存储时，或者在创建新值时(通过复合字面值或调用make)，并且没有提供显式初始化时，将为变量或值提供默认值。此类变量或值的每个元素的类型都设置为该类型的零值:布尔值为false，数值类型为0，字符串为&quot;&quot;，指针、函数、接口、片、通道和映射为nil。这个初始化是递归完成的，因此，如果结构体中没有指定相应field的值，那么默认将是该field的零值。</strong></p>
<p>下面表格中展示了Go中主要类型的零值：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Zero Value</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>numeric</td>
<td>0</td>
</tr>
<tr>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
<tr>
<td>pointer</td>
<td>nil</td>
</tr>
<tr>
<td>function</td>
<td>nil</td>
</tr>
<tr>
<td>interface</td>
<td>nil</td>
</tr>
<tr>
<td>slice</td>
<td>nil</td>
</tr>
<tr>
<td>map</td>
<td>nil</td>
</tr>
<tr>
<td>channel</td>
<td>nil</td>
</tr>
</tbody></table>
<p>其中，array和struct两个复合类型的零值为其承载的基础类型的零值，因为array和struct都是值类型，不像slice、map是引用类型。</p>
<p>但是，个人感觉上面一段话中关于<code>通过复合字面值或调用make</code>创造值的相关描述略有不准确。因为<code>Composite literals(复合字面值)</code>是为<code>structs</code>、<code>arrays</code>、<code>slices</code>、<code>maps</code>构造值，而<code>make</code>仅用于分配并初始化<code>slice</code>、<code>map</code>、<code>chanel</code>。如果使用<code>字面值</code>构造一个值且不显示的初始化，那么该值就是一个<code>空值（empty）</code>，和<code>make</code>的结果相同,<code>而不是零值nil</code>。看下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nilSlice []<span class="type">string</span></span><br><span class="line">newNilSlice := <span class="built_in">new</span>([]<span class="type">string</span>)</span><br><span class="line">emptySlice := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">emptySliceLiteral := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">fmt.Println(nilSlice)                                       <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nilSlice), <span class="built_in">cap</span>(nilSlice))                   <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(nilSlice == <span class="literal">nil</span>)                                <span class="comment">// Output: true</span></span><br><span class="line">fmt.Println(*newNilSlice)                                   <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(*newNilSlice), <span class="built_in">cap</span>(*newNilSlice))           <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(*newNilSlice == <span class="literal">nil</span>)							<span class="comment">// Output: true</span></span><br><span class="line">fmt.Println(emptySlice)                                     <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(emptySlice), <span class="built_in">cap</span>(emptySlice))               <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(emptySlice == <span class="literal">nil</span>)                              <span class="comment">// Output: false</span></span><br><span class="line">fmt.Println(emptySliceLiteral)                              <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(emptySliceLiteral), <span class="built_in">cap</span>(emptySliceLiteral)) <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(emptySliceLiteral == <span class="literal">nil</span>)                       <span class="comment">// Output: false</span></span><br></pre></td></tr></table></figure>

<p>像<code>slice</code>、<code>map</code>这样的引用类型的<code>零值是nil</code>，并不是<code>“the variable or value is given a default value”</code>，因为<code>通过复合字面值或调用make</code>构造变量时<code>default value</code>是<code>empty</code>。（<em><strong>如果有人觉得这是咬文嚼字，那我也只能承认，毕竟nil让我很痛苦，后面我会再论述default value</strong></em>）。</p>
<p>一个<code>nil的slice</code>和一个<code>Empty的slice</code>很容易让你迷惑，它们都被<code>fmt.Println</code>打印出<code>[]</code>，它们拥有相同的<code>length</code>和<code>capacity</code>。</p>
<p>除非<code>nil</code>或者<code>Empty</code>会对你的逻辑产生影响，否则不用区别对待它们。如果你需要测试一个slice是否是空的，使用<code>len(s) == 0</code>来判断，而不应该用<code>s == nil</code>来判断。除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样。</p>
<p>另一个值得注意的问题是，当你使用<code>encoding/json</code>时，你要特别注意：Golang的<code>encoding/json</code>会将<code>Nil Slice</code>编码为<code>null</code>。</p>
<h2 id="what-is-nil？"><a href="#what-is-nil？" class="headerlink" title="what is nil？"></a>what is nil？</h2><h3 id="nil的定义"><a href="#nil的定义" class="headerlink" title="nil的定义"></a>nil的定义</h3><p>nil 为预声明的标示符，定义在builtin&#x2F;builtin.go，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// nil is a predeclared identifier representing the zero value for a</span><br><span class="line">// pointer, channel, func, interface, map, or slice type.</span><br><span class="line">// Type must be a pointer, channel, func, interface, map, or slice type</span><br><span class="line">var nil Type </span><br><span class="line"></span><br><span class="line">// Type is here for the purposes of documentation only. It is a stand-in</span><br><span class="line">// for any Go type, but represents the same type for any given function</span><br><span class="line">// invocation.</span><br><span class="line">type Type int</span><br></pre></td></tr></table></figure>

<p>可见，<code>nil没有默认类型</code>，它是一个预定义好的变量，有多种可能的类型（<code>pointer</code>、<code>map</code>、<code>slice</code>、<code>function</code>、<code>channel</code>、<code>interface</code>）。它代表指针、通道、函数、接口、映射或切片的<code>零值</code>。</p>
<p>你必须给编译器以足够的信息，使得编译器可以推导出nil的类型，因此下面的使用方式是非法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="literal">nil</span> <span class="comment">// illegal， doesn&#x27;t compile</span></span><br></pre></td></tr></table></figure>

<p>正确的做法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// There must be sufficient information for</span></span><br><span class="line">	<span class="comment">// compiler to deduce the type of a nil value.</span></span><br><span class="line">	_ = (*<span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)</span><br><span class="line">	_ = []<span class="type">int</span>(<span class="literal">nil</span>)</span><br><span class="line">	_ = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>(<span class="literal">nil</span>)</span><br><span class="line">	_ = <span class="keyword">chan</span> <span class="type">string</span>(<span class="literal">nil</span>)</span><br><span class="line">	_ = (<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(<span class="literal">nil</span>)</span><br><span class="line">	_ = <span class="keyword">interface</span>&#123;&#125;(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This lines are equivalent to the above lines.</span></span><br><span class="line">	<span class="keyword">var</span> _ *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ []<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">chan</span> <span class="type">string</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="nil的地址"><a href="#nil的地址" class="headerlink" title="nil的地址"></a>nil的地址</h3><p>各种类型的<code>nil</code>的内存布局始终相同,换一句话说就是：不同类型nil的内存地址是一样的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> sl []<span class="type">int</span></span><br><span class="line">	testNewAddr := <span class="built_in">new</span>([]<span class="type">string</span>)</span><br><span class="line">	testMakeAddr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, m)            	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, ptr)          	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, sl)           	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, *testNewAddr) 	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, testMakeAddr) 	<span class="comment">//0x57db60</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，值为<code>nil</code>的变量都指向同样的内存地址<code>0x0</code>，这是一个无效的地址，如果对这个地址进行读写，会引发<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p *<span class="type">int</span>  <span class="comment">// Declare a nil value pointer</span></span><br><span class="line">	*p = <span class="number">10</span>		<span class="comment">// Write the value 10 to address 0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x4525b2]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/home/alarm/go/test/test.go:5 +0x2</span><br></pre></td></tr></table></figure>

<p>我们来看一下这段代码的<code>plan9汇编</code>指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go tool objdump -s main<span class="number">.</span>main <span class="keyword">test</span></span><br><span class="line"></span><br><span class="line">TEXT main<span class="number">.</span>main(SB) /home/alarm/go/<span class="keyword">test</span>/<span class="keyword">test</span><span class="number">.</span>go</span><br><span class="line"><span class="symbol">  test.go:</span><span class="number">5</span>		<span class="number">0x4525b0</span>		31c0				XORL <span class="built_in">AX</span>, <span class="built_in">AX</span>		</span><br><span class="line"><span class="symbol">  test.go:</span><span class="number">5</span>		<span class="number">0x4525b2</span>		48c7000a000000		<span class="keyword">MOVQ</span> <span class="number">$0</span>xa, <span class="number">0</span>(<span class="built_in">AX</span>)	</span><br><span class="line"><span class="symbol">  test.go:</span><span class="number">6</span>		<span class="number">0x4525b9</span>		c3					<span class="keyword">RET</span>				</span><br></pre></td></tr></table></figure>
<p>从汇编指令可以看到，<code>AX</code>寄存器被清零，之后试图将<code>0xa</code>（10）写入<code>AX指向的内存地址</code>，然后就导致了panic。</p>
<p><em><strong>现在我们可以作如下总结：</strong></em></p>
<blockquote>
<p><code>非引用类型</code>一旦赋予<code>default value</code>（或者说<code>zero value</code>），那么将会实际分配内存，并且内存中数据初始化为相应类型的<code>zero value</code>；而零值为<code>nil</code>的类型都是<code>引用类型</code>，其背后引用了使用前必须初始化的数据结构，它们的<code>default value</code>为<code>nil</code>，尚未分配内存，相应的数据结构也未被初始化。例如，slice是一个三元描述符，包含一个指向数据（在数组中）的指针、长度、以及容量，在这些项被初始化之前，slice都是nil的。对于slice，map和channel，make初始化这些内部数据结构，并准备好可用的值（对应类型的<code>zero value</code>）。</p>
</blockquote>
<h3 id="不是关键字"><a href="#不是关键字" class="headerlink" title="不是关键字"></a>不是关键字</h3><p>另一个值得注意的地方：<code>nil不是Go的关键字</code>，你可以重写他，但是最好不要这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="literal">nil</span> := <span class="number">123</span></span><br><span class="line">	fmt.Println(<span class="literal">nil</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following line fails to compile,</span></span><br><span class="line">	<span class="comment">// for nil represents an int value now</span></span><br><span class="line">	<span class="comment">// in this scope.</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kinds-of-nil"><a href="#kinds-of-nil" class="headerlink" title="kinds of nil"></a>kinds of nil</h2><p>我们知道nil的种类有<code>pointer</code>, <code>channel</code>, <code>func</code>, <code>interface</code>, <code>map</code>, or <code>slice</code>，下面分别讨论一下这几种类型的nil行为。</p>
<p>先说明一下这几种类型的nil含义：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>pointer</td>
<td>什么也不指向</td>
</tr>
<tr>
<td>function</td>
<td>没有初始化</td>
</tr>
<tr>
<td>interface</td>
<td>没有赋值，空指针</td>
</tr>
<tr>
<td>slice</td>
<td>没有底层数组</td>
</tr>
<tr>
<td>map</td>
<td>没有初始化</td>
</tr>
<tr>
<td>channel</td>
<td>没有初始化</td>
</tr>
</tbody></table>
<h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><p>在go中，指针指向一个内存地址，同c&#x2F;c++中一样，但go中的指针没有指针运算，所以是安全的。可以有以下几种方式生成pointer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 第一种：直接声明指针类型</span></span><br><span class="line">	<span class="keyword">var</span> p *[]<span class="type">int</span></span><br><span class="line">	fmt.Println(p == <span class="literal">nil</span>)		<span class="comment">// Output: true</span></span><br><span class="line">	fmt.Println(*p == <span class="literal">nil</span>)		<span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	<span class="comment">// 第二种：使用new()函数返回指针</span></span><br><span class="line">	pNew := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(pNew == <span class="literal">nil</span>)	<span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(*pNew == <span class="literal">nil</span>)	<span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三种：通过取址符&amp;，产生一个指向变量的指针</span></span><br><span class="line">	s := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	pAnd := &amp;s</span><br><span class="line">	fmt.Println(pAnd == <span class="literal">nil</span>)	<span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(*pAnd == <span class="literal">nil</span>)	<span class="comment">// Output: false</span></span><br><span class="line">	<span class="comment">// 给nil的指针赋值</span></span><br><span class="line">	p = &amp;s</span><br><span class="line">	fmt.Println(p == <span class="literal">nil</span>)		<span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(*p == <span class="literal">nil</span>)		<span class="comment">// Output: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我故意用了<code>slice</code>的指针类型，因此当pNew不是nil的时候，<code>*pNew依然是nil</code>。</p>
<p><code>nil的指针无法解引用，如果试图对一个nil的指针解引用的话会产生panic。</code></p>
<p><code>但是Nil却可以作为合法的接收器：</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> PointerReciver <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *PointerReciver)</span></span> showme()&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Yeah, it works!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ta *PointerReciver</span><br><span class="line">	ta.showme()		<span class="comment">// Yeah, it works!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>slice的底层是一个数组，那么一个nil的slice是没有底层数组的。一个<code>nil</code>的或者<code>长度为0的非nil</code>的slice都无法被索引，但是可以使用<code>append</code>去填充值。下面代码展示了各种构造slice的方式，以及nil的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//  显示声明</span></span><br><span class="line">	<span class="keyword">var</span> ts []<span class="type">int</span></span><br><span class="line">	fmt.Println(ts == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	ts[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	ts = <span class="built_in">append</span>(ts, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用new函数</span></span><br><span class="line">	p := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(*p == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	(*p)[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	*p = <span class="built_in">append</span>(*p, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用字面值初始化</span></span><br><span class="line">	literal := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	fmt.Println(literal == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	literal[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	literal = <span class="built_in">append</span>(literal, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用make初始化</span></span><br><span class="line">	mp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(mp == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	mp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	mp = <span class="built_in">append</span>(mp, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从数组截取</span></span><br><span class="line">	arrayExample := [<span class="number">10</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	sliceFromArray := arrayExample[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">	fmt.Println(sliceFromArray == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	sliceFromArray[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	sliceFromArray = <span class="built_in">append</span>(sliceFromArray, <span class="number">2</span>) <span class="comment">// slice: [1 0 0 2]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tnilslice []<span class="type">int</span></span><br><span class="line">	<span class="comment">// 不会迭代</span></span><br><span class="line">	<span class="keyword">for</span> k ,v := <span class="keyword">range</span> tnilslice&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;k: %d, v: %d\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Slice小结：</strong></p>
<p><em><strong>1. 显示声明、未初始化值时为nil</strong></em><br><em><strong>2. 使用new函数生成slice为nil</strong></em><br><em><strong>3. 字面值初始化的slice，未提供具体值的为Empty，不是nil，但长度和容量与nil相同都为0</strong></em><br><em><strong>4. 使用make初始化的slice未提供长度和容量的为Empty，提供的初始化为相应类型的零值</strong></em><br><em><strong>5. nil和Empty的slice（长度为0）无法被索引</strong></em><br><em><strong>6. 使用for...range遍历nil的slice不会迭代，也不会报错</strong></em></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map的底层是一个哈希表，通过内置的make函数可以快速构建一个map。make创建map时，实际底层调用的是<code>makemap</code>函数，返回值是一个结构体指针。</p>
<blockquote>
<p>func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap</p>
</blockquote>
<p>使用make可以选填<code>capacity </code>，capacity 不限制map的大小，map会自适应增长，但是nil的map除外。除了不允许添加元素以外，nil的map等价于Empty的map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接声明</span></span><br><span class="line">	<span class="keyword">var</span> dmap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	fmt.Println(dmap == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	fmt.Println(dmap[<span class="string">&quot;a&quot;</span>])   <span class="comment">// Output: 0</span></span><br><span class="line">	dmap[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>            <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line">	<span class="built_in">delete</span>(dmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用new函数</span></span><br><span class="line">	nmap := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(*nmap == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	fmt.Println((*nmap)[<span class="string">&quot;a&quot;</span>]) <span class="comment">// Output: 0</span></span><br><span class="line">	(*nmap)[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>          <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line">	<span class="built_in">delete</span>(*nmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字面量初始化</span></span><br><span class="line">	lmap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	fmt.Println(lmap == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(lmap[<span class="string">&quot;a&quot;</span>])   <span class="comment">// Output: 0</span></span><br><span class="line">	lmap[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>            <span class="comment">// sucess</span></span><br><span class="line">	<span class="built_in">delete</span>(lmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用make初始化</span></span><br><span class="line">	mmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(mmap == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(mmap[<span class="string">&quot;a&quot;</span>])   <span class="comment">// Output: 0</span></span><br><span class="line">	mmap[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>            <span class="comment">// sucess</span></span><br><span class="line">	<span class="built_in">delete</span>(mmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tnilmap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	<span class="comment">// 不会迭代</span></span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> tnilmap&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;k: %s, v: %d\n&quot;</span>, key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>map小结：</strong></p>
<p><em><strong>1. 显示声明、未初始化值时为nil</strong></em><br><em><strong>2. 使用new函数生成的map为nil</strong></em><br><em><strong>3. nil的map只读，无法写入</strong></em><br><em><strong>4. map读取，如果没有要读取的key，则返回key对应类型的零值</strong></em><br><em><strong>5. delete时如果map为nil或者key不存在则什么也不做</strong></em><br><em><strong>5. map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</strong></em><br><em><strong>6. 使用for...range遍历nil的slice不会迭代，也不会报错</strong></em></p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>一个未被make初始化的channel是nil的，channel是通过make来初始化的，make在创建channel时底层调用了<code>makechan</code>函数，返回值是一个结构体指针。</p>
<blockquote>
<p>func makechan(t *chantype, size int64) *hchan</p>
</blockquote>
<p>这里不去讨论详细的channel用法，仅仅对nil的情况做一下阐述。</p>
<ol>
<li><p>读写一个nil的channel会造成永远阻塞。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">&lt;- ch <span class="comment">// block</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span>  <span class="comment">// block</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭一个nil的channel会产生panic。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// panic: close of nil channel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>往一个已经关闭的channel发送数据会产生panic</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从一个已关闭的channel接收数据会收到最后发送的数据或者对应类型的零值</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// Output: 1</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// Output: 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>for...range语句会自动感知channel的关闭，但遇到nil会永远阻塞</p>
<p> 利用for...range优雅退出协程：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Using for-range to exit goroutine</span></span><br><span class="line">	<span class="comment">// range has the ability to detect the close/end of a channel</span></span><br><span class="line">	<span class="keyword">for</span> x := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Process %d\n&quot;</span>, x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(inCh)</span><br></pre></td></tr></table></figure>

<p> 遍历nil的通道：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tc  <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="comment">// 永远阻塞</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> tc &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>function和map、channel一样底层是一个指针，如果一个函数没有被初始化，那么它就是nil的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">fmt.Println(myFun == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br></pre></td></tr></table></figure>

<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p><code>interface</code>是比较有意思的一个类型，也是go能够具有<code>面向对象特征</code>以及<code>多态</code>基石，它是一个结构体，包含了<code>动态类型</code>和<code>动态值</code>。</p>
<p><img data-src="http://qiniu.liupzmin.com/interface.png" alt="interface"></p>
<p>对于一个接口的零值就是它的类型和值的部分都是nil， 只有<code>都为nil</code>的情况下<code>接口值 == nil</code>才成立。</p>
<p><img data-src="http://qiniu.liupzmin.com/nil-interface.jpg" alt="nil interface"></p>
<ol>
<li><p>调用一个空接口值上的任意方法都会产生panic</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"></span><br><span class="line">fmt.Println(w == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的(<code>此时nil不是nil</code>)</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...do something...</span></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">		out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上述示例，虽然我们给函数<code>f</code>传入了一个nil的指针（<code>*bytes.Buffer</code>），但是go将out的动态类型设为了<code>*bytes.Buffer</code>，动态值设为nil，意思就是out变量是一个包含了nil指针值的非nil接口，所以<code>out != nil</code>仍然为<code>true</code>，nil经过一道赋值的关卡后已不再是nil。</p>
</li>
</ol>
<p><img data-src="http://qiniu.liupzmin.com/non-nil-interface.png" alt="non nin interface with nil pointer"></p>
<h2 id="the-use-of-nil"><a href="#the-use-of-nil" class="headerlink" title="the use of nil"></a>the use of nil</h2><p><code>nil</code>并不总是为我们制造困难，有些时候也有其妙用。</p>
<ol>
<li><p><code>nil的指针可以作为合理的方法接收者</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> PointerReciver <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *PointerReciver)</span></span> showme()&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Yeah, it works!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ta *PointerReciver</span><br><span class="line">	ta.showme()		<span class="comment">// Yeah, it works!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nil的slice可以正常的append</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nil的map是只读的， 当你需要一个空map参数时可以使用nil</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGet</span><span class="params">(url <span class="type">string</span>, headers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> (*http.Request, <span class="type">error</span>) &#123;</span><br><span class="line">	req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		req.Header.Set(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 你可能想做如下调用，传入空的map</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewGet(</span><br><span class="line">		<span class="string">&quot;http://google.com&quot;</span>,</span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;,</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p> 你只需传入一个nil即可：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewGet(<span class="string">&quot;http://google.com&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nil的通道永远阻塞</code></p>
<p> 有时候我们可以利用<code>nil通道的阻塞特性</code>，比如有如下代码：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-a:</span><br><span class="line">				out &lt;- v</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-b:</span><br><span class="line">				out &lt;- v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个函数不断的从通道a和b读取数据，然后写入out通道，如果a和b其中有通道关闭，根据关闭通道的特性，我们知道会从	读取到对应类型的零值，那么如何才能跳过已经close的分支呢？	<br> 对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		a = <span class="literal">nil</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;a is now closed&quot;</span>)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	out &lt;- v</span><br></pre></td></tr></table></figure>
</li>
<li><p>nil的接口</p>
<p> 不用多说了</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章通过探索<code>new</code>和<code>make</code>的用法，揭示了go中初始化变量的一些规律，避免新手gopher使用过程中的困惑，对于这两个内置方法的使用时机，我个人的看法是：<code>如果你需要初始化一个slice、map、chan类型的变量，那么优先使用make</code>；<code>如果你需要一个指针接收器或者明确需要一个指针的时候，new会是一个不错的选择</code>。</p>
<p>在查阅new和make的过程中，我们遭遇了恼人的<code>nil</code>，本文也通过一些浅薄的分析，总结出了nil的一些规律，希望能给阅读本文的人带来一些帮助，同时也作为个人学习中的笔记可以随时翻阅，加强理解。</p>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3JlZi9zcGVj">The Go Programming Language Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj15bm9ZMnh6LUY4cw==">video:Understanding nil<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nbzEwMS5vcmcvYXJ0aWNsZS9uaWwuaHRtbA==">nils in Go<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BoYWJpYnJpZGhvL2dvbGFuZy1uaWwtdnMtZW1wdHktc2xpY2UtODdmZDUxYzBhNGQ=">Golang: Nil vs Empty Slice<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHVzdGNhdC9wLzQwMDQ4ODkuaHRtbA==">深入学习golang(4)—new与make<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNC8wMi9kaXZlLWludG8tZ28tc2xpY2Uv">深度解密Go语言之slice<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNS8yMi9kaXZlLWludG8tZ28tbWFwLw==">深度解密Go语言之map<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNy8yMi9kaXZlLWludG8tZ28tY2hhbm5lbC8=">深度解密Go语言之channel<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNC8yNS9kaXZlLWludG8tZ28taW50ZXJmYWNlLw==">深度解密Go语言之关于interface的 10 个问题<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/10/09/theory/three-body-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/09/theory/three-body-problem/" class="post-title-link" itemprop="url">《三体》问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-09 16:23:47" itemprop="dateCreated datePublished" datetime="2019-10-09T16:23:47+08:00">2019-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/computer-theory/" itemprop="url" rel="index"><span itemprop="name">computer theory</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>友情提醒：本文主要介绍由《三体》引发的关于计算机的某些思考，其中略有剧透，介意的朋友慎入。</p>
</blockquote>
<h2 id="旅行者1号"><a href="#旅行者1号" class="headerlink" title="旅行者1号"></a>旅行者1号</h2><p>很多年前，我刚刚升入高中，那时候我们学校每周只有周日下午放半天假，就在一个周日的下午，我整个人都泡在学校附近的新华书店，被一本人类探索太空的书迷住了。</p>
<p>从书中我第一次知道了<code>旅行者1号</code>，那个当时已经飞了25年的人类探测器，携带着地球文明的问候在太空中不知疲倦的飞行了25年，却仍没有飞出太阳系。</p>
<p>我并不是一个爱读书的人，至少当时是这样，我对宇宙的所有了解也大部分来源于那个下午，而我最基本的宇宙观也正是建立于那个下午，那一天我了解了<code>柯伊伯带</code>和<code>奥尔特星云</code>。在后来的人生中，我对<code>旅行者1号</code>也格外的亲切。</p>
<p>2012年8月25日，<code>旅行者1号</code>成为第一个穿越太阳圈并进入星际介质的宇宙飞船，它已经飞行了35年。</p>
<p>截至2019年8月28日止，<code>旅行者1号</code>正处于离太阳146.7 AU（$2.19 \times 10^{10} km$）的位置，是离地球最远的人造物体，已经飞行了42年。</p>
<p>那个下午出了书店，很长一段时间我都精神恍惚，若有所失，茫茫百感不知从何说起，震撼于宇宙的浩瀚与人类的渺小。</p>
<p>最近，我花了一周的时间读完了<code>刘慈欣</code>的<code>《三体》</code>，又一次体验到了少年时代的那种怅然若失的感觉，这也是让我想起<code>旅行者1号</code>的缘由。</p>
<h2 id="《三体》问题"><a href="#《三体》问题" class="headerlink" title="《三体》问题"></a>《三体》问题</h2><p>在小说<code>《三体》</code>中，可以通过特定的方法改变一个恒星系的光速，比如将太阳系的光速降低到<code>第三宇宙速度</code>，也就是光速由<code>30万km/s</code>降为<code>16.7km/s</code>，书中将此时的星系称为<code>“黒域”</code>，形成黒域的星系光速永远被限制，科技也永远停滞，人类永远也无法脱离该星系，这让该星系看起来安全，从而可以逃避<code>“黑暗森林”</code>的打击。</p>
<p>在大刘的假设中，当光速降为原来的万分之一，这个时候原来的电子计算机根本就无法运行了，需要特殊制造的芯片才可以，那么就引出了一个具体的问题：光速降低对我们现在的电子计算机会产生哪些影响呢？</p>
<h3 id="计算机的物理限制"><a href="#计算机的物理限制" class="headerlink" title="计算机的物理限制"></a>计算机的物理限制</h3><p>纵观计算机的发展历史，我们总是朝着更快的处理速度，更短的响应时间，更高的性能这条追求极致的道路上发展，我们的CPU不断的追求更多的晶体管，更先进的制程，更低的功耗，更加高性能的架构设计；我们的软件也在不断的改良，架构不断的演进，从单体到分布式，从传统数据中心到云计算，从巨石应用到微服务；在这个过程中是否存在一个我们永远无法逾越的物理限制呢？就像机械硬盘无论怎么样优化都无法打破磁头旋转这一物理动作的桎梏一样。是的，这样的物理限制存在，那就是光速。</p>
<p>以<code>3GHz</code>的CPU为例，频率是周期的倒数：<br>$$f&#x3D;{1 \over t}$$<br>晶振每秒钟可以振荡30亿次，每次耗时大约为0.33纳秒。光在1纳秒的时间内，可以前进30厘米。也就是说，在CPU的一个时钟周期内，光可以前进10厘米。这意味着如果要在一个时钟周期内完成一次信号的往返，并且假设组件没有延迟并且信号真的可以以光速运行，那么这个组件就要距离CPU不能超过5厘米。</p>
<p>这又意味着什么？我们假设数据的传输过程中，没有门延迟，电信号以光速传播，这时所需处理的数据距离CPU越远，它的传输时延越大。你看，我们一直不断优化的也不断提高的性能，居然受到一个<code>宇宙常数</code>的制约。</p>
<h3 id="光速降为第三宇宙速度"><a href="#光速降为第三宇宙速度" class="headerlink" title="光速降为第三宇宙速度"></a>光速降为第三宇宙速度</h3><p>距离CPU越远，传输的时延越大，这个结论肯定会让你想到<code>冯诺依曼</code>计算机的存储金字塔：</p>
<p><img data-src="http://qiniu.liupzmin.com/memory-hierarchy.jpg" alt="simplified computer memory hierarchy"></p>
<p>从塔尖到塔底，存储器件的时延由低到高，容量由小到大，如果将主频为3Ghz的CPU的一个时钟周期换算为人类习惯的1s的话，就会体会到CPU寄存器有多快，现代操作系统为什么要在I&#x2F;O的时候进行<code>上下文切换</code>了：</p>
<table>
<thead>
<tr>
<th>Computer Action</th>
<th>AVG Latency</th>
<th>Human Time</th>
</tr>
</thead>
<tbody><tr>
<td>3GhzCPU clock cycle</td>
<td>0.3ns</td>
<td>1s</td>
</tr>
<tr>
<td>Level 1 Cache access</td>
<td>0.9ns</td>
<td>3s</td>
</tr>
<tr>
<td>Level 2 Cache access</td>
<td>2.8ns</td>
<td>9s</td>
</tr>
<tr>
<td>Level 3 Cache access</td>
<td>12.9ns</td>
<td>43s</td>
</tr>
<tr>
<td>RAM access</td>
<td>70-100ns</td>
<td>3.5 to 5.5 min</td>
</tr>
<tr>
<td>NVMe SSD I&#x2F;O</td>
<td>7-150μs</td>
<td>2 hrs to 2 days</td>
</tr>
<tr>
<td>Hard Disk I&#x2F;O</td>
<td>1-10ms</td>
<td>11 days to 4 mos</td>
</tr>
<tr>
<td>Internet: SF to NYC</td>
<td>40ms</td>
<td>1.2 years</td>
</tr>
<tr>
<td>Internet: SF to Australia</td>
<td>183ms</td>
<td>6 years</td>
</tr>
<tr>
<td>OS virtualization reboot</td>
<td>4s</td>
<td>127 years</td>
</tr>
<tr>
<td>virtualization reboot</td>
<td>40s</td>
<td>1200 years</td>
</tr>
<tr>
<td>Physical system reboot</td>
<td>90s</td>
<td>3000 years</td>
</tr>
</tbody></table>
<p>如果光速降为原来的$1 \over 20000$会发生什么？我们进行一个不严谨的换算，假设所有组件本身工作延迟为0，所有的时延都是信号的传输花费，那么延时列表如下：</p>
<table>
<thead>
<tr>
<th>Computer Action</th>
<th>AVG Latency</th>
<th>Human Time</th>
<th>Lower c(third  cosmic  velocity)</th>
</tr>
</thead>
<tbody><tr>
<td>3GhzCPU clock cycle</td>
<td>0.3ns</td>
<td>1s</td>
<td>6μs</td>
</tr>
<tr>
<td>Level 1 Cache access</td>
<td>0.9ns</td>
<td>3s</td>
<td>18μs</td>
</tr>
<tr>
<td>Level 2 Cache access</td>
<td>2.8ns</td>
<td>9s</td>
<td>54μs</td>
</tr>
<tr>
<td>Level 3 Cache access</td>
<td>12.9ns</td>
<td>43s</td>
<td>258μs</td>
</tr>
<tr>
<td>RAM access</td>
<td>70-100ns</td>
<td>3.5 to 5.5 min</td>
<td>1.4ms to 2ms</td>
</tr>
<tr>
<td>NVMe SSD I&#x2F;O</td>
<td>7-150μs</td>
<td>2 hrs to 2 days</td>
<td>140ms to 3s</td>
</tr>
<tr>
<td>Hard Disk I&#x2F;O</td>
<td>1-10ms</td>
<td>11 days to 4 mos</td>
<td>20s to 3.4 min</td>
</tr>
<tr>
<td>Internet: SF to NYC</td>
<td>40ms</td>
<td>1.2 years</td>
<td>14 min</td>
</tr>
<tr>
<td>Internet: SF to Australia</td>
<td>183ms</td>
<td>6 years</td>
<td>1 hrs</td>
</tr>
<tr>
<td>OS virtualization reboot</td>
<td>4s</td>
<td>127 years</td>
<td>1 days</td>
</tr>
<tr>
<td>virtualization reboot</td>
<td>40s</td>
<td>1200 years</td>
<td>9 days</td>
</tr>
<tr>
<td>Physical system reboot</td>
<td>90s</td>
<td>3000 years</td>
<td>21 days</td>
</tr>
</tbody></table>
<p>可以看到，光速降为原来的$1 \over 20000$之后，CPU访问内存要花费<code>1~2ms</code>，访问最快的NVMe设备要花<code>140ms～3s</code>，这意味着什么？从外界事件的光线到达你的视网膜，到这个事件产生的神经脉冲到达你的大脑皮层，这之间的时间大约为<code>100ms</code>，如果一个交互系统延迟超过<code>140ms</code>才对你的操作做出反应，那么你就会感知到<code>“卡顿”</code>，也就是说在低光速下，你可以<code>“看到”</code>磁盘正在读写。</p>
<p>再看看网络传输，从<code>旧金山</code>到<code>纽约</code>的网络延时由原来的<code>40ms</code>增加到了<code>14分钟</code>，也就是说<code>ICMP包</code>的往返需要<code>14分钟</code>，我们假设<code>单程就是7分钟</code>，那么一个TCP连接的建立需要三次握手，共需花费<code>21分钟</code>，<code>理论上一个TCP数据包发送到接到ACK至少需要14分钟</code>，可见在现有的计算机网络设计上，光速骤降会导致计算机根本无法工作，一次硬重启就要花费<code>21天</code>的时间。</p>
<p><code>《三体》</code>中描述说没有计算机能在只有十几千米每秒的光速下运行，因此<code>关一帆</code>所在的银河系人类设计了可以在低光速下运行的<code>神经元计算机</code>，里面的所有芯片都是为低光速设计的，即便是经过专门的设计，在低光速下加载操作系统也要花<code>12</code>天的时间！</p>
<p>这个脑洞足以让你惊掉下巴，虽然它谈不上严谨，也不够科学(<em>注：这里的不严谨仅仅指我的推导过程，并非指大刘的分析逻辑，实际上大刘仅仅描述了结果，并未作详细解释</em>)，但是如果你仅仅得出光速降低会影响电子计算机这么个简单的结论，那你就太小看了大刘的脑洞。</p>
<p>在<code>《三体》</code>的猜想中，<code>光速</code>也并非永恒不变，光速在宇宙创世之初是无限快的，不严谨的描述就是：<code>光可以瞬间从宇宙的一端传输至另一端</code>。不知道你想到了什么，反正我想到了<code>量子纠缠</code>，那么为什么现在的光速只有30万公里每秒呢？答案是<code>黑暗森林</code>法则。</p>
<p>读过《三体》的朋友都知道，高维打低维是非常轻松的一件事。宇宙最初是十维的，因为文明<code>猜疑链</code>的<code>黑暗森林</code>法则，不断的有不同维度的、同维度的文明互相攻击，使得宇宙不断的从高维向低维坍缩，光速也不断在下降（太阳系属于三维，光速为$3 \times 10^8 m&#x2F;s$），小说中的太阳系就遭到了<code>降维打击</code>，从三维变到二维，太阳系成为了一副壮丽的画卷。</p>
<p>脑洞到此为止，我们还有个实际的问题要搞明白，那就是寄存器为什么会比内存快？除了距离上的优势之外，还有哪些内在的因素？</p>
<h2 id="为什么寄存器速度要比内存快"><a href="#为什么寄存器速度要比内存快" class="headerlink" title="为什么寄存器速度要比内存快"></a>为什么寄存器速度要比内存快</h2><p>在冯诺依曼计算机存储层次中，寄存器最快，容量最小，其次是内存，容量居中，硬盘最慢，容量最大；硬盘我们暂且不讨论，那么同样是晶体管存储设备，为什么寄存器的速度要比内存快呢？</p>
<h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>距离是一个因素，之前已经讨论过，越远离CPU，信号传输的距离越长，而电信号的传输速度受到光速的制约；而距离对于PC的影响就要比手机大，因为手机内存距离CPU更近，手机的CPU频率也通常比桌面电脑CPU低。</p>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p>成本是一个比较现实的原因，从<code>register-&gt;L1-&gt;L2-&gt;L3-&gt;DRAM</code>容量依次增大，以苹果的<code>A7处理器</code>为例，寄存器共有<code>6000比特</code>（32个64位的通用寄存器和32个128位的浮点寄存器等等）。但是目前的手机内存普遍拥有有<code>640亿比特</code>（8GB），因此，为这些为数不多的寄存器花费大量的成本去提高性能也是值得的，毕竟与内存比起来它太少了。</p>
<p>在设计上更加能突出这一点，寄存器和Cache相对于DRAM有更多更大的晶体管和更复杂的设计，且更加昂贵和耗电，并且一直有电；而DRAM的设计就相对简单，只有一个晶体管和一个很小的电容，也只有用到时才有电，所以更加便宜和省电。因此，DRAM上的cell排列非常稠密，而寄存器和SRAM就相对稀疏。这个道理同时适用于<code>register-&gt;L1-&gt;L2-&gt;L3-&gt;DRAM</code>这个链条，设计由复杂趋向简单，成本由高昂趋于节省，功耗由高变低。</p>
<p>可以想见，高性能、高成本、高耗电的设计就可以用在寄存器上，也只有低成本、低功耗的设计才可以堆出高容量的DRAM，一个简单的SRAM就需要至少6个晶体管，加上其他的元器件就有数十个晶体管，而DRAM只有一个晶体和一个电容。下面是SRAM和DRAM的cell的电路设计对比：</p>
<p><img data-src="http://qiniu.liupzmin.com/static-RAM-cell.jpg" alt="static RAM cell"><img data-src="http://qiniu.liupzmin.com/dynamic-RAM-cell.jpg" alt="dynamic RAM cell"></p>
<p>有人会问，如果我们<code>不计成本</code>，只做L1缓存，甚至做到跟内存一样大，不要内存了，会不会让CPU产生质的飞跃呢？</p>
<p>很遗憾，即便是现有的Cache层级下，也不是容量越大效果越好，<code>命中率的增长到达一定程度时就趋于平缓</code>，而如果真把L1做那么大容量，体积也会增大，就难以保证在一个时钟周期内访问到L1，那么cpu的频率就不能做那么高，这相当于自残，所以如何平衡缓存的层级和每个层级的大小一种<code>trade-off</code>艺术。这里有一篇文章有更详细的介绍：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjA1ODgwOA==">Cache为什么有那么多级？为什么一级比一级大？是不是Cache越大越好？<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>寄存器的工作方式很简单，只有两步：</p>
<ol>
<li>找到相关的位</li>
<li>读取这些位。</li>
</ol>
<p>Cache的工作方式便又复杂了些，这里不讨论内存如何映射到Cache，也不考虑各种处理器架构的区别，只是简单大概的介绍一下Cache的运作流程，系统启动时，缓存内没有任何数据。之后，需要读取内存的数据便被以一定的大小（<code>Cache Line</code>）依次存入L3、L2、L1中，处理器读取指令或数据的过程如下：</p>
<ol>
<li>将地址由高至低划分为四个部分：标签、索引、块内偏移、字节偏移。</li>
<li>用索引定位到相应的缓存块。</li>
<li>用标签尝试匹配该缓存块的对应标签值。如果存在这样的匹配，称为命中（Hit）；否则称为未命中（Miss）。</li>
<li>如命中，用块内偏移将已定位缓存块内的特定数据段取出，送回处理器。</li>
<li>如未命中，先用此块地址（标签+索引）从内存读取数据并载入到当前缓存块，再用块内偏移将位于此块内的特定数据单元取出，送回处理器。</li>
</ol>
<p>内存的工作方式就要复杂得多：</p>
<ol>
<li>找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）</li>
<li>将指针送往内存管理单元（MMU）。</li>
<li>由MMU将虚拟的内存地址翻译成实际的物理地址。</li>
<li>将物理地址送往内存控制器（memory controller）</li>
<li>由内存控制器找出该地址在哪一根内存插槽（bank）上。</li>
<li>确定数据在哪一个内存块（chunk）上，从该块读取数据。</li>
<li>数据先送回内存控制器</li>
<li>再送回CPU。</li>
<li>然后开始使用。</li>
</ol>
<p>内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。</p>
<p>以上就是为什么寄存器会比Cache和RAM快的大致原因，而缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性（Locality）特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。</p>
<h2 id="《三体》带来的其它思考"><a href="#《三体》带来的其它思考" class="headerlink" title="《三体》带来的其它思考"></a>《三体》带来的其它思考</h2><blockquote>
<p>给岁月以文明，而不是给文明以岁月</p>
</blockquote>
<p>如果说读完《三体》能让我记住些什么，那就是这句<code>给岁月以文明，而不是给文明以岁月</code>，这句话是出自帕斯卡的：<code>给时光以生命，而不是给生命以时光。(To the time to life, rather than to life in time)</code>。</p>
<p>两句话的都有相似的主旨，虽然表述的对象不同，看似略有深奥的话，其实阐明了一个很简单的道理：<code>活在当下</code>。不要被过去和未来迷惑，让活着的每一刻都有意义，不让生命虚度。如果时光蹉跎，那生命再长也不过是行尸走肉。</p>
<p>同样的道理，人类遭遇《三体》危机，全球都思考着如何延续我们的文明，而在这个过程中造成了太多的血与泪，不由得让人怀疑，文明若斯，当真还值得延续？</p>
<p>这不过就是王宝强老师的那句：<code>有意义的事儿就是好好活，好好活就是做有意义的事儿。</code></p>
<p>所有那些有意义的事儿串联起来，就是人生。</p>
<p>是的，<code>既往不恋，当下不杂，未来不迎</code>。</p>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWlrZWFzaC5jb20vcHlibG9nL2ZyaWRheS1xYS0yMDEzLTEwLTExLXdoeS1yZWdpc3RlcnMtYXJlLWZhc3QtYW5kLXJhbS1pcy1zbG93Lmh0bWw=">Why Registers Are Fast and RAM Is Slow<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZm9ybXVsdXNibGFjay5jb20vYmxvZy9jb21wdXRlLXBlcmZvcm1hbmNlLWRpc3RhbmNlLW9mLWRhdGEtYXMtYS1tZWFzdXJlLW9mLWxhdGVuY3kv">Compute Performance – Distance of Data as a Measure of Latency<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoZGlmZmVyZW5jZXMuY29tL2RpZmZlcmVuY2UtYmV0d2Vlbi1zcmFtLWFuZC1kcmFtLmh0bWw=">Difference Between SRAM and DRAM<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTMvMTAvcmVnaXN0ZXIuaHRtbA==">为什么寄存器比内存快？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMDQwOTM2MA==">为什么主流CPU的频率止步于4G?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQ1BVJUU3JUJDJTkzJUU1JUFEJTk4">wiki:CPU缓存<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjA1ODgwOA==">Cache为什么有那么多级？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTg1OTEwNQ==">Cache是怎么组织和工作的？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTQyMjIwMQ==">L1，L2，L3 Cache究竟在哪里？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5wYXJhbGxlbGxhYnMuY29tLzIwMTAvMDMvMDYvd2h5LXNob3VsZC1wcm9ncmFtbWVyLWNhcmUtYWJvdXQtc2VxdWVudGlhbC1jb25zaXN0ZW5jeS1yYXRoZXItdGhhbi1jYWNoZS1jb2hlcmVuY2Uv">为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？）<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/09/30/concurrence/tls-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/30/concurrence/tls-summary/" class="post-title-link" itemprop="url">初识Thread Local Storage</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-30 20:42:35" itemprop="dateCreated datePublished" datetime="2019-09-30T20:42:35+08:00">2019-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/concurrence/" itemprop="url" rel="index"><span itemprop="name">concurrence</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>当程序运行时，函数的局部变量是在线程的栈上进行分配，虽然线程共享进程的虚拟地址空间，但因为每个线程有自己的线程栈，所以栈中的数据是互相隔离的，互不侵扰；而全局变量在<code>heap</code>上进行分配，<code>heap</code>在各个线程间是共享的，所以在对共享的资源进行读写时，需要有同步机制来确保线程安全；然而有一种多线程下的编程方式，可以使得全局变量或静态变量只对单个线程可见，而对其它线程不可见，这就是<code>Thread Local Storage</code>，又叫<code>线程本地存储</code>或<code>线程局部存储</code></p>
</blockquote>
<h2 id="Thread-Local-Storage"><a href="#Thread-Local-Storage" class="headerlink" title="Thread Local Storage"></a>Thread Local Storage</h2><p><code>维基百科</code>上对Thread Local Storage的解释如下:</p>
<blockquote>
<p>Thread-local storage (TLS) is a computer programming method that uses static or global memory local to a thread.</p>
</blockquote>
<p>翻译下来就是：<code>线程本地存储(TLS)，对于线程来讲是一种对本地化使用静态或全局内存的计算机编程方法。</code></p>
<p>线程局部存储(TLS)是一个后来者, 产生于多线程概念之后.而在软件发展的早期, 全局变量经常用在库函数中, 用于存储全局信息, 比如errno, 多线程程序产生之后, 全局变量errno就成为所有线程都共享的一个变量, 而实际上, 每个线程都想维护一份自己的errno, 隔离于其他线程.这个时候, 没人愿意去修改库函数的接口. 于是线程局部存储就诞生了, 它主要是为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突，尤其是多个线程同时需要修改这一变量时，而这些变量逻辑上又可以在各个线程中独立，也就是说线程并不共享这些变量。</p>
<p> 为了解决这个问题，我们可以通过TLS机制，为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。而从全局变量的角度上来看，就好像一个全局变量被克隆成了多份副本，而每一份副本都可以被一个线程独立地改变。</p>
<h2 id="TLS简单使用"><a href="#TLS简单使用" class="headerlink" title="TLS简单使用"></a>TLS简单使用</h2><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><p>编写如下一段程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _MULTI_THREADED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">int</span> TLS_data1;</span><br><span class="line">__thread <span class="type">int</span> TLS_data2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int TLS_data1;</span></span><br><span class="line"><span class="comment">//int TLS_data2;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>                 NUMTHREADS   4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">theThread</span><span class="params">(<span class="type">void</span> *a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> arg = *(<span class="type">int</span> *)a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %lu before change: arg:%d TLS data=%d %d\n&quot;</span>,</span><br><span class="line">           pthread_self(), arg,  TLS_data1, TLS_data2);</span><br><span class="line">    TLS_data1 = arg;</span><br><span class="line">    TLS_data2 = arg +<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %lu after change: arg:%d TLS data=%d %d\n&quot;</span>,</span><br><span class="line">           pthread_self(), arg,  TLS_data1, TLS_data2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread[NUMTHREADS];</span><br><span class="line">    <span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ar[NUMTHREADS];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter Testcase - %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create/start threads\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMTHREADS; i++) &#123;</span><br><span class="line">        <span class="comment">/* Create per-thread TLS data and pass it to the thread */</span></span><br><span class="line">        ar[i] = i;</span><br><span class="line">        rc = pthread_create(&amp;thread[i], <span class="literal">NULL</span>, theThread, &amp;ar[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wait for the threads to complete, and release their resources\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMTHREADS; i++) &#123;</span><br><span class="line">        rc = pthread_join(thread[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该段程序使用<code>__thread</code>声明了两个变量<code>TLS_data1</code>和<code>TLS_data2</code>为线程局部存储，然后分别在4个线程中修改他们的值，观察运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Create/start threads</span><br><span class="line">Thread 139919563978496 before change: arg:0 TLS data=0 0</span><br><span class="line">Thread 139919563978496 after change: arg:0 TLS data=0 1</span><br><span class="line">Thread 139919547193088 before change: arg:2 TLS data=0 0</span><br><span class="line">Thread 139919547193088 after change: arg:2 TLS data=2 3</span><br><span class="line">Wait for the threads to complete, and release their resources</span><br><span class="line">Thread 139919538800384 before change: arg:3 TLS data=0 0</span><br><span class="line">Thread 139919538800384 after change: arg:3 TLS data=3 4</span><br><span class="line">Thread 139919555585792 before change: arg:1 TLS data=0 0</span><br><span class="line">Thread 139919555585792 after change: arg:1 TLS data=1 2</span><br><span class="line">Main completed</span><br></pre></td></tr></table></figure>
<p>可以看到每个线程可以从容的修改他们。并且相互之间没有造成干扰，那么我们去掉<code>__thread</code>而使用普通的全局变量的话，就会使这段程序变得线程不安全：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Create/start threads</span><br><span class="line">Thread 140450580477696 before change: arg:0 TLS data=0 0</span><br><span class="line">Thread 140450580477696 after change: arg:0 TLS data=0 1</span><br><span class="line">Thread 140450572084992 before change: arg:1 TLS data=0 1</span><br><span class="line">Thread 140450572084992 after change: arg:1 TLS data=1 2</span><br><span class="line">Thread 140450563692288 before change: arg:2 TLS data=1 2</span><br><span class="line">Thread 140450563692288 after change: arg:2 TLS data=2 3</span><br><span class="line">Wait for the threads to complete, and release their resources</span><br><span class="line">Thread 140450555299584 before change: arg:3 TLS data=2 3</span><br><span class="line">Thread 140450555299584 after change: arg:3 TLS data=3 4</span><br><span class="line">Main completed</span><br></pre></td></tr></table></figure>

<p>可以试着删除<code>__thread</code>关键字，再编译运行观察，你会看到一个错乱的运行结果。</p>
<h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><p>把上面的例子用python来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">local = threading.local()</span><br><span class="line">local.TLS_data1 = <span class="number">0</span></span><br><span class="line">local.TLS_data2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">info</span>):</span><br><span class="line">    myname = threading.currentThread().getName()</span><br><span class="line">    local.TLS_data1 = info</span><br><span class="line">    local.TLS_data2 = info + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Thread &#123;0&#125; after change TLS data: &#123;1&#125;, &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(myname, local.TLS_data1, local.TLS_data2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">    t[i] = threading.Thread(target=func, args=[i])</span><br><span class="line">    t[i].start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(t):</span><br><span class="line">    v.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Thread &#123;0&#125; TLS data: &#123;1&#125;, &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&quot;main&quot;</span>, local.TLS_data1, local.TLS_data2))</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread Thread-1 after change TLS data: 0, 1</span><br><span class="line">Thread Thread-2 after change TLS data: 1, 2</span><br><span class="line">Thread Thread-3 after change TLS data: 2, 3</span><br><span class="line">Thread Thread-4 after change TLS data: 3, 4</span><br><span class="line">Thread main TLS data: 0, 0</span><br></pre></td></tr></table></figure>

<h2 id="TLS的误区"><a href="#TLS的误区" class="headerlink" title="TLS的误区"></a>TLS的误区</h2><p>网上有很多文章误将TLS当成是编写线程安全代码的银弹，其实哪里是这样，这都取决于<code>global variable</code>在你的线程之间是不是<code>shared</code>，如果你的本意就是共享，那么TLS反而使你南辕北辙，你仍然需要<code>mutex</code>之类的锁去同步你的操作，那么TLS的本质到底是什么？</p>
<p>我认为TLS的本质就是填补了全局变量和局部变量之间的空白，它不像全局变量那样在多个线程中可见，也不像局部变量那样仅仅生存在在函数的作用域之内，它的可见度，大于局部变量，又小于全局变量。</p>
<h2 id="TLS适用场景"><a href="#TLS适用场景" class="headerlink" title="TLS适用场景"></a>TLS适用场景</h2><p>综上所述，线程本地存储并不是解决多线程变量共享的并发问题，而是限制变量仅在当前线程中可见，可想而知这样带来的好处之一就是线程内各个方法之间不用再通过传参就可以共享变量；另外一个可想而知的使用场景就是可以实现每个线程需要单独拥有一个实例的情况。</p>
<p>还有一个也是<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGhyZWFkLWxvY2FsX3N0b3JhZ2U=">wiki<i class="fa fa-external-link-alt"></i></span>上提到的，就是对一个<code>global variable</code>进行累加的情况，为了避免<code>race condition</code>的传统做法是使用<code>mutex</code>，但也可以使用TLS先在每个线程本地累加，然后再讲每个线程的累加结果同步到一个真正的<code>global variable</code>之上。</p>
<p>当然，我认为TLS的适用场景肯定远不止这些，只是我个人平时工作当中，编码并不是很多，其中多线程编程便又少了一些，而在多线程编程中适用TLS的情况更是为零，本篇文章仅当做学习过程中的记录，以后有更深层次的思考会随时补充，也希望大家可以共同探讨。</p>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGhyZWFkLWxvY2FsX3N0b3JhZ2U=">Thread-local storage<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2p1Lm91dG9mbWVtb3J5LmNuL2VudHJ5LzY2MjM4">线程局部存储漫谈<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jaGFvLXRpYy5naXRodWIuaW8vYmxvZy8yMDE4LzEyLzI1L3Rscw==">A Deep dive into (implicit) Thread Local Storage<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/09/24/docker/manage-docker-as-a-non-root-user/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/24/docker/manage-docker-as-a-non-root-user/" class="post-title-link" itemprop="url">使用普通用户管理docker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-24 16:09:12" itemprop="dateCreated datePublished" datetime="2019-09-24T16:09:12+08:00">2019-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Docker的Daemon程序绑定到socket文件上（<code>/var/run/docker.sock</code>），而不是tcp端口.因此，默认情况下这个socket文件只能被<code>root</code>用户或者拥有<code>sudo</code>权限的用户访问. Docker daemon总是以<code>root</code>用户运行。</p>
</blockquote>
<p>如果你不想总是在docker命令的前边加上<code>sudo</code>，那么可以创建一个名为<code>docker</code>的group，并且将你的用户加入到该组，那么docker daemon启动的时候会创建一个<code>docker</code>组成员可以访问的socket，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll /var/run/docker.sock </span><br><span class="line">srw-rw---- 1 root docker 0 Sep 24 11:24 /var/run/docker.sock</span><br></pre></td></tr></table></figure>

<p>To create the <code>docker</code> group and add your user:</p>
<ol>
<li><p>Create the <code>docker</code> group.</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Add your user to the <code>docker</code> group.</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="variable">$USER</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Log out and log back in so that your group membership is re-evaluated.<br>If testing on a virtual machine, it may be necessary to restart the virtual machine for changes to take effect.<br>On a desktop Linux environment such as X Windows, log out of your session completely and then log back in.<br>On Linux, you can also run the following command to activate the changes to groups:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">newgrp docker</span> </span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/09/16/golang/go-modules-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/16/golang/go-modules-md/" class="post-title-link" itemprop="url">浅谈Go1.13中的modules</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-16 10:41:24" itemprop="dateCreated datePublished" datetime="2019-09-16T10:41:24+08:00">2019-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>前几天go1.13发布，modules默认开启，从此modules转正成为golang官方原生的包依赖管理方式；除了modules，go1.13中还增加了新的语法，如二进制、八进制、十六进制字面量表示法，defer性能的增强，新的errors等等，社区已有很多相关特性的论述文章；此文仅简单讨论一下go1.13中modules的一些改变，毕竟包的管理跟我们日常开发是息息相关的，行文仓促，若有不当之处，希望读者斧正。</p>
</blockquote>
<p><strong>本文仅介绍modules在1.11&#x2F;1.12&#x2F;1.13等版本中的变化，并不介绍modules的使用，如需了解modules的详细使用方法，请参考官方文档或其他社区文章</strong></p>
<h2 id="Go-Moudles"><a href="#Go-Moudles" class="headerlink" title="Go Moudles"></a>Go Moudles</h2><p><code>modules</code> 是 go1.11 推出的特性，官方称是 <code>GOPATH</code> 的替代品，是一个完整的支持包分发和版本控制的工具，使用modules，工作区不再局限于<code>GOPATH</code>之内，从而使构建更加可靠和可重复，但modules在go1.11版本中仅仅是一个实验性的功能，紧接着在go1.12中得到了增强，而刚刚发布的go1.13中得到了转正，<code>GOPATH</code>的作用进一步被弱化，Go Moudles开始大规模使用。</p>
<h3 id="两个模式"><a href="#两个模式" class="headerlink" title="两个模式"></a>两个模式</h3><p>对于 modules 这种模式官网有一个称呼是<code> Module-aware</code>，我不知道如何去翻译这个组合词，与之相对的，就是在<code>Module-aware mode</code>之前我们使用的包管理方式称为<code>GOPATH mode</code>，他们的区别如下：</p>
<ul>
<li><p><strong>GOPATH mode：</strong> go command从<code>vendor</code>和<code>GOPATH</code>下寻找依赖,依赖会被下载至<code>GOPATH/src</code></p>
</li>
<li><p><strong>Module-aware mode:</strong> go command不再考虑<code>GOPATH</code>，仅仅使用<code>GOPATH/pkg/mod</code>存储下载的依赖，并且是多版本并存</p>
</li>
</ul>
<p><strong>注意：Module-aware开启和关闭的情况下，go get 的使用方式不是完全相同的。在 modules 模式开启的情况下，可以通过在 package 后面添加 @version 来表明要升级（降级）到某个版本。如果没有指明 version 的情况下，则默认先下载打了 tag 的 release 版本，比如 v0.4.5 或者 v1.2.3；如果没有 release 版本，则下载最新的 pre release 版本，比如 v0.0.1-pre1。如果还没有则下载最新的 commit。这个地方给我们的一个启示是如果我们不按规范的方式来命名我们的 package 的 tag，则 modules 是无法管理的。version 的格式为 v(major).(minor).(patch) ，</strong></p>
<p>在 modules 开启的模式下，go get 还支持 version 模糊查询，比如 &gt; v1.0.0 表示大于 v1.0.0 的可使用版本；&lt; v1.12.0 表示小于 v1.12.0  版本下最近可用的版本。version 的比较规则按照 version 的各个字段来展开。</p>
<p>除了指定版本，我们还可以使用如下命名使用最近的可行的版本：</p>
<ul>
<li><p>go get -u 使用最新的 minor 或者 patch 版本</p>
</li>
<li><p>go get -u&#x3D;patch 使用最新的 patch 版本</p>
</li>
</ul>
<h2 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h2><p>在 1.12 版本之前，使用 Go modules 之前需要环境变量 GO111MODULE：</p>
<ul>
<li><p>GO111MODULE&#x3D;off: 不使用 Module-aware mode。</p>
</li>
<li><p>GO111MODULE&#x3D;on: 使用 Module-aware mode，不会去 GOPATH 下面查找依赖包。</p>
</li>
<li><p>GO111MODULE&#x3D;auto或unset: Golang 自己检测是不是使用Module-aware mode。</p>
</li>
</ul>
<p>go1.11时GO111MODULE&#x3D;on有一个很不好的体验，就是go command依赖go.mod文件，也就是如果在module文件夹外使用go get等命令会报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node1 ~]# go get github.com/google/go-cmp</span><br><span class="line">go: cannot find main module; see &#x27;go help modules&#x27;</span><br><span class="line">[root@k8s-node1 ~]# touch go.mod</span><br><span class="line">[root@k8s-node1 ~]# go get github.com/google/go-cmp</span><br><span class="line">go: cannot determine module path for source directory /root (outside GOPATH, no import comments)</span><br></pre></td></tr></table></figure>

<p>这个情况在go1.12中得到了解决，可以在<code>module directory</code>之外使用<code>go</code> command。</p>
<p>但我个人比较喜欢不去设置<code>GO111MODULE</code>，根据官方描述在不设置<code>GO111MODULE</code>的情况下或者设为auto的时候，如果在当前目录或者父目录中有go.mod文件，那么就使用<code>Module-aware mode</code>， 而go1.12中，如果包位于<code>GOPATH/src</code>下，且<code>GO111MODULE=auto</code>, 即使有go.mod的存在，go仍然使用<code>GOPATH mode</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos test]# go get github.com/jlaffaye/ftp        </span><br><span class="line">go get: warning: modules disabled by GO111MODULE=auto in GOPATH/src;</span><br><span class="line">        ignoring go.mod;</span><br><span class="line">        see &#x27;go help modules&#x27;</span><br></pre></td></tr></table></figure>

<p>这个现象在go1.13中又发生了改变.</p>
<h2 id="modules-in-go1-13"><a href="#modules-in-go1-13" class="headerlink" title="modules in go1.13"></a>modules in go1.13</h2><h3 id="GO111MODULE-1"><a href="#GO111MODULE-1" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><blockquote>
<p>The GO111MODULE environment variable continues to default to auto, but the auto setting now activates the module-aware mode of the go command whenever the current working directory contains, or is below a directory containing, a go.mod file — even if the current directory is within GOPATH&#x2F;src.</p>
</blockquote>
<p>Go 1.13 includes support for Go modules. Module-aware mode is active by default whenever a go.mod file is found in, or in a parent of, the current directory.</p>
<p>可见，modules 在 Go 1.13 的版本下是默认开启的，GOPATH的地位进一步被弱化。</p>
<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p><code>GOPROXY</code>环境变量是伴随着modules而生的，在go1.13中得到了增强，可以设置为逗号分隔的url列表来指定多个代理，其默认值为<code>https://proxy.golang.org,direct</code>，也就是说google为我们维护了一个代理服务器，但是因为墙的存在，这个默认设置对中国的gopher并无卵用，应第一时间修改。</p>
<p><code>go</code>命令在需要下载库包的时候将逐个试用设置中的各个代理，直到发现一个可用的为止。<code>direct</code>表示直连，所有<code>direct</code>之后的proxy都不会被使用，一个设置例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY=https://proxy.golang.org,https://myproxy.mysite:8888,direct</span><br></pre></td></tr></table></figure>

<p><code>GOPROXY</code>环境变量可以帮助我们下载墙外的第三方库包，比较知名的中国区代理<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvcHJveHkvZ29wcm94eS5jbg==">goproxy.cn<i class="fa fa-external-link-alt"></i></span>。当然，通过设置https_proxy环境变量设也可以达到此目的。但是一个公司通过在内部架设一个自己的goproxy服务器来缓存第三方库包，库包下载速度会更快,可以感觉到module有一点<code>maven</code>的意思了，但是易用性上还有很长的路要走。</p>
<h3 id="GOPRIVATE"><a href="#GOPRIVATE" class="headerlink" title="GOPRIVATE"></a>GOPRIVATE</h3><p>使用<code>GOPROXY</code>可以获取公共的包，这些包在获取的时候会去https://sum.golang.org进行校验，这对中国的gopher来说又是一个比较坑的地方，Go为了安全性推出了Go checksum database（sumdb），环境变量为<code>GOSUMDB</code>，go命令将在必要的时候连接此服务来检查下载的第三方依赖包的哈希是否和sumdb的记录相匹配。很遗憾，在中国也被墙了，可以选择设置为一个第三方的校验库，也可更直接点将<code>GOSUMDB</code>设为<code>off</code>关闭哈希校验，当然就不是很安全了。</p>
<p>除了<code>public</code>的包，在现实开发中我们更多的是使用很多<code>private</code>的包，因此就不适合走代理，所以go1.13推出了一个新的环境变量<code>GOPRIVATE</code>，它的值是一个以逗号分隔的列表，支持正则（正则语法遵守 Golang 的 包 path.Match）。在<code>GOPRIVATE</code>中设置的包不走proxy和checksum database，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPRIVATE=*.corp.example.com,rsc.io/private</span><br></pre></td></tr></table></figure>

<h3 id="GONOSUMDB-和-GONOPROXY"><a href="#GONOSUMDB-和-GONOPROXY" class="headerlink" title="GONOSUMDB 和 GONOPROXY"></a>GONOSUMDB 和 GONOPROXY</h3><p>这两个环境变量根据字面意思就能明白是设置不进行校验和不走代理的包，设置方法也是以逗号分隔</p>
<h3 id="go-env-w"><a href="#go-env-w" class="headerlink" title="go env -w"></a>go env -w</h3><p>可能是go也觉得环境变量有点多了，干脆为go env增加了一个选项<code>-w</code>，来设置全局环境变量，在Linux系统上我们可以这样用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">go env -w GOPRIVATE=*.gitlab.com,*.gitee.com</span><br><span class="line">go env -w GOSUMDB=off</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就<code>1.13</code>中包管理的改变来看，有些乏善可陈，go的包管理很难让大多数开发者满意，当我看到越来越多的环境变量时，心里忍不住唾弃，使用这么多环境变量是一个多么蠢的方法，希望未来Go能给大家带来更好的包管理方式吧，就像Java的maven那样。</p>
<p><strong>参考文献：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy9nbzEuMTM=">Go 1.13 Release Notes<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy9nbzEuMTI=">Go 1.12 Release Notes<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy9nbzEuMTE=">Go 1.11 Release Notes<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3Mvdi1OZFlFSkJnS2JpS3Nkb1FhUnNRZw==">Go Modules 不完全教程<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/08/06/golang/url-encode-linefeed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/06/golang/url-encode-linefeed/" class="post-title-link" itemprop="url">The 
 in URL Encode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-06 09:50:36" itemprop="dateCreated datePublished" datetime="2019-08-06T09:50:36+08:00">2019-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="0A的问题"><a href="#0A的问题" class="headerlink" title="%0A的问题"></a>%0A的问题</h2><p>在使用<code>Go</code>语言的<code>net/url</code>包进行编码组装url的时候，遇到如下报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-07-31 16:55:46.850 ERROR   executor/driver_rollback.go:41  encounter an error:bad response code: 404</span><br><span class="line">github.com/glory-cd/agent/executor.(*HttpFileHandler).Get</span><br><span class="line">        /home/liupeng/cdp/src/agent/executor/file_http.go:115</span><br><span class="line">github.com/glory-cd/agent/executor.(*Client).Get</span><br><span class="line">        /home/liupeng/cdp/src/agent/executor/client.go:66</span><br><span class="line">github.com/glory-cd/agent/executor.Get</span><br><span class="line">        /home/liupeng/cdp/src/agent/executor/filehandler.go:33</span><br><span class="line">github.com/glory-cd/agent/executor.(*Roll).getCode</span><br><span class="line">        /home/liupeng/cdp/src/agent/executor/driver_rollback.go:77</span><br><span class="line">github.com/glory-cd/agent/executor.(*Roll).Exec</span><br><span class="line">        /home/liupeng/cdp/src/agent/executor/driver_rollback.go:52</span><br><span class="line">runtime.goexit</span><br><span class="line">        /usr/lib/go/src/runtime/asm_amd64.s:1337</span><br><span class="line">the kv is: &#123;&quot;url&quot;:&quot;http://admin:xxxx@192.168.1.75:32749/test/1.0.0/Gateway.zip%0A&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>可见，最终组装成的<code>url</code>末尾多了<code>%0A</code>，从而导致<strong>http</strong>请求返回<code>404</code>，那么<code>%0A</code>是怎么来的呢？ 那就回溯一下url的组装过程吧。</p>
<p>我用来组装url的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建url.URL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hu *HttpFileHandler)</span></span> newPostUrl() <span class="type">string</span> &#123;</span><br><span class="line">	requestURL := <span class="built_in">new</span>(url.URL)</span><br><span class="line"></span><br><span class="line">	requestURL.Scheme = <span class="string">&quot;http&quot;</span></span><br><span class="line"></span><br><span class="line">	requestURL.User = url.UserPassword(hu.client.User, hu.client.Pass)</span><br><span class="line"></span><br><span class="line">	requestURL.Host = hu.client.Addr</span><br><span class="line"></span><br><span class="line">	requestURL.Path += hu.client.RelativePath</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> requestURL.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Path</code>部分是使用<code>hu.client.RelativePath</code>进行拼接的，<code>RelativePathient</code>的来源如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *driver)</span></span> readServiceVerion() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	versionFile := filepath.Join(d.Dir, common.PathFile)</span><br><span class="line">	path, err := ioutil.ReadFile(versionFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(path), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现<code>RelativePathient</code>是从文件中读取的，我这个文件中只有一行内容，那么再结合<code>url encode</code>来看，这个<code>%0A</code>就是一个<code>linefeed</code>，是一个换行符，那么处理方法就简单了，返回的时候<code>Trim</code>一下就可以解决换行和空格的问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> strings.TrimSpace(<span class="type">string</span>(path)), <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>接下来再简单聊一下<code>url encode</code></p>
<h2 id="url-encode"><a href="#url-encode" class="headerlink" title="url encode"></a>url encode</h2><hr>
<p>百分号编码（英语：Percent-encoding，又称：URL编码（英语：URL encoding）），是特定上下文的统一资源定位符 (URL)的编码机制. 实际上也适用于统一资源标志符（URI）的编码。也用于为application&#x2F;x-www-form-urlencodedMIME准备数据，因为它用于通过HTTP的请求操作（request）提交HTML表单数据。</p>
<hr>
<p>上面是<code>维基百科</code>对url编码的解释，通常如果一样东西需要编码，说明这样东西并不适合传输。原因多种多样，如Size过大，包含隐私数据，对于Url来说，之所以要进行编码，是因为Url中有些字符会引起歧义。</p>
<p>例如，Url参数字符串中使用key&#x3D;value键值对这样的形式来传参，键值对之间以&amp;符号分隔，如&#x2F;s?q&#x3D;abc&amp; ie&#x3D;utf-8。如果你的value字符串中包含了&#x3D;或者&amp;，那么势必会造成接收Url的服务器解析错误，因此必须将引起歧义的&amp;和&#x3D; 符号进行转义，也就是对其进行编码。</p>
<p>又如，Url的编码格式采用的是ASCII码，而不是Unicode，这也就是说你不能在Url中包含任何非ASCII字符，例如中文。否则如果客户端浏览器和服务端浏览器支持的字符集不同的情况下，中文可能会造成问题。</p>
<p>Url编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。</p>
<h3 id="语法构成"><a href="#语法构成" class="headerlink" title="语法构成"></a>语法构成</h3><p>URI是统一资源标识的意思，通常我们所说的URL只是URI的一种。典型URL的格式如下所示。下面提到的URL编码，实际上应该指的是URI编码。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODY=">rfc3986<i class="fa fa-external-link-alt"></i></span>中解释URI的构成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   The generic URI syntax consists of a hierarchical sequence of</span><br><span class="line">   components referred to as the scheme, authority, path, query, and</span><br><span class="line">   fragment.</span><br><span class="line"></span><br><span class="line">      URI         = scheme &quot;:&quot; hier-part [ &quot;?&quot; query ] [ &quot;#&quot; fragment ]</span><br><span class="line"></span><br><span class="line">      hier-part   = &quot;//&quot; authority path-abempty</span><br><span class="line">                  / path-absolute</span><br><span class="line">                  / path-rootless</span><br><span class="line">                  / path-empty</span><br><span class="line"></span><br><span class="line">The following are two example URIs and their component parts:</span><br><span class="line"></span><br><span class="line">         foo://example.com:8042/over/there?name=ferret#nose</span><br><span class="line">         \_/   \______________/\_________/ \_________/ \__/</span><br><span class="line">          |           |            |            |        |</span><br><span class="line">       scheme     authority       path        query   fragment</span><br><span class="line">          |   _____________________|__</span><br><span class="line">         / \ /                        \</span><br><span class="line">         urn:example:animal:ferret:nose</span><br></pre></td></tr></table></figure>

<h3 id="哪些字符需要编码"><a href="#哪些字符需要编码" class="headerlink" title="哪些字符需要编码"></a>哪些字符需要编码</h3><p>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。 RFC3986文档对Url的编解码问题做出了详细的建议，指出了哪些字符需要被编码才不会引起Url语义的转变，以及对为什么这些字符需要编码做出了相 应的解释。</p>
<p>US-ASCII字符集中没有对应的可打印字符：Url中只允许使用可打印字符。US-ASCII码中的10-7F字节全都表示控制字符，这些 字符都不能直接出现在Url中。同时，对于80-FF字节（ISO-8859-1），由于已经超出了US-ACII定义的字节范围，因此也不可以放在 Url中。</p>
<p>保留字符：Url可以划分成若干个组件，协议、主机、路径等。有一些字符（:&#x2F;?#[]@）是用作分隔不同组件的。例如：冒号用于分隔协议和主 机，&#x2F;用于分隔主机和路径，?用于分隔路径和查询参数，等等。还有一些字符（!$&amp;&#39;()*+,;&#x3D;）用于在每个组件中起到分隔作用的，如&#x3D;用于 表示查询参数中的键值对，&amp;符号用于分隔查询多个键值对。当组件中的普通数据包含这些特殊字符时，需要对其进行编码。</p>
<p>RFC3986中指定了以下字符为保留字符：! * &#39; ( ) ; : @ &amp; &#x3D; + $ , &#x2F; ? # [ ]</p>
<p>不安全字符：还有一些字符，当他们直接放在Url中的时候，可能会引起解析程序的歧义。这些字符被视为不安全字符，原因有很多。</p>
<ul>
<li>空格：Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。</li>
<li>引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用</li>
<li>#：通常用于表示书签或者锚点</li>
<li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li>
<li>{}|^[]&#96;~：某一些网关或者传输代理会篡改这些字符</li>
</ul>
<hr>
<p>需要注意的是，对于Url中的合法字符，编码和不编码是等价的，但是对于上面提到的这些字符，如果不经过编码，那么它们有可能会造成Url语义 的不同。因此对于Url而言，只有普通英文字符和数字，特殊字符$-_.+!*&#39;()还有保留字符，才能出现在未经编码的Url之中。其他字符均需要经过 编码之后才能出现在Url中。</p>
<hr>
<h3 id="如何对url进行编码"><a href="#如何对url进行编码" class="headerlink" title="如何对url进行编码"></a>如何对url进行编码</h3><p>Url编码通常也被称为百分号编码（Url Encoding，also known as percent-encoding），是因为它的编码方式非常简单，使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的 十六进制形式。Url编码默认使用的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就 是%61，我们在地址栏上输入http://g.cn/search?q=%61%62%63，实际上就等同于在google上搜索abc了。又如@符号 在ASCII字符集中对应的字节为0x40，经过Url编码之后得到的是%40。</p>
<p>对于非ASCII字符，需要使用ASCII字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码。对于Unicode字 符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。如&quot;中文&quot;使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到&quot;%E4%B8%AD%E6%96%87&quot;。</p>
<p>如果某个字节对应着ASCII字符集中的某个非保留字符，则此字节无需使用百分号表示。例如&quot;Url编码&quot;，使用UTF-8编码得到的字节是 0x55 0x72 0x6C 0xE7 0xBC 0x96 0xE7 0xA0 0x81，由于前三个字节对应着ASCII中的非保留字符&quot;Url&quot;，因此这三个字节可以用非保留字符&quot;Url&quot;表示。最终的Url编码可以简化 成&quot;Url%E7%BC%96%E7%A0%81&quot; ，当然，如果你用&quot;%55%72%6C%E7%BC%96%E7%A0%81&quot;也是可以的。</p>
<h2 id="使用vim去除EOL"><a href="#使用vim去除EOL" class="headerlink" title="使用vim去除EOL"></a>使用vim去除EOL</h2><p>还可以使用vim去除文件末尾的换行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">You can turn off the &#x27;eol&#x27; option and turn on the &#x27;binary&#x27; option to write</span><br><span class="line">a file without the EOL at the end of the file:</span><br><span class="line"></span><br><span class="line">    :set binary</span><br><span class="line">    :set noeol</span><br><span class="line">    :w</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/08/05/linux/How-to-find-the-INODE-usage-on-Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/05/linux/How-to-find-the-INODE-usage-on-Linux/" class="post-title-link" itemprop="url">Linux inode 小记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-05 13:59:15" itemprop="dateCreated datePublished" datetime="2019-08-05T13:59:15+08:00">2019-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是inode"><a href="#什么是inode" class="headerlink" title="什么是inode"></a>什么是inode</h2><p>理解inode，要从文件储存说起。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做&quot;扇区&quot;（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>
<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个&quot;块&quot;（block）。这种由多个扇区组成的&quot;块&quot;，是文件存取的最小单位。&quot;块&quot;的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>
<p>文件数据都储存在&quot;块&quot;中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为&quot;索引节点&quot;。</p>
<p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<h2 id="inode的内容"><a href="#inode的内容" class="headerlink" title="inode的内容"></a>inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：</p>
<ul>
<li>文件的字节数</li>
<li>文件拥有者的User ID</li>
<li>文件的Group ID</li>
<li>文件的读、写、执行权限</li>
<li>文件的时间戳</li>
<li>链接数，即有多少文件名指向这个inode</li>
<li>文件数据block的位置</li>
</ul>
<p>使用<code>stat</code>命令查看某个文件的<code>inode信息</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> $ <span class="built_in">stat</span> proxy.sh </span><br><span class="line">  File: proxy.sh</span><br><span class="line">  Size: 89        	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 802h/2050d	Inode: 9714171     Links: 1</span><br><span class="line">Access: (0755/-rwxr-xr-x)  Uid: ( 1000/ liupeng)   Gid: ( 1000/ liupeng)</span><br><span class="line">Access: 2019-07-29 10:25:57.880429139 +0800</span><br><span class="line">Modify: 2019-07-29 10:25:57.880429139 +0800</span><br><span class="line">Change: 2019-07-29 10:26:05.910683677 +0800</span><br><span class="line"> Birth: 2019-07-29 10:25:57.880429139 +0800</span><br></pre></td></tr></table></figure>

<h2 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h2><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p>
<p>每个inode节点的大小，一般是128字节或256字节，甚至可以手动指定到2K，inode节点的总数，在格式化时就给定，以ext3&#x2F;ext4为例：</p>
<ul>
<li>每个 inode 大小为 256byte，block 大小为 4k byte；</li>
<li>根据 block count 和 inode count，我们也可以算出 16k bytes-per-inode（15728384*4096&#x2F;3932160）</li>
</ul>
<p>也就是文件系统在创建的时候每16k空间自动划分一个inode，如果你需要存储的是大量的小文件，那么你应该在格式化分区的时候手动修改<code>bytes-per-inode</code>的值，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 -i 8192 /dev/sda1</span><br></pre></td></tr></table></figure>
<p>而在<code>xfs</code>文件系统中<code>-i inode_options</code>中的<code>maxpct=value</code>描述如下：</p>
<p><em>This  specifies  the  maximum percentage of space in the filesystem that can be allocated to inodes. The default value is 25% for filesystems under 1TB, 5% for filesystems under 50TB and 1% for filesystems over 50TB.</em></p>
<p>可见默认情况下<code>xfs</code>文件系统要比<code>ext</code>文件系统分配更多的inode</p>
<p>可以使用<code>df -i</code>查看inode的大小和使用率</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">df</span> -i</span></span><br><span class="line">Filesystem       Inodes   IUsed    IFree IUse% Mounted on</span><br><span class="line">dev             1015658     414  1015244    1% /dev</span><br><span class="line">run             1017797     680  1017117    1% /run</span><br><span class="line">/dev/sda2      14057472 1003259 13054213    8% /</span><br><span class="line">tmpfs           1017797     129  1017668    1% /dev/shm</span><br><span class="line">tmpfs           1017797      18  1017779    1% /sys/fs/cgroup</span><br><span class="line">tmpfs           1017797     629  1017168    1% /tmp</span><br><span class="line">/dev/sda1             0       0        0     - /boot/efi</span><br><span class="line">tmpfs           1017797      37  1017760    1% /run/user/1000</span><br></pre></td></tr></table></figure>

<h2 id="inode号"><a href="#inode号" class="headerlink" title="inode号"></a>inode号</h2><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p>
<p>这里值得重复一遍，Unix&#x2F;Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>
<p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>
<p>使用<code>ls -i</code>命令，可以看到文件名对应的inode号码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -i proxy.sh</span> </span><br><span class="line">9714171 proxy.sh</span><br></pre></td></tr></table></figure>

<h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>Unix&#x2F;Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>
<p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>
<h2 id="查看目录的inode"><a href="#查看目录的inode" class="headerlink" title="查看目录的inode"></a>查看目录的inode</h2><p>通过介绍我们知道，通常情况下每个文件对应一个inode，那么如果想查找某个目录使用的inode数量，则可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear;echo &quot;Detailed Inode usage: $(pwd)&quot; ; for d in `find -maxdepth 1 -type d |cut -d\/ -f2 |grep -xv . |sort`; do c=$(find $d |wc -l) ; printf &quot;$c\t\t- $d\n&quot; ; done ; printf &quot;Total: \t\t$(find $(pwd) | wc -l)\n&quot;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Detailed Inode usage: /home/liupeng/liupzmin.github.io</span><br><span class="line">312		    - .git</span><br><span class="line">8049		- node_modules</span><br><span class="line">294		    - public</span><br><span class="line">4		    - scaffolds</span><br><span class="line">45		    - source</span><br><span class="line">409		    - themes</span><br><span class="line">Total: 		    9120</span><br></pre></td></tr></table></figure>

<p>要清理inode，只要找到包含大量文件的目录删除之即可。</p>
<p><strong>参考文献：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTEvMTIvaW5vZGUuaHRtbA==">理解inode<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aGVnZWVrc2FsaXZlLmNvbS9ob3ctdG8tZmluZC10aGUtaW5vZGUtdXNhZ2Utb24tbGludXgv">How to find the INODE usage on Linux<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/08/02/golang/working-zip-archive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/02/golang/working-zip-archive/" class="post-title-link" itemprop="url">Golang 使用zip压缩、解压缩</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-02 09:24:15" itemprop="dateCreated datePublished" datetime="2019-08-02T09:24:15+08:00">2019-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Golang提供了几个包可以将文件压缩为不同的类型，这篇博客主要展示一下<code>archive/zip</code>这个包的用法，如何将文件或文件夹压缩为<code>zip</code>格式,以及如何进行解压缩。</p>
<h2 id="Compressing"><a href="#Compressing" class="headerlink" title="Compressing"></a>Compressing</h2><h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zipit(<span class="string">&quot;/tmp/documents&quot;</span>, <span class="string">&quot;/tmp/backup.zip&quot;</span>, <span class="string">&quot;*.log&quot;</span>)</span><br><span class="line">zipit(<span class="string">&quot;/tmp/report.txt&quot;</span>, <span class="string">&quot;/tmp/report-2015.zip&quot;</span>, <span class="string">&quot;*.log&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="func-Zipit"><a href="#func-Zipit" class="headerlink" title="func Zipit"></a>func Zipit</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩为zip格式</span></span><br><span class="line"><span class="comment">//source为要压缩的文件或文件夹, 绝对路径和相对路径都可以</span></span><br><span class="line"><span class="comment">//target是目标文件</span></span><br><span class="line"><span class="comment">//filter是过滤正则(Golang 的 包 path.Match)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Zipit</span><span class="params">(source, target, filter <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> isAbs := filepath.IsAbs(source); !isAbs &#123;</span><br><span class="line">		source, err = filepath.Abs(source) <span class="comment">// 将传入路径直接转化为绝对路径</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建zip包文件</span></span><br><span class="line">	zipfile, err := os.Create(target)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := zipfile.Close(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">			log.Slogger.Errorf(<span class="string">&quot;*File close error: %s, file: %s&quot;</span>, err.Error(), zipfile.Name())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建zip.Writer</span></span><br><span class="line">	zw := zip.NewWriter(zipfile)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := zw.Close(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">			log.Slogger.Errorf(<span class="string">&quot;zipwriter close error: %s&quot;</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	info, err := os.Stat(source)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> baseDir <span class="type">string</span></span><br><span class="line">	<span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">		baseDir = filepath.Base(source)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = filepath.Walk(source, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将遍历到的路径与pattern进行匹配</span></span><br><span class="line">		ism, err := filepath.Match(filter, info.Name())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果匹配就忽略</span></span><br><span class="line">		<span class="keyword">if</span> ism &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建文件头</span></span><br><span class="line">		header, err := zip.FileInfoHeader(info)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> baseDir != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			header.Name = filepath.Join(baseDir, strings.TrimPrefix(path, source))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">			header.Name += <span class="string">&quot;/&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			header.Method = zip.Deflate</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//写入文件头信息</span></span><br><span class="line">		writer, err := zw.CreateHeader(header)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//写入文件内容</span></span><br><span class="line">		file, err := os.Open(path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := file.Close(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">				log.Slogger.Errorf(<span class="string">&quot;*File close error: %s, file: %s&quot;</span>, err.Error(), file.Name())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		_, err = io.Copy(writer, file)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Extracting"><a href="#Extracting" class="headerlink" title="Extracting"></a>Extracting</h2><h3 id="usage-1"><a href="#usage-1" class="headerlink" title="usage"></a>usage</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip(<span class="string">&quot;/tmp/report-2015.zip&quot;</span>, <span class="string">&quot;/tmp/reports/&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="func-Unzip"><a href="#func-Unzip" class="headerlink" title="func Unzip"></a>func Unzip</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解压zip</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unzip</span><span class="params">(archive, target <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	reader, err := zip.OpenReader(archive)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := os.MkdirAll(target, <span class="number">0755</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, file := <span class="keyword">range</span> reader.File &#123;</span><br><span class="line">		unzippath := filepath.Join(target, file.Name)</span><br><span class="line">		<span class="keyword">if</span> file.FileInfo().IsDir() &#123;</span><br><span class="line">			err := os.MkdirAll(unzippath, file.Mode())</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fileReader, err := file.Open()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> fileReader.Close()</span><br><span class="line"></span><br><span class="line">		targetFile, err := os.OpenFile(unzippath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> targetFile.Close()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, err := io.Copy(targetFile, fileReader); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.WithStack(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考文献：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cucmFsY2guY29tL3R1dG9yaWFsL2dvbGFuZy13b3JraW5nLXdpdGgtemlwLw==">Golang: Working with ZIP archives<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/07/31/golang/golang-three-dots/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/31/golang/golang-three-dots/" class="post-title-link" itemprop="url">golang三个点(...)的用法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-31 13:17:31" itemprop="dateCreated datePublished" datetime="2019-07-31T13:17:31+08:00">2019-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Passing-arguments-to-parameters"><a href="#Passing-arguments-to-parameters" class="headerlink" title="Passing arguments to ... parameters"></a>Passing arguments to ... parameters</h2><p>If f is variadic with a final parameter p of type ...T, then within f the type of p is equivalent to type []T. If f is invoked with no actual arguments for p, the value passed to p is nil. Otherwise, the value passed is a new slice of type []T with a new underlying array whose successive elements are the actual arguments, which all must be assignable to T. The length and capacity of the slice is therefore the number of arguments bound to p and may differ for each call site.</p>
<p>Given the function and calls</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greeting</span><span class="params">(prefix <span class="type">string</span>, who ...<span class="type">string</span>)</span></span></span><br><span class="line">Greeting(<span class="string">&quot;nobody&quot;</span>)</span><br><span class="line">Greeting(<span class="string">&quot;hello:&quot;</span>, <span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Eileen&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>within Greeting, who will have the value nil in the first call, and []string{&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;} in the second.</p>
<p>If the final argument is assignable to a slice type []T, it may be passed unchanged as the value for a ...T parameter if the argument is followed by .... In this case no new slice is created.</p>
<p>Given the slice s and call</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Jasmine&quot;</span>&#125;</span><br><span class="line">Greeting(<span class="string">&quot;goodbye:&quot;</span>, s...)</span><br></pre></td></tr></table></figure>

<p>within Greeting, who will have the same value as s with the same underlying array.</p>
<p><strong>上面是官方文档中关于<code>...</code>的用法的描述，主要有两种使用形式：</strong></p>
<h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><p>如果<code>最后一个</code>函数参数的类型的是...T，那么在调用这个函数的时候，我们可以在参数列表的最后使用若干个类型为T的参数。这里，...T在函数内部的类型实际是[]T,是隐式创建的slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        res += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="slice参数"><a href="#slice参数" class="headerlink" title="slice参数"></a>slice参数</h3><p>如果传入的<code>最后一个</code>函数参数是slice []T,直接在slice后跟<code>...</code>，那么就不会创建新的slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primes := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Println(Sum(primes...)) <span class="comment">// 17</span></span><br></pre></td></tr></table></figure>

<p>因此，当我们想把一个slice追加到另外一个slice时，可以使用如下方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s1 = <span class="built_in">append</span>(s1, s2...) <span class="comment">// instead of FOR</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>

<p>或者，当我们想在slice中删除一个元素时:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fo index, v := <span class="keyword">range</span> s1&#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">2</span>&#123;</span><br><span class="line">        s1 = <span class="built_in">append</span>(s1[:index], s1[index+<span class="number">1</span>:]...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标识数组元素个数"><a href="#标识数组元素个数" class="headerlink" title="标识数组元素个数"></a>标识数组元素个数</h2><p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// &quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p>在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, q) <span class="comment">// &quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Go命令行中的通配符"><a href="#Go命令行中的通配符" class="headerlink" title="Go命令行中的通配符"></a>Go命令行中的通配符</h2><p>描述包文件的通配符。<br>在这个例子中，会单元测试当前目录和所有子目录的所有包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> ./...</span><br></pre></td></tr></table></figure>

<p><strong>参考文献：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW5neWFjaGVuL3poYW5neWFjaGVuLmdpdGh1Yi5pby9pc3N1ZXMvMTM3">golang 三个点(three dots)的用法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3JlZi9zcGVjI1Bhc3NpbmdfYXJndW1lbnRzX3RvXy4uLl9wYXJhbWV0ZXJz">Passing arguments to ... parameters<i class="fa fa-external-link-alt"></i></span></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2018/03/22/bigdata/spark2.2-use-python3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/22/bigdata/spark2.2-use-python3/" class="post-title-link" itemprop="url">在spark2.2.0中使用python 3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-22 15:29:00" itemprop="dateCreated datePublished" datetime="2018-03-22T15:29:00+08:00">2018-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Cannot run program &quot;python3&quot;: error&#x3D;2, 没有那个文件或目录</p>
</blockquote>
<p>spark2中默认使用的是python2，可以通过以下三种方式之一使用python3：</p>
<ol>
<li><code>PYSPARK_PYTHON=python3  pyspark2</code></li>
<li>修改<code>~/.bash_profile</code>，增加 <code>PYSPARK_PYTHON=python3</code></li>
<li>修改<code>spark-env.sh</code>增加<code>PYSPARK_PYTHON=/usr/local/bin/python3</code></li>
</ol>
<p><code>如果使用前2种不带绝对路径的变量声明时可能会遇到</code>Cannot run program &quot;python3&quot;: error&#x3D;2, 没有那个文件或目录<code>错误，原因是我的spark环境默认的是运行在</code>yarn<code>上的，当执行RDD任务时会在其他节点报错：</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop-04 ~]# PYSPARK_PYTHON=python3 pyspark2</span><br><span class="line">Python 3.6.4 (default, Mar 21 2018, 13:55:56) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-16)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 2.2.0.cloudera2</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.6.4 (default, Mar 21 2018 13:55:56)</span><br><span class="line">SparkSession available as &#x27;spark&#x27;.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; lines = sc.textFile(<span class="string">&#x27;/afis/flume/auth/2018/03/16/auth.1521129675887.log&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines = lines.filter(lambda line:<span class="string">&quot;python&quot;</span> <span class="keyword">in</span> line)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines.count()</span></span><br><span class="line">[Stage 0:&gt; (0 + 2) / 2]18/03/22 13:25:22 WARN scheduler.TaskSetManager: Lost task 0.0 in stage 0.0 (TID 0, hadoop-02, executor 2): java.io.IOException: Cannot run program &quot;python3&quot;: error=2, 没有那个文件或目录</span><br><span class="line">        at java.lang.ProcessBuilder.start(ProcessBuilder.java:1048)</span><br><span class="line">        at org.apache.spark.api.python.PythonWorkerFactory.startDaemon(PythonWorkerFactory.scala:163)</span><br><span class="line">        at org.apache.spark.api.python.PythonWorkerFactory.createThroughDaemon(PythonWorkerFactory.scala:89)</span><br><span class="line">        at org.apache.spark.api.python.PythonWorkerFactory.create(PythonWorkerFactory.scala:65)</span><br><span class="line">        at org.apache.spark.SparkEnv.createPythonWorker(SparkEnv.scala:117)</span><br><span class="line">        at org.apache.spark.api.python.PythonRunner.compute(PythonRDD.scala:128)</span><br><span class="line">        at org.apache.spark.api.python.PythonRDD.compute(PythonRDD.scala:63)</span><br><span class="line">        at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:323)</span><br><span class="line">        at org.apache.spark.rdd.RDD.iterator(RDD.scala:287)</span><br><span class="line">        at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:87)</span><br><span class="line">        at org.apache.spark.scheduler.Task.run(Task.scala:108)</span><br><span class="line">        at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:338)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.io.IOException: error=2, 没有那个文件或目录</span><br><span class="line">        at java.lang.UNIXProcess.forkAndExec(Native Method)</span><br><span class="line">        at java.lang.UNIXProcess.&lt;init&gt;(UNIXProcess.java:247)</span><br><span class="line">        at java.lang.ProcessImpl.start(ProcessImpl.java:134)</span><br><span class="line">        at java.lang.ProcessBuilder.start(ProcessBuilder.java:1029)</span><br><span class="line">        ... 14 more</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 18/03/22 13:25:23 WARN scheduler.TaskSetManager: Lost task 1.0 <span class="keyword">in</span> stage 0.0 (TID 1, hadoop-03, executor 1): TaskKilled (stage cancelled)</span></span><br></pre></td></tr></table></figure>

<p><code>hadoop-02</code>这个节点上找不到<code>python3</code>导致任务终止,既然提示在其他节点上找不到，那在本地节点运行会是哪种结果呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop-04 ~]# PYSPARK_PYTHON=python3 pyspark2 --master local</span><br><span class="line">Python 3.6.4 (default, Mar 21 2018, 13:55:56) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-16)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 2.2.0.cloudera2</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.6.4 (default, Mar 21 2018 13:55:56)</span><br><span class="line">SparkSession available as &#x27;spark&#x27;.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; lines = sc.textFile(<span class="string">&#x27;/afis/flume/auth/2018/03/16/auth.1521129675887.log&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines = lines.filter(lambda line:<span class="string">&quot;python&quot;</span> <span class="keyword">in</span> line)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines.count()</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>可见在本地运行是没有问题的，那问题就出在<code>python3</code>的可执行文件少了绝对路径，猜测是spark内部的任务调度执行的时候没有使用操作系统的<code>PATH</code>导致找不到可执行文件，现在把<code>python3</code>的可执行文件路径补全：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop-04 ~]# PYSPARK_PYTHON=/usr/local/bin/python3 pyspark2</span><br><span class="line">Python 3.6.4 (default, Mar 21 2018, 13:55:56) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-16)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">18/03/22 14:54:52 WARN util.Utils: Service &#x27;SparkUI&#x27; could not bind on port 4040. Attempting port 4041.</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 2.2.0.cloudera2</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 3.6.4 (default, Mar 21 2018 13:55:56)</span><br><span class="line">SparkSession available as &#x27;spark&#x27;.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; lines = sc.textFile(<span class="string">&#x27;/afis/flume/auth/2018/03/16/auth.1521129675887.log&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines = lines.filter(lambda line:<span class="string">&quot;python&quot;</span> <span class="keyword">in</span> line)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines.count()</span></span><br><span class="line">0                                                                               </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines = lines.filter(lambda line:<span class="string">&quot;SessionTask&quot;</span> <span class="keyword">in</span> line)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; pythonlines.count()</span></span><br><span class="line">719</span><br></pre></td></tr></table></figure>

<p><strong>可见，要在spark2上使用python3需要设置<code>PYSPARK_PYTHON</code>为可执行文件的绝对路径，优先推荐设置<code>spark-env.sh</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop-01 ~]# more /etc/spark2/conf/spark-env.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Generated by Cloudera Manager and should not be modified directly</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line">SELF=&quot;$(cd $(dirname $BASH_SOURCE) &amp;&amp; pwd)&quot;</span><br><span class="line">if [ -z &quot;$SPARK_CONF_DIR&quot; ]; then</span><br><span class="line">  export SPARK_CONF_DIR=&quot;$SELF&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export SPARK_HOME=/opt/cloudera/parcels/SPARK2-2.2.0.cloudera2-1.cdh5.12.0.p0.232957/lib/spark2</span><br><span class="line">export DEFAULT_HADOOP_HOME=/opt/cloudera/parcels/CDH-5.14.0-1.cdh5.14.0.p0.24/lib/hadoop</span><br><span class="line">export PYSPARK_PYTHON=/usr/local/bin/python3</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"liupzmin","repo":"liupzmin.github.io","client_id":"77654195445087c01c56","client_secret":"eda09eecd05b86f0ef995d8067ec751abeb753d9","admin_user":"liupzmin","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","ClientID":"ae0756501dfc5de89d35","ClientSecret":"26befb359f7a466031bb96b4b7e0715c41c63fb8","owner":"liupzmin","adminUser":"['liupzmin']","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","createIssueManually":true,"distractionFreeMode":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"dbb1aad0300bb8f37fa677175e85a293"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
