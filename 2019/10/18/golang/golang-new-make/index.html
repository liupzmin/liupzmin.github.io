<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liupzmin.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Go语言中有两个builtin函数new和make，这个两个函数经常让初学者摸不着头脑，也许使用过程中并未有什么阻碍，但回过头看细想又难以说清道明。本文将针对这两个函数进行分析，希望能抽丝剥茧，彻底搞清楚他们的区别。 函数定义当然，我们先看Go官方对这两个函数的解释： func new(Type) *Typel The new built-in function allocates memory.">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言中的new和make-从函数阻击战到nil遭遇战">
<meta property="og:url" content="http://liupzmin.com/2019/10/18/golang/golang-new-make/index.html">
<meta property="og:site_name" content="兔子先生">
<meta property="og:description" content="Go语言中有两个builtin函数new和make，这个两个函数经常让初学者摸不着头脑，也许使用过程中并未有什么阻碍，但回过头看细想又难以说清道明。本文将针对这两个函数进行分析，希望能抽丝剥茧，彻底搞清楚他们的区别。 函数定义当然，我们先看Go官方对这两个函数的解释： func new(Type) *Typel The new built-in function allocates memory.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.liupzmin.com/interface.png">
<meta property="og:image" content="http://qiniu.liupzmin.com/nil-interface.jpg">
<meta property="og:image" content="http://qiniu.liupzmin.com/non-nil-interface.png">
<meta property="article:published_time" content="2019-10-18T01:30:46.000Z">
<meta property="article:modified_time" content="2025-02-07T01:32:12.639Z">
<meta property="article:author" content="巴流">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="go nil">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.liupzmin.com/interface.png">


<link rel="canonical" href="http://liupzmin.com/2019/10/18/golang/golang-new-make/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://liupzmin.com/2019/10/18/golang/golang-new-make/","path":"2019/10/18/golang/golang-new-make/","title":"Go语言中的new和make-从函数阻击战到nil遭遇战"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go语言中的new和make-从函数阻击战到nil遭遇战 | 兔子先生</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="兔子先生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">兔子先生</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探寻计算机的历史与哲学密码</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">63</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">函数定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#func-new-Type-Typel"><span class="nav-number">1.1.</span> <span class="nav-text">func new(Type) *Typel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#func-make-t-Type-size-IntegerType-Type"><span class="nav-number">1.2.</span> <span class="nav-text">func make(t Type, size ...IntegerType) Type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zero-value"><span class="nav-number">2.</span> <span class="nav-text">zero value</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#what-is-nil%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">what is nil？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nil%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.</span> <span class="nav-text">nil的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-number">3.2.</span> <span class="nav-text">nil的地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.3.</span> <span class="nav-text">不是关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kinds-of-nil"><span class="nav-number">4.</span> <span class="nav-text">kinds of nil</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pointer"><span class="nav-number">4.1.</span> <span class="nav-text">pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice"><span class="nav-number">4.2.</span> <span class="nav-text">slice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">4.3.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#channel"><span class="nav-number">4.4.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function"><span class="nav-number">4.5.</span> <span class="nav-text">function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interface"><span class="nav-number">4.6.</span> <span class="nav-text">interface</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-use-of-nil"><span class="nav-number">5.</span> <span class="nav-text">the use of nil</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="巴流"
      src="/images/gzh.jpg">
  <p class="site-author-name" itemprop="name">巴流</p>
  <div class="site-description" itemprop="description">左手人文 | 右手科技</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liupzmin"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdXB6bWluQGdtYWlsLmNvbQ==" title="E-Mail → mailto:liupzmin@gmail.com"><i class="envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2019/10/18/golang/golang-new-make/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go语言中的new和make-从函数阻击战到nil遭遇战 | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go语言中的new和make-从函数阻击战到nil遭遇战<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2xpdXB6bWluLmdpdGh1Yi5pby9lZGl0L2hleG9fcmVzb3VyY2Uvc291cmNlL19wb3N0cy9nb2xhbmcvZ29sYW5nLW5ldy1tYWtlLm1k" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-18 09:30:46" itemprop="dateCreated datePublished" datetime="2019-10-18T09:30:46+08:00">2019-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Go语言中有两个<code>builtin</code>函数<code>new</code>和<code>make</code>，这个两个函数经常让初学者摸不着头脑，也许使用过程中并未有什么阻碍，但回过头看细想又难以说清道明。本文将针对这两个函数进行分析，希望能抽丝剥茧，彻底搞清楚他们的区别。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>当然，我们先看Go官方对这两个函数的解释：</p>
<h3 id="func-new-Type-Typel"><a href="#func-new-Type-Typel" class="headerlink" title="func new(Type) *Typel"></a>func new(Type) *Typel</h3><blockquote>
<p>The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.</p>
</blockquote>
<p><strong>大意：new函数会分配内存，它唯一的一个参数是<code>type</code>不是value，返回值是一个指针，指向刚刚分配的那块内存，并且这块内存中存储着<code>type</code>的<code>零值（zero value）</code>。</strong></p>
<p>重点：</p>
<ol>
<li>分配内存</li>
<li>返回指向这块内存的指针</li>
<li>内存存储<code>type</code>的<code>零值</code></li>
</ol>
<h3 id="func-make-t-Type-size-IntegerType-Type"><a href="#func-make-t-Type-size-IntegerType-Type" class="headerlink" title="func make(t Type, size ...IntegerType) Type"></a>func make(t Type, size ...IntegerType) Type</h3><blockquote>
<p>The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make&#39;s return type is the same as the type of its argument, not a pointer to it.</p>
</blockquote>
<p><strong>大意：make仅用于分配和初始化<code>slice、map、chanel</code>，同new一样，第一个参数要传入一个<code>type</code>；不同的是，make返回的是初始化过之后的<code>type</code>的一个值，而不是指针。</strong></p>
<p>重点：</p>
<ol>
<li>分配内存并初始化</li>
<li>仅用于<code>slice</code>、<code>map</code>、<code>chanel</code></li>
<li>返回的是值，不是指针</li>
</ol>
<h2 id="zero-value"><a href="#zero-value" class="headerlink" title="zero value"></a>zero value</h2><p>上文提到<code>new()</code>会分配内存，并且为相应的<code>Type</code>存储<code>零值</code>，<code>那什么是零值呢？</code>官方对于<code>zero value</code>的描述如下：</p>
<blockquote>
<p>When storage is allocated for a variable, either through a declaration or a call of new, or when a new value is created, either through a composite literal or a call of make, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: false for booleans, 0 for numeric types, &quot;&quot; for strings, and nil for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.</p>
</blockquote>
<p><strong>大意：当通过声明或调用new为变量分配存储时，或者在创建新值时(通过复合字面值或调用make)，并且没有提供显式初始化时，将为变量或值提供默认值。此类变量或值的每个元素的类型都设置为该类型的零值:布尔值为false，数值类型为0，字符串为&quot;&quot;，指针、函数、接口、片、通道和映射为nil。这个初始化是递归完成的，因此，如果结构体中没有指定相应field的值，那么默认将是该field的零值。</strong></p>
<p>下面表格中展示了Go中主要类型的零值：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Zero Value</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>numeric</td>
<td>0</td>
</tr>
<tr>
<td>string</td>
<td>&quot;&quot;</td>
</tr>
<tr>
<td>pointer</td>
<td>nil</td>
</tr>
<tr>
<td>function</td>
<td>nil</td>
</tr>
<tr>
<td>interface</td>
<td>nil</td>
</tr>
<tr>
<td>slice</td>
<td>nil</td>
</tr>
<tr>
<td>map</td>
<td>nil</td>
</tr>
<tr>
<td>channel</td>
<td>nil</td>
</tr>
</tbody></table>
<p>其中，array和struct两个复合类型的零值为其承载的基础类型的零值，因为array和struct都是值类型，不像slice、map是引用类型。</p>
<p>但是，个人感觉上面一段话中关于<code>通过复合字面值或调用make</code>创造值的相关描述略有不准确。因为<code>Composite literals(复合字面值)</code>是为<code>structs</code>、<code>arrays</code>、<code>slices</code>、<code>maps</code>构造值，而<code>make</code>仅用于分配并初始化<code>slice</code>、<code>map</code>、<code>chanel</code>。如果使用<code>字面值</code>构造一个值且不显示的初始化，那么该值就是一个<code>空值（empty）</code>，和<code>make</code>的结果相同,<code>而不是零值nil</code>。看下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nilSlice []<span class="type">string</span></span><br><span class="line">newNilSlice := <span class="built_in">new</span>([]<span class="type">string</span>)</span><br><span class="line">emptySlice := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">emptySliceLiteral := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">fmt.Println(nilSlice)                                       <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nilSlice), <span class="built_in">cap</span>(nilSlice))                   <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(nilSlice == <span class="literal">nil</span>)                                <span class="comment">// Output: true</span></span><br><span class="line">fmt.Println(*newNilSlice)                                   <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(*newNilSlice), <span class="built_in">cap</span>(*newNilSlice))           <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(*newNilSlice == <span class="literal">nil</span>)							<span class="comment">// Output: true</span></span><br><span class="line">fmt.Println(emptySlice)                                     <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(emptySlice), <span class="built_in">cap</span>(emptySlice))               <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(emptySlice == <span class="literal">nil</span>)                              <span class="comment">// Output: false</span></span><br><span class="line">fmt.Println(emptySliceLiteral)                              <span class="comment">// Output: []</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(emptySliceLiteral), <span class="built_in">cap</span>(emptySliceLiteral)) <span class="comment">// Output: 0 0</span></span><br><span class="line">fmt.Println(emptySliceLiteral == <span class="literal">nil</span>)                       <span class="comment">// Output: false</span></span><br></pre></td></tr></table></figure>

<p>像<code>slice</code>、<code>map</code>这样的引用类型的<code>零值是nil</code>，并不是<code>“the variable or value is given a default value”</code>，因为<code>通过复合字面值或调用make</code>构造变量时<code>default value</code>是<code>empty</code>。（<em><strong>如果有人觉得这是咬文嚼字，那我也只能承认，毕竟nil让我很痛苦，后面我会再论述default value</strong></em>）。</p>
<p>一个<code>nil的slice</code>和一个<code>Empty的slice</code>很容易让你迷惑，它们都被<code>fmt.Println</code>打印出<code>[]</code>，它们拥有相同的<code>length</code>和<code>capacity</code>。</p>
<p>除非<code>nil</code>或者<code>Empty</code>会对你的逻辑产生影响，否则不用区别对待它们。如果你需要测试一个slice是否是空的，使用<code>len(s) == 0</code>来判断，而不应该用<code>s == nil</code>来判断。除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样。</p>
<p>另一个值得注意的问题是，当你使用<code>encoding/json</code>时，你要特别注意：Golang的<code>encoding/json</code>会将<code>Nil Slice</code>编码为<code>null</code>。</p>
<h2 id="what-is-nil？"><a href="#what-is-nil？" class="headerlink" title="what is nil？"></a>what is nil？</h2><h3 id="nil的定义"><a href="#nil的定义" class="headerlink" title="nil的定义"></a>nil的定义</h3><p>nil 为预声明的标示符，定义在builtin&#x2F;builtin.go，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// nil is a predeclared identifier representing the zero value for a</span><br><span class="line">// pointer, channel, func, interface, map, or slice type.</span><br><span class="line">// Type must be a pointer, channel, func, interface, map, or slice type</span><br><span class="line">var nil Type </span><br><span class="line"></span><br><span class="line">// Type is here for the purposes of documentation only. It is a stand-in</span><br><span class="line">// for any Go type, but represents the same type for any given function</span><br><span class="line">// invocation.</span><br><span class="line">type Type int</span><br></pre></td></tr></table></figure>

<p>可见，<code>nil没有默认类型</code>，它是一个预定义好的变量，有多种可能的类型（<code>pointer</code>、<code>map</code>、<code>slice</code>、<code>function</code>、<code>channel</code>、<code>interface</code>）。它代表指针、通道、函数、接口、映射或切片的<code>零值</code>。</p>
<p>你必须给编译器以足够的信息，使得编译器可以推导出nil的类型，因此下面的使用方式是非法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="literal">nil</span> <span class="comment">// illegal， doesn&#x27;t compile</span></span><br></pre></td></tr></table></figure>

<p>正确的做法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// There must be sufficient information for</span></span><br><span class="line">	<span class="comment">// compiler to deduce the type of a nil value.</span></span><br><span class="line">	_ = (*<span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)</span><br><span class="line">	_ = []<span class="type">int</span>(<span class="literal">nil</span>)</span><br><span class="line">	_ = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>(<span class="literal">nil</span>)</span><br><span class="line">	_ = <span class="keyword">chan</span> <span class="type">string</span>(<span class="literal">nil</span>)</span><br><span class="line">	_ = (<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(<span class="literal">nil</span>)</span><br><span class="line">	_ = <span class="keyword">interface</span>&#123;&#125;(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This lines are equivalent to the above lines.</span></span><br><span class="line">	<span class="keyword">var</span> _ *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ []<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">chan</span> <span class="type">string</span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="nil的地址"><a href="#nil的地址" class="headerlink" title="nil的地址"></a>nil的地址</h3><p>各种类型的<code>nil</code>的内存布局始终相同,换一句话说就是：不同类型nil的内存地址是一样的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> sl []<span class="type">int</span></span><br><span class="line">	testNewAddr := <span class="built_in">new</span>([]<span class="type">string</span>)</span><br><span class="line">	testMakeAddr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, m)            	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, ptr)          	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, sl)           	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, *testNewAddr) 	<span class="comment">//0x0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, testMakeAddr) 	<span class="comment">//0x57db60</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，值为<code>nil</code>的变量都指向同样的内存地址<code>0x0</code>，这是一个无效的地址，如果对这个地址进行读写，会引发<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p *<span class="type">int</span>  <span class="comment">// Declare a nil value pointer</span></span><br><span class="line">	*p = <span class="number">10</span>		<span class="comment">// Write the value 10 to address 0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x4525b2]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/home/alarm/go/test/test.go:5 +0x2</span><br></pre></td></tr></table></figure>

<p>我们来看一下这段代码的<code>plan9汇编</code>指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go tool objdump -s main<span class="number">.</span>main <span class="keyword">test</span></span><br><span class="line"></span><br><span class="line">TEXT main<span class="number">.</span>main(SB) /home/alarm/go/<span class="keyword">test</span>/<span class="keyword">test</span><span class="number">.</span>go</span><br><span class="line"><span class="symbol">  test.go:</span><span class="number">5</span>		<span class="number">0x4525b0</span>		31c0				XORL <span class="built_in">AX</span>, <span class="built_in">AX</span>		</span><br><span class="line"><span class="symbol">  test.go:</span><span class="number">5</span>		<span class="number">0x4525b2</span>		48c7000a000000		<span class="keyword">MOVQ</span> <span class="number">$0</span>xa, <span class="number">0</span>(<span class="built_in">AX</span>)	</span><br><span class="line"><span class="symbol">  test.go:</span><span class="number">6</span>		<span class="number">0x4525b9</span>		c3					<span class="keyword">RET</span>				</span><br></pre></td></tr></table></figure>
<p>从汇编指令可以看到，<code>AX</code>寄存器被清零，之后试图将<code>0xa</code>（10）写入<code>AX指向的内存地址</code>，然后就导致了panic。</p>
<p><em><strong>现在我们可以作如下总结：</strong></em></p>
<blockquote>
<p><code>非引用类型</code>一旦赋予<code>default value</code>（或者说<code>zero value</code>），那么将会实际分配内存，并且内存中数据初始化为相应类型的<code>zero value</code>；而零值为<code>nil</code>的类型都是<code>引用类型</code>，其背后引用了使用前必须初始化的数据结构，它们的<code>default value</code>为<code>nil</code>，尚未分配内存，相应的数据结构也未被初始化。例如，slice是一个三元描述符，包含一个指向数据（在数组中）的指针、长度、以及容量，在这些项被初始化之前，slice都是nil的。对于slice，map和channel，make初始化这些内部数据结构，并准备好可用的值（对应类型的<code>zero value</code>）。</p>
</blockquote>
<h3 id="不是关键字"><a href="#不是关键字" class="headerlink" title="不是关键字"></a>不是关键字</h3><p>另一个值得注意的地方：<code>nil不是Go的关键字</code>，你可以重写他，但是最好不要这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="literal">nil</span> := <span class="number">123</span></span><br><span class="line">	fmt.Println(<span class="literal">nil</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following line fails to compile,</span></span><br><span class="line">	<span class="comment">// for nil represents an int value now</span></span><br><span class="line">	<span class="comment">// in this scope.</span></span><br><span class="line">	<span class="keyword">var</span> _ <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kinds-of-nil"><a href="#kinds-of-nil" class="headerlink" title="kinds of nil"></a>kinds of nil</h2><p>我们知道nil的种类有<code>pointer</code>, <code>channel</code>, <code>func</code>, <code>interface</code>, <code>map</code>, or <code>slice</code>，下面分别讨论一下这几种类型的nil行为。</p>
<p>先说明一下这几种类型的nil含义：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>pointer</td>
<td>什么也不指向</td>
</tr>
<tr>
<td>function</td>
<td>没有初始化</td>
</tr>
<tr>
<td>interface</td>
<td>没有赋值，空指针</td>
</tr>
<tr>
<td>slice</td>
<td>没有底层数组</td>
</tr>
<tr>
<td>map</td>
<td>没有初始化</td>
</tr>
<tr>
<td>channel</td>
<td>没有初始化</td>
</tr>
</tbody></table>
<h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><p>在go中，指针指向一个内存地址，同c&#x2F;c++中一样，但go中的指针没有指针运算，所以是安全的。可以有以下几种方式生成pointer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 第一种：直接声明指针类型</span></span><br><span class="line">	<span class="keyword">var</span> p *[]<span class="type">int</span></span><br><span class="line">	fmt.Println(p == <span class="literal">nil</span>)		<span class="comment">// Output: true</span></span><br><span class="line">	fmt.Println(*p == <span class="literal">nil</span>)		<span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	<span class="comment">// 第二种：使用new()函数返回指针</span></span><br><span class="line">	pNew := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(pNew == <span class="literal">nil</span>)	<span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(*pNew == <span class="literal">nil</span>)	<span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三种：通过取址符&amp;，产生一个指向变量的指针</span></span><br><span class="line">	s := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	pAnd := &amp;s</span><br><span class="line">	fmt.Println(pAnd == <span class="literal">nil</span>)	<span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(*pAnd == <span class="literal">nil</span>)	<span class="comment">// Output: false</span></span><br><span class="line">	<span class="comment">// 给nil的指针赋值</span></span><br><span class="line">	p = &amp;s</span><br><span class="line">	fmt.Println(p == <span class="literal">nil</span>)		<span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(*p == <span class="literal">nil</span>)		<span class="comment">// Output: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我故意用了<code>slice</code>的指针类型，因此当pNew不是nil的时候，<code>*pNew依然是nil</code>。</p>
<p><code>nil的指针无法解引用，如果试图对一个nil的指针解引用的话会产生panic。</code></p>
<p><code>但是Nil却可以作为合法的接收器：</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> PointerReciver <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *PointerReciver)</span></span> showme()&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Yeah, it works!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ta *PointerReciver</span><br><span class="line">	ta.showme()		<span class="comment">// Yeah, it works!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>slice的底层是一个数组，那么一个nil的slice是没有底层数组的。一个<code>nil</code>的或者<code>长度为0的非nil</code>的slice都无法被索引，但是可以使用<code>append</code>去填充值。下面代码展示了各种构造slice的方式，以及nil的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//  显示声明</span></span><br><span class="line">	<span class="keyword">var</span> ts []<span class="type">int</span></span><br><span class="line">	fmt.Println(ts == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	ts[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	ts = <span class="built_in">append</span>(ts, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用new函数</span></span><br><span class="line">	p := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(*p == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	(*p)[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	*p = <span class="built_in">append</span>(*p, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用字面值初始化</span></span><br><span class="line">	literal := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	fmt.Println(literal == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	literal[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	literal = <span class="built_in">append</span>(literal, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用make初始化</span></span><br><span class="line">	mp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(mp == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	mp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line">	mp = <span class="built_in">append</span>(mp, <span class="number">2</span>) <span class="comment">// slice: [2]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从数组截取</span></span><br><span class="line">	arrayExample := [<span class="number">10</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	sliceFromArray := arrayExample[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">	fmt.Println(sliceFromArray == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	sliceFromArray[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	sliceFromArray = <span class="built_in">append</span>(sliceFromArray, <span class="number">2</span>) <span class="comment">// slice: [1 0 0 2]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tnilslice []<span class="type">int</span></span><br><span class="line">	<span class="comment">// 不会迭代</span></span><br><span class="line">	<span class="keyword">for</span> k ,v := <span class="keyword">range</span> tnilslice&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;k: %d, v: %d\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Slice小结：</strong></p>
<p><em><strong>1. 显示声明、未初始化值时为nil</strong></em><br><em><strong>2. 使用new函数生成slice为nil</strong></em><br><em><strong>3. 字面值初始化的slice，未提供具体值的为Empty，不是nil，但长度和容量与nil相同都为0</strong></em><br><em><strong>4. 使用make初始化的slice未提供长度和容量的为Empty，提供的初始化为相应类型的零值</strong></em><br><em><strong>5. nil和Empty的slice（长度为0）无法被索引</strong></em><br><em><strong>6. 使用for...range遍历nil的slice不会迭代，也不会报错</strong></em></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map的底层是一个哈希表，通过内置的make函数可以快速构建一个map。make创建map时，实际底层调用的是<code>makemap</code>函数，返回值是一个结构体指针。</p>
<blockquote>
<p>func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap</p>
</blockquote>
<p>使用make可以选填<code>capacity </code>，capacity 不限制map的大小，map会自适应增长，但是nil的map除外。除了不允许添加元素以外，nil的map等价于Empty的map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接声明</span></span><br><span class="line">	<span class="keyword">var</span> dmap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	fmt.Println(dmap == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	fmt.Println(dmap[<span class="string">&quot;a&quot;</span>])   <span class="comment">// Output: 0</span></span><br><span class="line">	dmap[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>            <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line">	<span class="built_in">delete</span>(dmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用new函数</span></span><br><span class="line">	nmap := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(*nmap == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line">	fmt.Println((*nmap)[<span class="string">&quot;a&quot;</span>]) <span class="comment">// Output: 0</span></span><br><span class="line">	(*nmap)[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>          <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line">	<span class="built_in">delete</span>(*nmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字面量初始化</span></span><br><span class="line">	lmap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	fmt.Println(lmap == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(lmap[<span class="string">&quot;a&quot;</span>])   <span class="comment">// Output: 0</span></span><br><span class="line">	lmap[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>            <span class="comment">// sucess</span></span><br><span class="line">	<span class="built_in">delete</span>(lmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用make初始化</span></span><br><span class="line">	mmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(mmap == <span class="literal">nil</span>) <span class="comment">// Output: false</span></span><br><span class="line">	fmt.Println(mmap[<span class="string">&quot;a&quot;</span>])   <span class="comment">// Output: 0</span></span><br><span class="line">	mmap[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>            <span class="comment">// sucess</span></span><br><span class="line">	<span class="built_in">delete</span>(mmap, <span class="string">&quot;c&quot;</span>)        <span class="comment">// no-op</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tnilmap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	<span class="comment">// 不会迭代</span></span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> tnilmap&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;k: %s, v: %d\n&quot;</span>, key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>map小结：</strong></p>
<p><em><strong>1. 显示声明、未初始化值时为nil</strong></em><br><em><strong>2. 使用new函数生成的map为nil</strong></em><br><em><strong>3. nil的map只读，无法写入</strong></em><br><em><strong>4. map读取，如果没有要读取的key，则返回key对应类型的零值</strong></em><br><em><strong>5. delete时如果map为nil或者key不存在则什么也不做</strong></em><br><em><strong>5. map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</strong></em><br><em><strong>6. 使用for...range遍历nil的slice不会迭代，也不会报错</strong></em></p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>一个未被make初始化的channel是nil的，channel是通过make来初始化的，make在创建channel时底层调用了<code>makechan</code>函数，返回值是一个结构体指针。</p>
<blockquote>
<p>func makechan(t *chantype, size int64) *hchan</p>
</blockquote>
<p>这里不去讨论详细的channel用法，仅仅对nil的情况做一下阐述。</p>
<ol>
<li><p>读写一个nil的channel会造成永远阻塞。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">&lt;- ch <span class="comment">// block</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span>  <span class="comment">// block</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭一个nil的channel会产生panic。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// panic: close of nil channel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>往一个已经关闭的channel发送数据会产生panic</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// panic: send on closed channel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从一个已关闭的channel接收数据会收到最后发送的数据或者对应类型的零值</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// Output: 1</span></span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">// Output: 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>for...range语句会自动感知channel的关闭，但遇到nil会永远阻塞</p>
<p> 利用for...range优雅退出协程：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Using for-range to exit goroutine</span></span><br><span class="line">	<span class="comment">// range has the ability to detect the close/end of a channel</span></span><br><span class="line">	<span class="keyword">for</span> x := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Process %d\n&quot;</span>, x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(inCh)</span><br></pre></td></tr></table></figure>

<p> 遍历nil的通道：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tc  <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="comment">// 永远阻塞</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> tc &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>function和map、channel一样底层是一个指针，如果一个函数没有被初始化，那么它就是nil的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">fmt.Println(myFun == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br></pre></td></tr></table></figure>

<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p><code>interface</code>是比较有意思的一个类型，也是go能够具有<code>面向对象特征</code>以及<code>多态</code>基石，它是一个结构体，包含了<code>动态类型</code>和<code>动态值</code>。</p>
<p><img data-src="http://qiniu.liupzmin.com/interface.png" alt="interface"></p>
<p>对于一个接口的零值就是它的类型和值的部分都是nil， 只有<code>都为nil</code>的情况下<code>接口值 == nil</code>才成立。</p>
<p><img data-src="http://qiniu.liupzmin.com/nil-interface.jpg" alt="nil interface"></p>
<ol>
<li><p>调用一个空接口值上的任意方法都会产生panic</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"></span><br><span class="line">fmt.Println(w == <span class="literal">nil</span>) <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的(<code>此时nil不是nil</code>)</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...do something...</span></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">		out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上述示例，虽然我们给函数<code>f</code>传入了一个nil的指针（<code>*bytes.Buffer</code>），但是go将out的动态类型设为了<code>*bytes.Buffer</code>，动态值设为nil，意思就是out变量是一个包含了nil指针值的非nil接口，所以<code>out != nil</code>仍然为<code>true</code>，nil经过一道赋值的关卡后已不再是nil。</p>
</li>
</ol>
<p><img data-src="http://qiniu.liupzmin.com/non-nil-interface.png" alt="non nin interface with nil pointer"></p>
<h2 id="the-use-of-nil"><a href="#the-use-of-nil" class="headerlink" title="the use of nil"></a>the use of nil</h2><p><code>nil</code>并不总是为我们制造困难，有些时候也有其妙用。</p>
<ol>
<li><p><code>nil的指针可以作为合理的方法接收者</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> PointerReciver <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *PointerReciver)</span></span> showme()&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Yeah, it works!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ta *PointerReciver</span><br><span class="line">	ta.showme()		<span class="comment">// Yeah, it works!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nil的slice可以正常的append</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nil的map是只读的， 当你需要一个空map参数时可以使用nil</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGet</span><span class="params">(url <span class="type">string</span>, headers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> (*http.Request, <span class="type">error</span>) &#123;</span><br><span class="line">	req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		req.Header.Set(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 你可能想做如下调用，传入空的map</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewGet(</span><br><span class="line">		<span class="string">&quot;http://google.com&quot;</span>,</span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;,</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p> 你只需传入一个nil即可：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewGet(<span class="string">&quot;http://google.com&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nil的通道永远阻塞</code></p>
<p> 有时候我们可以利用<code>nil通道的阻塞特性</code>，比如有如下代码：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-a:</span><br><span class="line">				out &lt;- v</span><br><span class="line">			<span class="keyword">case</span> v := &lt;-b:</span><br><span class="line">				out &lt;- v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个函数不断的从通道a和b读取数据，然后写入out通道，如果a和b其中有通道关闭，根据关闭通道的特性，我们知道会从	读取到对应类型的零值，那么如何才能跳过已经close的分支呢？	<br> 对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		a = <span class="literal">nil</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;a is now closed&quot;</span>)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	out &lt;- v</span><br></pre></td></tr></table></figure>
</li>
<li><p>nil的接口</p>
<p> 不用多说了</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章通过探索<code>new</code>和<code>make</code>的用法，揭示了go中初始化变量的一些规律，避免新手gopher使用过程中的困惑，对于这两个内置方法的使用时机，我个人的看法是：<code>如果你需要初始化一个slice、map、chan类型的变量，那么优先使用make</code>；<code>如果你需要一个指针接收器或者明确需要一个指针的时候，new会是一个不错的选择</code>。</p>
<p>在查阅new和make的过程中，我们遭遇了恼人的<code>nil</code>，本文也通过一些浅薄的分析，总结出了nil的一些规律，希望能给阅读本文的人带来一些帮助，同时也作为个人学习中的笔记可以随时翻阅，加强理解。</p>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3JlZi9zcGVj">The Go Programming Language Specification<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj15bm9ZMnh6LUY4cw==">video:Understanding nil<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nbzEwMS5vcmcvYXJ0aWNsZS9uaWwuaHRtbA==">nils in Go<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BoYWJpYnJpZGhvL2dvbGFuZy1uaWwtdnMtZW1wdHktc2xpY2UtODdmZDUxYzBhNGQ=">Golang: Nil vs Empty Slice<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHVzdGNhdC9wLzQwMDQ4ODkuaHRtbA==">深入学习golang(4)—new与make<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNC8wMi9kaXZlLWludG8tZ28tc2xpY2Uv">深度解密Go语言之slice<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNS8yMi9kaXZlLWludG8tZ28tbWFwLw==">深度解密Go语言之map<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNy8yMi9kaXZlLWludG8tZ28tY2hhbm5lbC8=">深度解密Go语言之channel<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xY3Jhby5jb20vMjAxOS8wNC8yNS9kaXZlLWludG8tZ28taW50ZXJmYWNlLw==">深度解密Go语言之关于interface的 10 个问题<i class="fa fa-external-link-alt"></i></span></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
              <a href="/tags/go-nil/" rel="tag"># go nil</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/10/09/theory/three-body-problem/" rel="prev" title="《三体》问题">
                  <i class="fa fa-chevron-left"></i> 《三体》问题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/11/06/docker/container-chat/" rel="next" title="漫谈容器发展史">
                  漫谈容器发展史 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"liupzmin","repo":"liupzmin.github.io","client_id":"77654195445087c01c56","client_secret":"eda09eecd05b86f0ef995d8067ec751abeb753d9","admin_user":"liupzmin","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","ClientID":"ae0756501dfc5de89d35","ClientSecret":"26befb359f7a466031bb96b4b7e0715c41c63fb8","owner":"liupzmin","adminUser":"['liupzmin']","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","createIssueManually":true,"distractionFreeMode":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"f5a9954401095ba8154af6fd501aa49d"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
