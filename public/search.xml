<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment func Test()&#123; a := 1 fmt.printf("Hello GoLang!")&#125;]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用DBMS_SCHEDULER在Oracle 11gR2 RAC上执行rman备份]]></title>
    <url>%2F2017%2F07%2F01%2Foracle%2Fbackup-restore%2Fdbms_scheduler-for-rman-backup%2F</url>
    <content type="text"><![CDATA[利用DBMS_SCHEDULER在Oracle 11gR2 RAC上执行rman备份RMAN backup in Oracle 11gR2 RAC is exactly same like RMAN backup in Oracle 11gR2 single node.The only difference is: Typically, in case of Oracle single node database, we will schedule RMAN scripts with the help of CRON job and it will run according to our convenience, but in case of Oracle RAC if we schedule RMAN script and if unfortunately that RAC node goes down ( where we configured RMAN scripts ), then RMAN backup won’t run obviously. So, Same strategy will not be work in Oracle RAC node. For RMAN consistent backups use dbms_scheduler &amp; we need to place RMAN scripts in shared directory. ( Or in my case, I have created identical scripts on both cluster node’s ) 注意： 需要将脚本放在共享位置或者每个节点的相同位置 看一下rman的备份脚本，此脚本将备份放在ASM中，将日志放在节点本地 ################################################################# rman_backup_rac.sh FOR RAC ## created by lp ## 2017/03/22 ## usage: rman_backup_rac.sh &lt;$BACKUP_LEVEL&gt; ## BACKUP_LEVEL: ## F: full backup ## 0: level 0 ## 1: level 1 ##################################################################!/bin/bash# User specific environment and startup programsexport ORACLE_HOME=/u01/app/oracle/product/11.2.0/dbhome_1export RMAN_BAK_LOG_BASE=/home/oracle/DbBackupexport RMAN_BAK_DATA_BASE=+data/NXRAC/backupexport ORACLE_SID=`ps -ef|grep pmon|grep -v ASM|grep -v grep|awk -F&apos;_&apos; &apos;&#123;print $NF&#125;&apos;`export TIMESTAMP=`date +%Y%m%d%H%M`;#the destination of rman backuppieceexport RMAN_DATA=$&#123;RMAN_BAK_DATA_BASE&#125;/rman#the destination of rman backup logsexport RMAN_LOG=$&#123;RMAN_BAK_LOG_BASE&#125;/logsif [[ ! -z $1 ]] &amp;&amp; echo $1 |grep -Ew &quot;[01F]&quot; &gt;/dev/null 2&gt;&amp;1then export RMAN_LEVEL=$&#123;1&#125; # Check rman level if [ &quot;$RMAN_LEVEL&quot; == &quot;F&quot; ]; then unset INCR_LVL BACKUP_TYPE=full else INCR_LVL=&quot;INCREMENTAL LEVEL $&#123;RMAN_LEVEL&#125;&quot; BACKUP_TYPE=lev$&#123;RMAN_LEVEL&#125; fielse echo &quot;$&#123;1&#125; wrong argument!&quot; &gt;$&#123;RMAN_LOG&#125;/wrong_argument_$&#123;TIMESTAMP&#125;.log exit 1fi#the prefix of rman backuppiece export RMAN_FILE=$&#123;RMAN_DATA&#125;/$&#123;BACKUP_TYPE&#125;_$&#123;TIMESTAMP&#125;#the logfile of shell script including the rman logs contentsexport SSH_LOG=$&#123;RMAN_LOG&#125;/$&#123;BACKUP_TYPE&#125;_$&#123;TIMESTAMP&#125;.log#the size of backuppieceexport MAXPIECESIZE=4G##################################################################### ## the name of rman logs excluding the file expanded-name, ## when the shell is complete,the content of this file will be ## appended to the $SSH_LOG and the rman logfile will be deleted. ## #####################################################################export RMAN_LOG_FILE=$&#123;RMAN_LOG&#125;/$&#123;BACKUP_TYPE&#125;_$&#123;TIMESTAMP&#125;_1#Check RMAN Backup Pathif ! test -d $&#123;RMAN_LOG&#125;thenmkdir -p $&#123;RMAN_LOG&#125;fiecho &quot;---------------------------------&quot; &gt;&gt;$&#123;SSH_LOG&#125;echo &quot; &quot; &gt;&gt;$&#123;SSH_LOG&#125;echo &quot;Rman Begin to Working .........&quot; &gt;&gt;$&#123;SSH_LOG&#125;echo &quot;Begin time at:&quot; `date` --`date +%Y%m%d%H%M` &gt;&gt;$&#123;SSH_LOG&#125;#Startup rman to backup$ORACLE_HOME/bin/rman log=$&#123;RMAN_LOG_FILE&#125;.log &lt;&lt;EOFconnect target /run &#123;CONFIGURE RETENTION POLICY TO RECOVERY WINDOW OF 7 DAYS;CONFIGURE BACKUP OPTIMIZATION ON;CONFIGURE CONTROLFILE AUTOBACKUP ON;CONFIGURE DEVICE TYPE DISK PARALLELISM 4 BACKUP TYPE TO BACKUPSET;CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO &apos;$&#123;RMAN_DATA&#125;/control_auto_%F&apos;;ALLOCATE CHANNEL &apos;ch1&apos; TYPE DISK maxpiecesize=$&#123;MAXPIECESIZE&#125; CONNECT &apos;SYS/passwd@node1&apos;;ALLOCATE CHANNEL &apos;ch2&apos; TYPE DISK maxpiecesize=$&#123;MAXPIECESIZE&#125; CONNECT &apos;SYS/passwd@node1&apos;;ALLOCATE CHANNEL &apos;ch3&apos; TYPE DISK maxpiecesize=$&#123;MAXPIECESIZE&#125; CONNECT &apos;SYS/passwd@mode2&apos;;ALLOCATE CHANNEL &apos;ch4&apos; TYPE DISK maxpiecesize=$&#123;MAXPIECESIZE&#125; CONNECT &apos;SYS/passwd@node2&apos;;CROSSCHECK ARCHIVELOG ALL;DELETE NOPROMPT OBSOLETE;DELETE NOPROMPT EXPIRED BACKUP;BACKUP AS COMPRESSED BACKUPSET$&#123;INCR_LVL&#125;DATABASE FORMAT &apos;$&#123;RMAN_FILE&#125;_db_%U&apos; TAG &apos;$&#123;BACKUP_TYPE&#125;_$&#123;TIMESTAMP&#125;&apos;;SQL &apos;ALTER SYSTEM ARCHIVE LOG CURRENT&apos;;BACKUP FILESPERSET 20 ARCHIVELOG ALL FORMAT &apos;$&#123;RMAN_FILE&#125;_arc_%U&apos; TAG &apos;$&#123;ORACLE_SID&#125;_arc_$&#123;TIMESTAMP&#125;&apos;DELETE INPUT; RELEASE CHANNEL ch1;RELEASE CHANNEL ch2;RELEASE CHANNEL ch3;RELEASE CHANNEL ch4;ALLOCATE CHANNEL ch00 TYPE DISK;BACKUP FORMAT &apos;$&#123;RMAN_DATA&#125;/cntrl_%U&apos; CURRENT CONTROLFILE;RELEASE CHANNEL ch00;&#125;exit;EOFRC=$?cat $&#123;RMAN_LOG_FILE&#125;.log &gt;&gt;$&#123;SSH_LOG&#125;echo &quot;Rman Stop working @ time:&quot;`date` `date +%Y%m%d%H%M` &gt;&gt;$&#123;SSH_LOG&#125;if [ $RC -ne &quot;0&quot; ]; then echo &quot;------ error ------&quot; &gt;&gt;$&#123;SSH_LOG&#125;else echo &quot;------ Success during RMAN backup peroid------&quot; &gt;&gt;$&#123;SSH_LOG&#125; rm -rf $&#123;RMAN_LOG_FILE&#125;.logfiexit DBMS_SCHEDULER: Here we are using DBMS_SCHEDULER instead of DBMS_JOB, because DBMS_SCHEDULER is RAC aware. Before jump into real DBMS_SCHEDULER configuration, we need to focus on an important thing, That: Both RAC nodes local time zone must be identical with DBMS_SCHEDULER default time. On all RAC node, Ensure local time zone and set it accordingly. [oracle@node2 ]$ cat /etc/sysconfig/clockZONE="Asia/Shanghai" configure default time zone for DBMS_SCHEDULER SQL&gt; select value from dba_scheduler_global_attribute where attribute_name = 'DEFAULT_TIMEZONE';VALUE--------------------------------------------------------------------------------PRCSQL&gt; exec dbms_scheduler.set_scheduler_attribute ('DEFAULT_TIMEZONE', 'Asia/Shanghai');PL/SQL procedure successfully completed.SQL&gt; select value from dba_scheduler_global_attribute where attribute_name = 'DEFAULT_TIMEZONE';VALUE--------------------------------------------------------------------------------Asia/Shanghai Now we need to create credential so that are assigned to DBMS_SCHEDULER jobs so that they can authenticate with a local/remote host operating system or a remote Oracle database. SQL&gt; exec dbms_scheduler.create_credential(credential_name =&gt; 'oracle', username =&gt; 'oracle', password =&gt; 'oracle');PL/SQL procedure successfully completed. Now its time to create DBMS_SCHEDULER job for RMAN incremental level 0 backup, Here in this procedure I am going to create RMAN_INC0_BACKUP job with required attributes. begindbms_scheduler.create_job(job_name =&gt; 'RMAN_INC0_BACKUP',job_type =&gt; 'EXECUTABLE',job_action =&gt; '/bin/sh',number_of_arguments =&gt; 2,start_date =&gt; SYSTIMESTAMP,credential_name =&gt; 'oracle',auto_drop =&gt; FALSE,enabled =&gt; FALSE);end;/ Set argument_position &amp; argument_value ( i.e. Path of the RMAN script ) for the same job: begindbms_scheduler.set_job_argument_value(job_name =&gt; 'RMAN_INC0_BACKUP',argument_position =&gt; 1,argument_value =&gt; '/home/oracle/rman.sh');end;/begindbms_scheduler.set_job_argument_value(job_name =&gt; 'RMAN_INC0_BACKUP',argument_position =&gt; 2,argument_value =&gt; 0);end;/ Set start_date for the same job, In my case RMAN_INC0_BACKUP job will execute every week on sunday @03am, so job start date and its first run timing would according to my convenience. begindbms_scheduler.set_attribute(name =&gt; 'RMAN_INC0_BACKUP',attribute =&gt; 'start_date',value =&gt; trunc(sysdate)+3/24);end;/ Test your backup job manually in SQL prompt by instantiating RMAN_INC0_BACKUP job. SQL&gt; exec dbms_scheduler.run_job('RMAN_INC0_BACKUP');PL/SQL procedure successfully completed. Verify running RMAN backup status by issuing following SQL query, It will show you RMAN backup details with start time &amp; end time. select SESSION_KEY, INPUT_TYPE, STATUS,to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,elapsed_seconds/3600 hrsfrom V$RMAN_BACKUP_JOB_DETAILSorder by session_key; In case of any error while test run, you can make sure details of error by issuing the following query, OR You can also query to dba_scheduler_job_run_details dictionary view for more details. select JOB_NAME,STATUS,STATE,ERROR#,CREDENTIAL_NAME from dba_scheduler_job_run_details where CREDENTIAL_NAME like 'RMAN%'; After successfully completion of test run, Enable &amp; schedule it by following procedure by setting value to repeat_interval parameter, In my case RMAN_INC0_BACKUP job will execute every week on Sunday @03pm. begindbms_scheduler.set_attribute(name =&gt; 'RMAN_INC0_BACKUP',attribute =&gt; 'repeat_interval',value =&gt; 'freq=daily;byday=sun;byhour=03');dbms_scheduler.enable( 'RMAN_INC0_BACKUP' );end;/ Ensure dbms_scheduler job details by issuing the following query OR you can also query to dba_scheduler_jobs and dba_scheduler_job_args. SQL&gt; select job_name,enabled,owner, state from dba_scheduler_jobs where job_name in ('RMAN_INC0_BACKUP'); Keep your eye on behavior of dbms_scheduler job by issuing the following query: SQL&gt; select job_name,RUN_COUNT,LAST_START_DATE,NEXT_RUN_DATE from dba_scheduler_jobs where job_name in ('RMAN_INC0_BACKUP');SQL&gt; select * from dba_scheduler_job_args where job_name like 'RMAN%'; In accordance with the above method to create a level 1 backup job RMAN_INC1_BACKUP，The only difference is the repeat_interval： begindbms_scheduler.set_attribute(name =&gt; 'RMAN_INC1_BACKUP',attribute =&gt; 'repeat_interval',value =&gt; 'freq=daily;byday=mon,tue,wed,thu,fri,sat;byhour=03');dbms_scheduler.enable( 'RMAN_INC1_BACKUP' );end;/ Important Note:DBMS_SCHEDULER is smart enough to start backup on the node where the last backup was successfully executed. 参考： https://dbatricksworld.com/how-to-backup-oracle-rac-11gr2-database-with-rman-backup-utility-with-the-help-of-dbms_scheduler-part-i-rman-full-database-backup/ http://dbatricksworld.com/how-to-backup-oracle-rac-11gr2-database-with-rman-backup-utility-with-the-help-of-dbms_scheduler-part-ii-rman-incremental-database-backup/]]></content>
      <categories>
        <category>oracle backup</category>
      </categories>
      <tags>
        <tag>oracle backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[enq之TM-contention解决之道——外键无索引导致锁争用（上）]]></title>
    <url>%2F2016%2F07%2F25%2Foracle%2Flock-latch%2Fenq-TM-1%2F</url>
    <content type="text"><![CDATA[近日，开发负责人反映某生产环境业务处理缓慢，主要业务操作就是修改会员信息，登录查询后发现大量的session正在等待enq: TM - contention，且waiting的语句几乎都是updatesession的即时信息没有保留，现在附上ash视图的一些统计信息，可以大概了解一下当时争用的场景 SQL&gt; @ash_wait_chains.sql username||':'||program2||event2 session_type='FOREGROUND' sysdate-6/24 sysdate-5/24-- Display ASH Wait Chain Signatures script v0.2 BETA by Tanel Poder ( http://blog.tanelpoder.com )%This SECONDS AAS------ ---------- ----------WAIT_CHAIN------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 72% 20073 5.6-&gt; JSCHPROD:(JDBC Thin Client) ON CPU 8% 2293 .6-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) ON CPU 8% 2141 .6-&gt; JSCHPROD:(JDBC Thin Client) log file sync -&gt; SYS:(LGWR) log file parallel write 7% 1879 .5-&gt; JSCHPROD:(JDBC Thin Client) log file sync -&gt; SYS:(LGWR) LGWR-LNS wait on channel 2% 654 .2-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) ON CPU 1% 288 .1-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) ON CPU 1% 149 0-&gt; JSCHPROD:(JDBC Thin Client) log file sync -&gt; SYS:(LGWR) ON CPU 0% 128 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention 0% 112 0-&gt; JSCHPROD:(JDBC Thin Client) log file sync 0% 86 0-&gt; JSCHPROD:(JDBC Thin Client) db file scattered read 0% 43 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) ON CPU 0% 37 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention 0% 25 0-&gt; JSCHPROD:(JDBC Thin Client) log file sync -&gt; SYS:(LGWR) LGWR wait on LNS 0% 13 0-&gt; JSCHPROD:(plsqldev.exe) ON CPU 0% 11 0-&gt; SYS:(plsqldev.exe) ON CPU 0% 10 0-&gt; JSCHPROD:(JDBC Thin Client) SQL*Net more data from client 0% 9 0-&gt; JSCHPROD:(JDBC Thin Client) db file sequential read 0% 9 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) ONCPU 0% 6 0-&gt; JSCHPROD:(JDBC Thin Client) read by other session -&gt; JSCHPROD:(JDBC Thin Client) ON CPU 0% 4 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention -&gt; JSCHPROD:(JDBC Thin Client) enq: TM - contention 0% 3 0-&gt; JSCHPROD:(JDBC Thin Client) SQL*Net more data to client 0% 3 0-&gt; JSCHPROD:(JDBC Thin Client) buffer busy waits [data block] 0% 3 0-&gt; SYS:(oraagent.bin) Disk file operations I/O 0% 3 0-&gt; JSCHPROD:(JDBC Thin Client) log file sync -&gt; SYS:(LGWR) LGWR wait for redo copy 0% 2 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TX - row lock contention 0% 2 0-&gt; JSCHPROD:(JDBC Thin Client) log file sync -&gt; SYS:(LGWR) LGWR wait for redo copy -&gt; JSCHPROD:(JDBC Thin Client) ON CPU 0% 2 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TX - index contention -&gt; JSCHPROD:(JDBC Thin Client) ON CPU 0% 1 0-&gt; JSCHPROD:(plsqldev.exe) log file sync -&gt; SYS:(LGWR) log file parallel write 0% 1 0-&gt; SYS:(plsqldev.exe) Disk file operations I/O 0% 1 0-&gt; JSCHPROD:(JDBC Thin Client) enq: TX - row lock contention -&gt; JSCHPROD:(JDBC Thin Client) ON CPU30 rows selected. 可以看到，TM锁的争用很多，再看一份当时awr报告的top10 虽然占DBTIME不多，但本来是很快的操作，短时间内给人的感觉就是业务处理缓慢查一下当时等待事件的p1,p2,p3的值 select ash.SAMPLE_TIME, ash.EVENT, ash.SESSION_ID, ash.BLOCKING_SESSION, ash.P1TEXT, ash.P1, ash.P2TEXT, ash.p2, ash.p3text, ash.p3, ash.SESSION_STATE, ash.SQL_OPNAME, ash.SQL_ID --ash.* from v$active_session_history ash where ash.SAMPLE_TIME &gt; to_date('20160425 10:00:00', 'yyyymmdd HH24:MI:SS') and ash.SAMPLE_TIME &lt; to_date('20160425 12:10:00', 'yyyymmdd HH24:MI:SS') and ash.WAIT_CLASS &lt;&gt; 'Idle' and ash.EVENT like 'enq: TM - contention' order by sample_time desc; 下面是部分结果 enq: TM - contention 1828 2401 name|mode 1414332421 object # 110417 table/partition 0 WAITING UPDATE ak25v8q8p6fzdenq: TM - contention 1873 2504 name|mode 1414332419 object # 110415 table/partition 0 WAITING INSERT 7w0tma5up32wtenq: TM - contention 2504 1828 name|mode 1414332421 object # 110415 table/partition 0 WAITING UPDATE ak25v8q8p6fzdenq: TM - contention 772 4 name|mode 1414332421 object # 110417 table/partition 0 WAITING UPDATE ak25v8q8p6fzdenq: TM - contention 1781 1828 name|mode 1414332419 object # 110415 table/partition 0 WAITING INSERT 7w0tma5up32wtenq: TM - contention 1828 772 name|mode 1414332421 object # 110415 table/partition 0 WAITING UPDATE ak25v8q8p6fzdenq: TM - contention 2401 1828 name|mode 1414332419 object # 110415 table/partition 0 WAITING INSERT 7w0tma5up32wtenq: TM - contention 2504 772 name|mode 1414332421 object # 110415 table/partition 0 WAITING UPDATE ak25v8q8p6fzdenq: TM - contention 4 772 name|mode 1414332419 object # 110415 table/partition 0 WAITING INSERT 7w0tma5up32wtenq: TM - contention 148 1781 name|mode 1414332420 object # 110428 table/partition 0 WAITING UPDATE 9gd6xhd0xyhphenq: TM - contention 772 148 name|mode 1414332421 object # 110415 table/partition 0 WAITING UPDATE ak25v8q8p6fzdenq: TM - contention 1828 148 name|mode 1414332421 object # 110415 table/partition 0 WAITING UPDATE ak25v8q8p6fzdenq: TM - contention 1873 772 name|mode 1414332419 object # 110415 table/partition 0 WAITING INSERT 7w0tma5up32wt 可以看到p2的值为产生TM争用的对象id，经过查证，这些object均是session正在更新的表的子表，而且通过v$sql查看update语句均更改了主表的主键，问题到这里已经很明朗了，由于外键没加索引，导致了主表在更新主表主键或删除主表记录时对子表的锁定，而且这张主表被大量的子表引用，此时子表上也同时进行事务处理，所以造成了更新主表的session 不时hang住。 通过对所有子表的外键加索引，消除了争用，检测未加索引的外键语句： SELECT TABLE_NAME, CONSTRAINT_NAME, CNAME1 || NVL2(CNAME2, ',' || CNAME2, NULL) || NVL2(CNAME3, ',' || CNAME3, NULL) || NVL2(CNAME4, ',' || CNAME4, NULL) || NVL2(CNAME5, ',' || CNAME5, NULL) || NVL2(CNAME6, ',' || CNAME6, NULL) || NVL2(CNAME7, ',' || CNAME7, NULL) || NVL2(CNAME8, ',' || CNAME8, NULL) COLUMNS FROM (SELECT B.TABLE_NAME, B.CONSTRAINT_NAME, MAX(DECODE(POSITION, 1, COLUMN_NAME, NULL)) CNAME1, MAX(DECODE(POSITION, 2, COLUMN_NAME, NULL)) CNAME2, MAX(DECODE(POSITION, 3, COLUMN_NAME, NULL)) CNAME3, MAX(DECODE(POSITION, 4, COLUMN_NAME, NULL)) CNAME4, MAX(DECODE(POSITION, 5, COLUMN_NAME, NULL)) CNAME5, MAX(DECODE(POSITION, 6, COLUMN_NAME, NULL)) CNAME6, MAX(DECODE(POSITION, 7, COLUMN_NAME, NULL)) CNAME7, MAX(DECODE(POSITION, 8, COLUMN_NAME, NULL)) CNAME8, COUNT(*) COL_CNT FROM (SELECT SUBSTR(TABLE_NAME, 1, 30) TABLE_NAME, SUBSTR(CONSTRAINT_NAME, 1, 30) CONSTRAINT_NAME, SUBSTR(COLUMN_NAME, 1, 30) COLUMN_NAME, POSITION FROM USER_CONS_COLUMNS) A, USER_CONSTRAINTS B WHERE A.CONSTRAINT_NAME = B.CONSTRAINT_NAME AND B.CONSTRAINT_TYPE = 'R' GROUP BY B.TABLE_NAME, B.CONSTRAINT_NAME) CONS WHERE COL_CNT &gt; ALL (SELECT COUNT(*) FROM USER_IND_COLUMNS I WHERE I.TABLE_NAME = CONS.TABLE_NAME AND I.COLUMN_NAME IN (CNAME1, CNAME2, CNAME3, CNAME4, CNAME5, CNAME6, CNAME7, CNAME8) AND I.COLUMN_POSITION &lt;= CONS.COL_CNT GROUP BY I.INDEX_NAME); 这是摘自TOM大师的语句，外键不加索引也是导致死锁的常见原因之一，因此对于主表经常进行更新删除操作的情况，外键一定要加索引。至于外键未加索引是如何导致锁定的，以及为何加了索引后争用就消失了? 敬请关注enq: TM - contention解决之道——外键无索引导致锁争用 （下）]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次ORA-00600[13011]处理过程]]></title>
    <url>%2F2016%2F07%2F20%2Foracle%2Fbackup-restore%2FORA-00600%5B13011%5D%2F</url>
    <content type="text"><![CDATA[一次掉电后，DG主库启动alert中报如下错误 Errors in file /home/oracle/app/oracle/diag/rdbms/min/min/trace/min_m002_4099.trc (incident=16328):ORA-00600: internal error code, arguments: [13011], [6443], [8463760], [14], [8488694], [0], [], [], [], [], [], []Incident details in: /home/oracle/app/oracle/diag/rdbms/min/min/incident/incdir_16328/min_m002_4099_i16328.trcUse ADRCI or Support Workbench to package the incident.See Note 411.1 at My Oracle Support for error and packaging details.Errors in file /home/oracle/app/oracle/diag/rdbms/min/min/trace/min_m002_4099.trc (incident=16329):ORA-00600: internal error code, arguments: [kewrose_1], [600], [ORA-00600: internal error code, arguments: [13011], [6443], [8463760], [14], [8488694], [0], [], [], [], [], [], []], [], [], [], [], [], [], [], [], []Incident details in: /home/oracle/app/oracle/diag/rdbms/min/min/incident/incdir_16329/min_m002_4099_i16329.trc 查看trace文件，部分内容如下 *** 2016-07-20 18:21:04.185*** SESSION ID:(169.43) 2016-07-20 18:21:04.185*** CLIENT ID:() 2016-07-20 18:21:04.185*** SERVICE NAME:(SYS$BACKGROUND) 2016-07-20 18:21:04.185*** MODULE NAME:(MMON_SLAVE) 2016-07-20 18:21:04.185*** ACTION NAME:(Auto-Purge Slave Action) 2016-07-20 18:21:04.185Dump continued from file: /home/oracle/app/oracle/diag/rdbms/min/min/trace/min_m000_2615.trcORA-00600: internal error code, arguments: [13011], [6665], [8395075], [14], [8462787], [0], [], [], [], [], [], []========= Dump for incident 14804 (ORA 600 [13011]) ========*** 2016-07-20 18:21:04.186dbkedDefDump(): Starting incident default dumps (flags=0x2, level=3, mask=0x0)----- Current SQL Statement for this session (sql_id=c8taax4bfzsjc) -----delete from WRH$_RSRC_PLAN tab where (:beg_snap &lt;= tab.snap_id and tab.snap_id &lt;= :end_snap and dbid = :dbid) and not exists (select 1 from WRM$_BASELINE b where (tab.dbid = b.dbid) and (tab.snap_id &gt;= b.start_snap_id) and (tab.snap_id &lt;= b.end_snap_id)) MOS中关于ORA-600 [13013]描述 Format: ORA-600 [13013] [a] [b] &#123;c&#125; [d] [e] [f]Arg [a] PasscountArg [b] Data Object numberArg &#123;c&#125; Tablespace Decimal Relative DBA (RDBA) of block containing the row to be updatedArg [d] Row Slot numberArg [e] Decimal RDBA of block being updated (Typically same as &#123;c&#125;)Arg [f] Code 确定object SQL&gt; select owner,object_name,object_type from dba_objects where object_id=6665;OWNER OBJECT_NAME OBJECT_TYPE------------------------------ ------------------------------------------------------------ -------------------SYS WRH$_RSRC_PLAN TABLE 可见与trc文件中的sql中对象名吻合，都是WRH$_RSRC_PLAN查看trc文件中的PLAN TABLE ----- Plan Table -----============Plan Table============-----------------------------------------------------------+-----------------------------------+| Id | Operation | Name | Rows | Bytes | Cost | Time |-----------------------------------------------------------+-----------------------------------+| 0 | DELETE STATEMENT | | | | 626 | || 1 | DELETE | WRH$_RSRC_PLAN | | | | || 2 | FILTER | | | | | || 3 | INDEX RANGE SCAN | WRH$_RSRC_PLAN_PK| 94 | 1598 | 8 | 00:00:01 || 4 | TABLE ACCESS BY INDEX ROWID | WRM$_BASELINE | 1 | 33 | 2 | 00:00:01 || 5 | INDEX RANGE SCAN | WRM$_BASELINE_PK | 1 | | 1 | 00:00:01 |-----------------------------------------------------------+-----------------------------------+ 1.The most common cause of this error is an index corruption. The first step is to check the indexes for corruption, i.e. run SQL&gt; ANALYZE INDEX WRH$_RSRC_PLAN_PK VALIDATE STRUCTURE;Index analyzed. 2.If the indexes do not report corruption, further test for corruption the base tables referenced in the execution plan or the statement producing the error: SQL&gt; ANALYZE TABLE WRH$_RSRC_PLAN VALIDATE STRUCTURE CASCADE;ANALYZE TABLE WRH$_RSRC_PLAN VALIDATE STRUCTURE CASCADE*ERROR at line 1:ORA-01499: table/index cross reference failure - see trace file 查看生成的trace文件内容 *** 2016-07-21 01:31:31.840*** SESSION ID:(52.5) 2016-07-21 01:31:31.840*** CLIENT ID:() 2016-07-21 01:31:31.840*** SERVICE NAME:(SYS$USERS) 2016-07-21 01:31:31.840*** MODULE NAME:(sqlplus@primary (TNS V1-V3)) 2016-07-21 01:31:31.840*** ACTION NAME:() 2016-07-21 01:31:31.840Table/Index row count mismatchtable 2901 : index 3203, 296Index root = tsn: 1 rdba: 0x0080194a 对于文件内容，简单介绍如下： trace文件中包含：&lt;description&gt;: tsn: &lt;tablespace number&gt; rdba: &lt;relative dba&gt;description有以下值：&quot;row not found in index&quot;&quot;Table/Index row count mismatch&quot;&quot;row mismatch in index dba&quot;&quot;Table row count/Bitmap index bit count mismatch&quot;&quot;kdavls: kdcchk returns %d when checking cluster dba 0x%08lx objn %d\n&quot;tsn: Tablespace Number表示的是索引存储的表空间编号。rdba: 是索引段头相对于数据块的存储地址。 运行以下sql查询索引的文件和块号 SELECT dbms_utility.data_block_address_file( to_number(trim(leading '0' fromreplace('&amp;&amp;rdba','0x','')),'XXXXXXXX') ) AS rfile#, dbms_utility.data_block_address_block( to_number(trim(leading '0' fromreplace('&amp;&amp;rdba','0x','')),'XXXXXXXX') ) AS block#FROM dual; 结果如下： SQL&gt; SELECT dbms_utility.data_block_address_file( 2 to_number(trim(leading '0' from 3 replace('&amp;&amp;rdba','0x','')),'XXXXXXXX') 4 ) AS rfile#, 5 dbms_utility.data_block_address_block( 6 to_number(trim(leading '0' from 7 replace('&amp;&amp;rdba','0x','')),'XXXXXXXX') 8 ) AS block# 9 FROM dual;Enter value for rdba: 0x0080194aold 3: replace('&amp;&amp;rdba','0x','')),'XXXXXXXX')new 3: replace('0x0080194a','0x','')),'XXXXXXXX')old 7: replace('&amp;&amp;rdba','0x','')),'XXXXXXXX')new 7: replace('0x0080194a','0x','')),'XXXXXXXX') RFILE# BLOCK#---------- ---------- 2 6474 接下来运行如下查询，定位具体的segment select owner, segment_name, segment_typefrom dba_segmentswhere header_file = &lt;rfile#&gt; and header_block = &lt;block#&gt; 结果如下： SQL&gt; select owner, segment_name, segment_type 2 from dba_segments 3 where header_file = 2 4 and header_block = 6474;OWNER SEGMENT_NAME SEGMENT_TYPE------------------------------ --------------------------------------------------------------------------------- ------------------SYS WRH$_RSRC_PLAN_PK INDEX 看来仍然是上面分析过的索引，这里是因为表和索引的数据不一致，那么重建索引 alter table WRH$_RSRC_PLAN drop constraint WRH$_RSRC_PLAN_PK cascade;alter table WRH$_RSRC_PLAN add constraint WRH$_RSRC_PLAN_PK primary key (DBID, SNAP_ID, INSTANCE_NUMBER, SEQUENCE#); 再次分析表，发现错误消失了 SQL&gt; ANALYZE TABLE WRH$_RSRC_PLAN VALIDATE STRUCTURE CASCADE;Table analyzed. 至此，问题解决 掉电仍是数据库的大敌，而此次并非只在这一张表上有讹误，还有其他一些WRH$表，这些表均属于sysaux表空间，这些表都是awr系列表，写入频繁，掉电容易引起数据的不一致性，但是，正因为是awr数据，并不是特别重要，修复起来也相对容易。 记录一下AWR Performance Tables介绍 The Oracle10g dynamic performance tables constitute the foundation of sophisticated automations such as Automatic Memory Management (AMM ) as well as intelligent advisory tools such as ADDM and the SQL Tuning Advisor.Remember, the AWR is a core feature of the 10g database kernel and automatically collects and stores important run-time performance information for our historical analysis.The tables that store this information are prefixed with wrh$ and are very similar in function to the STATSPACK tables. This could make STATSPACK appear somewhat obsolete, although it is still available in the $ORACLE_HOME/rdbms/admin directory.Unlike the more cumbersome STATSPACK utility, which requires knowledge of the table structure and creation of complex query scripts, the 10g Enterprise Manager (OEM) automatically displays and interprets this valuable time-series performance data.The wrh$ AWR tables store important historical statistical information about the database in the form of periodic snapshots. Each snapshot is a capture of the in–memory x$ fixed view and other control structures at a certain point in time. Each of the AWR table names is prefixed with wrm$ (Metadata tables), wrh$ (History tables), or wri$ (Advisory tables). 1. The wrm$ tables store metadata information for the Workload Repository. 2. The wrh$ tables store historical data or snapshots. 3. The wri$ tables: These 49 tables store data related to advisory functions.]]></content>
      <categories>
        <category>oracle restore</category>
      </categories>
      <tags>
        <tag>oracle restore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASSM三级位图结构与高水位的探究（下）]]></title>
    <url>%2F2015%2F09%2F30%2Foracle%2Farchitecture%2FASSM2%2F</url>
    <content type="text"><![CDATA[上一篇文章介绍了ASSM三级位图管理下的数据插入和高水位推进的关系，我们得出的结论是随着数据不断的插入，段大小的不断增长，L1中挂载的数据块的数量也会增长，而高水位是以L1中数据块大小的总和与区大小之间最小的一方为单位进行推进，而且我们知道要想应对大并发插入，就要使高水位之下的空闲块的数量尽可能多，但是如此一来就有可能造成空间的浪费，而oracle的初心也是本着节省空间的目的来设计的。之前我们用的是常规路径插入，能以L1和区的单位推动高水位，前提是要填满L1或区，而我们熟知的直接路径插入是在高水位之上插入，那是不是可以用直接路径插入快速增加高水位呢？我们来一探究竟。 首先构造测试的表空间和表，跟上一篇一样 SQL&gt; drop tablespace lp including contents and datafiles;Tablespace dropped.SQL&gt; create tablespace lp datafile '/home/oracle/app/oracle/oradata/DG43/lp.dbf' size 2048M uniform size 1m;create table lp (id number,des1 char(2000),des2 char(2000),des3 char(2000),des4 char(500)) tablespace lp;Tablespace created.SQL&gt;Table created.SQL&gt; alter table lp pctfree 24;Table altered.SQL&gt; select object_id,object_name from dba_objects where object_name='LP'; OBJECT_ID OBJECT_NAME---------- ------------------------------ 78760 LP 首先看一下，78760这个对象在buffer里的数据块有哪些 SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 131 N 78760 5 129 N 78760 5 130 N 78760 5 128 N 78760 有没有眼熟呢，128、129、130、131四个块刚好是两个L1、L2、L3我们定位段头块，看一下此时的高水位 SQL&gt; select segment_name ,HEADER_FILE,HEADER_BLOCK from dba_segments where segment_name='LP';SEGMENT_NAME HEADER_FILE HEADER_BLOCK------------------------------ ----------- ------------LP 5 131Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 1 #blocks: 128 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x01400084 ext#: 0 blk#: 4 ext size: 128 #blocks in seg. hdr's freelists: 0 #blocks below: 0 mapblk 0x00000000 offset: 0 SQL&gt; select dbms_utility.data_block_address_file(to_number('01400084', 'xxxxxxxx')) file#, 2 dbms_utility.data_block_address_block(to_number('01400084', 'xxxxxxxx')) block# 3 from dual; FILE# BLOCK#---------- ---------- 5 132 可以看出在没有任何数据的情况下，高水位是在第一个数据块上的，下面常规插入一行数据 insert into lp values(1,'a','a','a','a'); 看一下高水位和buffer中的块 SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 165 Y 78760 5 131 Y 78760 5 173 Y 78760 5 160 Y 78760 5 168 Y 78760 5 163 Y 78760 5 129 N 78760 5 171 Y 78760 5 166 Y 78760 5 174 Y 78760 5 161 Y 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 169 Y 78760 5 164 Y 78760 5 130 N 78760 5 172 Y 78760 5 167 Y 78760 5 175 Y 78760 5 162 Y 78760 5 128 Y 78760 5 170 Y 7876020 rows selected.SQL&gt; select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp;DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)------------------------------------ ------------------------------------ 5 160 Extent Control Header-----------------------------------------------------------------Extent Header:: spare1: 0 spare2: 0 #extents: 1 #blocks: 128last map 0x00000000 #maps: 0 offset: 2716Highwater:: 0x014000c0 ext#: 0 blk#: 64 ext size: 128#blocks in seg. hdr&apos;s freelists: 0#blocks below: 60mapblk 0x00000000 offset: 0 发现数据插入到160号块中，buffer中却多了16个块，高水位已移动到第二个L1中的第一个块上，看一下第一个L1 HWM Flag: HWM Set Highwater:: 0x014000c0 ext#: 0 blk#: 64 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 60 mapblk 0x00000000 offset: 0 -------------------------------------------------------- DBA Ranges : -------------------------------------------------------- 0x01400080 Length: 64 Offset: 0 0:Metadata 1:Metadata 2:Metadata 3:Metadata 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:unformatted 17:unformatted 18:unformatted 19:unformatted 20:unformatted 21:unformatted 22:unformatted 23:unformatted 24:unformatted 25:unformatted 26:unformatted 27:unformatted 28:unformatted 29:unformatted 30:unformatted 31:unformatted 32:FULL 33:75-100% free 34:75-100% free 35:75-100% free 36:75-100% free 37:75-100% free 38:75-100% free 39:75-100% free 40:75-100% free 41:75-100% free 42:75-100% free 43:75-100% free 44:75-100% free 45:75-100% free 46:75-100% free 47:75-100% free 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted SQL&gt; select dbms_utility.data_block_address_file(to_number('014000c0', 'xxxxxxxx')) file#, 2 dbms_utility.data_block_address_block(to_number('014000c0', 'xxxxxxxx')) block# 3 from dual; FILE# BLOCK#---------- ---------- 5 192 可以发现，buffer中新增的16个块是一次性格式化的这16个块，而高水位指在192号块上，直接路径插入一行 SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 165 N 78760 5 131 N 78760 5 173 N 78760 5 160 N 78760 5 168 N 78760 5 163 N 78760 5 129 N 78760 5 171 N 78760 5 166 N 78760 5 174 N 78760 5 161 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 169 N 78760 5 164 N 78760 5 130 N 78760 5 172 N 78760 5 167 N 78760 5 175 N 78760 5 162 N 78760 5 128 N 78760 5 170 N 7876020 rows selected.SQL&gt; insert /*+ append_values(lp)*/ into lp values(2,'b','b','b','b');1 row created.SQL&gt; commit;Commit complete.SQL&gt; select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp;DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)------------------------------------ ------------------------------------ 5 160 5 192SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 165 N 78760 5 131 Y 78760 5 173 N 78760 5 160 N 78760 5 168 N 78760 5 163 N 78760 5 129 Y 78760 5 171 N 78760 5 192 Y 78760 5 166 N 78760 5 174 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 161 N 78760 5 169 N 78760 5 164 N 78760 5 130 N 78760 5 172 N 78760 5 167 N 78760 5 175 N 78760 5 162 N 78760 5 128 Y 78760 5 170 N 7876021 rows selected.SQL&gt; alter system checkpoint;System altered. 可以发现确实插入到了192号块，并且192号块已在buffer中，看一下此时的高水位 Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 1 #blocks: 128 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x014000c1 ext#: 0 blk#: 65 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 65 mapblk 0x00000000 offset: 0 HWM Flag: HWM Set Highwater:: 0x014000c1 ext#: 0 blk#: 65 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 65 mapblk 0x00000000 offset: 0 -------------------------------------------------------- DBA Ranges : -------------------------------------------------------- 0x014000c0 Length: 64 Offset: 0 0:FULL 1:unformatted 2:unformatted 3:unformatted 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:unformatted 17:unformatted 18:unformatted 19:unformatted 20:unformatted 21:unformatted 22:unformatted 23:unformatted 24:unformatted 25:unformatted 26:unformatted 27:unformatted 28:unformatted 29:unformatted 30:unformatted 31:unformatted 32:unformatted 33:unformatted 34:unformatted 35:unformatted 36:unformatted 37:unformatted 38:unformatted 39:unformatted 40:unformatted 41:unformatted 42:unformatted 43:unformatted 44:unformatted 45:unformatted 46:unformatted 47:unformatted 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted --------------------------------------------------------End dump data blocks tsn: 5 file#: 5 minblk 129 maxblk 129 发现高水位仅仅移动了1个block，再试一遍 SQL&gt; insert /*+ append_values(lp)*/ into lp values(3,'c','c','c','c');1 row created.SQL&gt; commit;Commit complete.SQL&gt; select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp;DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)------------------------------------ ------------------------------------ 5 160 5 192 5 193SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 165 N 78760 5 131 Y 78760 5 173 N 78760 5 160 N 78760 5 168 N 78760 5 163 N 78760 5 129 Y 78760 5 171 N 78760 5 192 N 78760 5 166 N 78760 5 174 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 161 N 78760 5 169 N 78760 5 164 N 78760 5 130 N 78760 5 172 N 78760 5 193 Y 78760 5 167 N 78760 5 175 N 78760 5 162 N 78760 5 128 N 78760 5 170 N 7876022 rows selected. Extent Header:: spare1: 0 spare2: 0 #extents: 1 #blocks: 128 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x014000c2 ext#: 0 blk#: 66 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 66 mapblk 0x00000000 offset: 0 仍然是只推动了一个block，但是发现为何每次直接路径插入的block都会出现在buffer里呢？难道是11g这个append_values新的hint的原因，再来试一下传统的append SQL&gt; insert /*+ append*/ into lp select * from lp where trim(des1)='a';1 row created.SQL&gt; commit;Commit complete.SQL&gt; select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp;DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)------------------------------------ ------------------------------------ 5 160 5 192 5 193 5 194SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 165 N 78760 5 131 Y 78760 5 173 N 78760 5 194 Y 78760 5 160 N 78760 5 168 N 78760 5 163 N 78760 5 129 Y 78760 5 171 N 78760 5 192 N 78760 5 166 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 174 N 78760 5 161 N 78760 5 169 N 78760 5 164 N 78760 5 130 N 78760 5 172 N 78760 5 193 N 78760 5 167 N 78760 5 175 N 78760 5 162 N 78760 5 128 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 170 N 7876023 rows selected.SQL&gt; alter system checkpoint;System altered. Extent Control Header-----------------------------------------------------------------Extent Header:: spare1: 0 spare2: 0 #extents: 1 #blocks: 128 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x014000c3 ext#: 0 blk#: 67 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 67 mapblk 0x00000000 offset: 0 依然如故，不知道大家有没有发现，每次我执行完插入，都会执行一条select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp;这其实是全表扫描，本来块没在buffer里，一个FTS把块全给整进来了（小表buffer读，大表在11g中通常情况是直接路径读），知道原因了，再试一遍 SQL&gt; insert /*+ append*/ into lp select * from lp where trim(des1)='b';1 row created.SQL&gt; commit;Commit complete.SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 165 N 78760 5 131 Y 78760 5 173 N 78760 5 194 N 78760 5 160 N 78760 5 168 N 78760 5 163 N 78760 5 129 Y 78760 5 171 N 78760 5 192 N 78760 5 166 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 174 N 78760 5 161 N 78760 5 169 N 78760 5 164 N 78760 5 130 N 78760 5 172 N 78760 5 193 N 78760 5 167 N 78760 5 175 N 78760 5 162 N 78760 5 128 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 170 N 7876023 rows selected.SQL&gt; select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp;DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)------------------------------------ ------------------------------------ 5 160 5 192 5 193 5 194 5 195SQL&gt; select file#,BLOCK#,DIRTY,OBJD from v$bh where objd='78760'; FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 165 N 78760 5 131 Y 78760 5 173 N 78760 5 194 N 78760 5 160 N 78760 5 168 N 78760 5 163 N 78760 5 129 Y 78760 5 171 N 78760 5 192 N 78760 5 166 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 174 N 78760 5 195 Y 78760 5 161 N 78760 5 169 N 78760 5 164 N 78760 5 130 N 78760 5 172 N 78760 5 193 N 78760 5 167 N 78760 5 175 N 78760 5 162 N 78760 FILE# BLOCK# D OBJD---------- ---------- - ---------- 5 128 N 78760 5 170 N 7876024 rows selected. 终于看到了想要的结果，总结一下吧，直接路径下高水位的推进大概如下图的样子： 不知道大家有没有注意到，直接路径插入完后再读入buffer中居然是个脏块，这是不是跟延迟提交清除有关呢？我们以后再慢慢分析！]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASSM三级位图结构与高水位的探究（上）]]></title>
    <url>%2F2015%2F09%2F25%2Foracle%2Farchitecture%2FASSM1%2F</url>
    <content type="text"><![CDATA[#ASSM三级位图结构与高水位的探究 三级位图 Oracle9i在本地表空管理(LMT)的基础上，对段空间管理也引入了位图管理（Segment Space Management Auto）来取代原来的freelist管理方式（Segment Space Management Manual）。但是默认system和undo表空间仍然是MSSM的管理方式，本文主要探究ASSM管理方式下，段的三级位图结构和高水位推进的关系 先来看ASSM管理方式下的三级位图结构图： 注：此图来源于网络一个段被创建之后，段头其实是一个L3块，在我的试验中，一个1M固定区大小，block为8K的表空间，创建的第一个段第0个区，前两个块是L1（128,129号块），第三个是L2（130号块），第四个是L3（131号块），前128个块是数据文件头，本文不讨论。当数据被插入的时候，oracle根据连接进来的session，做hash运算，随机选择一个L3（如果有多个的话），再随机选择一个L2，接下来在该L2下随机选择一个L1，再从L1中管理的block里面随机选择一个块将数据插入，不同的session经过hash之后，最后落到block时已经是很分散的了，不会产生很多和会话同时往一个block中插数据申请独占buffer pin，而造成大量buffer busy waits的情况，这就是ASSM号称支持大并发插入的原理所在，但是事实上真的如此么？我们来一探究竟！ 实验环境 OS:REDHAT6.5 X64DB VERSION:11.2.0.4 首先，创建一个1M区大小的表空间，并在上面创建一张表，此表创建了4个空间很大的字段，目的是要一行占满一个block，便于观察结果 SQL&gt; select file#,NAME,BYTES/1024/1204 from v$datafile; FILE# NAME BYTES/1024/1204---------- -------------------------------------------------------------------------------- --------------- 1 +DATA/min/datafile/system.256.854775095 637.873754 2 +DATA/min/datafile/sysaux.257.854775097 484.784053 3 +DATA/min/datafile/undotbs1.258.854775097 187.109635 4 +DATA/min/datafile/users.259.854775097 103.122924SQL&gt; create tablespace lp datafile '+DATA/min/datafile/lp.dbf' size 2048M uniform size 1m;Tablespace created.SQL&gt; select file#,NAME,BYTES/1024/1204 from v$datafile; FILE# NAME BYTES/1024/1204---------- -------------------------------------------------------------------------------- --------------- 1 +DATA/min/datafile/system.256.854775095 637.873754 2 +DATA/min/datafile/sysaux.257.854775097 484.784053 3 +DATA/min/datafile/undotbs1.258.854775097 187.109635 4 +DATA/min/datafile/users.259.854775097 103.122924 5 +DATA/min/datafile/lp.dbf 1741.8206SQL&gt; create table lp (id number,des1 char(2000),des2 char(2000),des3 char(2000),des4 char(500)) tablespace lp;Table created. 观察新建的表所占区 SQL&gt; col SEGMENT_NAME for a30SQL&gt; col des1 for a1SQL&gt; col des2 for a1SQL&gt; col des3 for a1SQL&gt; col des4 for a1SQL&gt; set line 200SQL&gt; select SEGMENT_NAME,EXTENT_ID,FILE_ID,BLOCK_ID, BLOCKS from dba_extents where segment_name='LP';SEGMENT_NAME EXTENT_ID FILE_ID BLOCK_ID BLOCKS------------------------------ ---------- ---------- ---------- ----------LP 0 5 128 128 此表是5号文件，拥有1个区，block从128号开始，接下来我们插入一条数据，并dump出段头进行观察 SQL&gt; insert into lp values(1,'a','a','a','a');1 row created.SQL&gt; commit;Commit complete.SQL&gt; select segment_name ,HEADER_FILE,HEADER_BLOCK from dba_segments where segment_name='LP';SEGMENT_NAME HEADER_FILE HEADER_BLOCK------------------------------ ----------- ------------LP 5 131SQL&gt; alter system checkpoint;System altered. LP的段头是5号文件，131号块，进行dump SQL&gt; alter system dump datafile 5 block 131;SQL&gt; col value for a65SQL&gt; select * from v$diag_info; INST_ID NAME VALUE---------- -------------------------------------------------------------------------------- ----------------------------------------------------------------- 1 Diag Enabled TRUE 1 ADR Base /u01/app/oracle 1 ADR Home /u01/app/oracle/diag/rdbms/min/min 1 Diag Trace /u01/app/oracle/diag/rdbms/min/min/trace 1 Diag Alert /u01/app/oracle/diag/rdbms/min/min/alert 1 Diag Incident /u01/app/oracle/diag/rdbms/min/min/incident 1 Diag Cdump /u01/app/oracle/diag/rdbms/min/min/cdump 1 Health Monitor /u01/app/oracle/diag/rdbms/min/min/hm 1 Default Trace File /u01/app/oracle/diag/rdbms/min/min/trace/min_ora_2835.trc 1 Active Problem Count 0 1 Active Incident Count 011 rows selected. 观察trc文件min_ora_2835.trc Block dump from disk:buffer tsn: 8 rdba: 0x01400083 (5/131)scn: 0x0000.00140d51 seq: 0x01 flg: 0x04 tail: 0x0d512301frmt: 0x02 chkval: 0xfd8a type: 0x23=PAGETABLE SEGMENT HEADERHex dump of block: st=0, typ_found=1Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 1 #blocks: 128 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x014000c0 ext#: 0 blk#: 64 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 60 mapblk 0x00000000 offset: 0 Unlocked -------------------------------------------------------- Low HighWater Mark : Highwater:: 0x01400084 ext#: 0 blk#: 4 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 0 mapblk 0x00000000 offset: 0 Level 1 BMB for High HWM block: 0x01400080 Level 1 BMB for Low HWM block: 0x01400080 -------------------------------------------------------- Segment Type: 1 nl2: 1 blksz: 8192 fbsz: 0 L2 Array start offset: 0x00001434 First Level 3 BMB: 0x00000000 L2 Hint for inserts: 0x01400082 Last Level 1 BMB: 0x01400081 Last Level II BMB: 0x01400082 Last Level III BMB: 0x00000000 Map Header:: next 0x00000000 #extents: 1 obj#: 87596 flag: 0x10000000 Inc # 0 Extent Map ----------------------------------------------------------------- 0x01400080 length: 128 Auxillary Map -------------------------------------------------------- Extent 0 : L1 dba: 0x01400080 Data dba: 0x01400084 --------------------------------------------------------Second Level Bitmap block DBAs -------------------------------------------------------- DBA 1: 0x01400082End dump data blocks tsn: 8 file#: 5 minblk 131 maxblk 131 很容易发现这是一个PAGETABLE SEGMENT HEADER块，Extent Map中只有一个区，另外在尾部有一个指向二级位图块的地址0x01400082，这是数据块地址的二进制用十六进制来表示，我们来将其转化成直观一点的信息 SQL&gt; select dbms_utility.data_block_address_file(to_number('01400082', 'xxxxxxxx')) file#, 2 dbms_utility.data_block_address_block(to_number('01400082', 'xxxxxxxx')) block# 3 from dual; FILE# BLOCK#---------- ---------- 5 130 依样将5号文件130号块的内容dump出来 Block dump from disk:buffer tsn: 8 rdba: 0x01400082 (5/130)scn: 0x0000.00140a45 seq: 0x02 flg: 0x04 tail: 0x0a452102frmt: 0x02 chkval: 0xd119 type: 0x21=SECOND LEVEL BITMAP BLOCKHex dump of block: st=0, typ_found=1Dump of Second Level Bitmap Block number: 2 nfree: 2 ffree: 0 pdba: 0x01400083 Inc #: 0 Objd: 87596 opcode:0 xid: L1 Ranges : -------------------------------------------------------- 0x01400080 Free: 5 Inst: 1 0x01400081 Free: 5 Inst: 1 --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 130 maxblk 130 可以发现这是一个二级位图块，并从其中找到了2个L1块的地址，我们来看第一个L1 Block dump from disk:buffer tsn: 8 rdba: 0x01400080 (5/128)scn: 0x0000.00140d51 seq: 0x03 flg: 0x04 tail: 0x0d512003frmt: 0x02 chkval: 0xe697 type: 0x20=FIRST LEVEL BITMAP BLOCKHex dump of block: st=0, typ_found=1DBA Ranges : -------------------------------------------------------- 0x01400080 Length: 64 Offset: 0 0:Metadata 1:Metadata 2:Metadata 3:Metadata 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:75-100% free 17:75-100% free 18:75-100% free 19:75-100% free 20:75-100% free 21:75-100% free 22:75-100% free 23:75-100% free 24:75-100% free 25:75-100% free 26:75-100% free 27:75-100% free 28:75-100% free 29:75-100% free 30:75-100% free 31:0-25% free 32:unformatted 33:unformatted 34:unformatted 35:unformatted 36:unformatted 37:unformatted 38:unformatted 39:unformatted 40:unformatted 41:unformatted 42:unformatted 43:unformatted 44:unformatted 45:unformatted 46:unformatted 47:unformatted 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 128 maxblk 128 无疑这是一个L1块，里面挂了64个数据块，因为我之前插入了一行数据，oracle已经格式化了一部分，并向其中一个块插入了数据，但是没达到我们的效果，被插入的块还显示0-25%的空闲，我们要的是full的状态，说明我们构造的数据不够大，没关系，我们修改一下pctfree就可以了，另外我们可以发现这个区是1M，有2个L1，每个L1里有64个数据块，接下来修改pctfree SQL&gt; alter table lp pctfree 24;Table altered.SQL&gt; select TABLE_NAME,PCT_FREE from dba_tables where table_name='LP';TABLE_NAME PCT_FREE------------------------------ ----------LP 24SQL&gt; insert into lp values(2,'a','a','a','a');1 row created.SQL&gt; commit;Commit complete.--手动触发检查点将内存中的块刷新到磁盘，本文每次dump之前都会做这个操作，以保证磁盘和内存的内容一致SQL&gt; alter system checkpoint;System altered. 我们再看128号块 DBA Ranges : -------------------------------------------------------- 0x01400080 Length: 64 Offset: 0 0:Metadata 1:Metadata 2:Metadata 3:Metadata 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:75-100% free 17:75-100% free 18:75-100% free 19:75-100% free 20:75-100% free 21:75-100% free 22:75-100% free 23:75-100% free 24:75-100% free 25:75-100% free 26:75-100% free 27:75-100% free 28:75-100% free 29:75-100% free 30:75-100% free 31:0-25% free 32:75-100% free 33:75-100% free 34:75-100% free &lt;font color=&apos;red&apos;&gt;35:FULL&lt;/font&gt; 36:75-100% free 37:75-100% free 38:75-100% free 39:75-100% free 40:75-100% free 41:75-100% free 42:75-100% free 43:75-100% free 44:75-100% free 45:75-100% free 46:75-100% free 47:75-100% free 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 128 maxblk 128 已经是我们想的结果了，到这里我们再来看一下另外一个L1吧，dump129号块 DBA Ranges : -------------------------------------------------------- 0x014000c0 Length: 64 Offset: 0 0:unformatted 1:unformatted 2:unformatted 3:unformatted 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:unformatted 17:unformatted 18:unformatted 19:unformatted 20:unformatted 21:unformatted 22:unformatted 23:unformatted 24:unformatted 25:unformatted 26:unformatted 27:unformatted 28:unformatted 29:unformatted 30:unformatted 31:unformatted 32:unformatted 33:unformatted 34:unformatted 35:unformatted 36:unformatted 37:unformatted 38:unformatted 39:unformatted 40:unformatted 41:unformatted 42:unformatted 43:unformatted 44:unformatted 45:unformatted 46:unformatted 47:unformatted 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 129 maxblk 129 全是未格式化的块，试一试并发插入，这里不模拟真正的并发了，只是开不同的session来进行插入 SQL&gt; insert into lp values(3,'a','a','a','a');1 row created.SQL&gt; insert into lp values(4,'a','a','a','a');1 row created.SQL&gt; insert into lp values(5,'a','a','a','a');1 row created.SQL&gt; insert into lp values(6,'a','a','a','a');1 row created.SQL&gt; insert into lp values(7,'a','a','a','a');1 row created.--单独session5条SQL&gt; select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp;DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)------------------------------------ ------------------------------------ 5 158 5 159 5 163 5 167 5 171 5 172 5 174 5 175 5 179 5 183 5 187 5 19112 rows selected. 一个单独的session里插入了5条，另外5个单独的session里各插一条，发现规律了么，插入的块只在132和192之间，我们分别看看两个L1 SQL&gt; alter system checkpoint;System altered. DBA Ranges : -------------------------------------------------------- 0x01400080 Length: 64 Offset: 0 0:Metadata 1:Metadata 2:Metadata 3:Metadata 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:75-100% free 17:75-100% free 18:75-100% free 19:75-100% free 20:75-100% free 21:75-100% free 22:75-100% free 23:75-100% free 24:75-100% free 25:75-100% free 26:75-100% free 27:75-100% free 28:75-100% free 29:75-100% free 30:FULL 31:0-25% free 32:75-100% free 33:75-100% free 34:75-100% free 35:FULL 36:75-100% free 37:75-100% free 38:75-100% free 39:FULL 40:75-100% free 41:75-100% free 42:75-100% free 43:FULL 44:FULL 45:75-100% free 46:FULL 47:FULL 48:75-100% free 49:75-100% free 50:75-100% free 51:FULL 52:75-100% free 53:75-100% free 54:75-100% free 55:FULL 56:75-100% free 57:75-100% free 58:75-100% free 59:FULL 60:75-100% free 61:75-100% free 62:75-100% free 63:FULL --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 128 maxblk 128********************************************************************看一下第二个L1DBA Ranges : -------------------------------------------------------- 0x014000c0 Length: 64 Offset: 0 0:unformatted 1:unformatted 2:unformatted 3:unformatted 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:unformatted 17:unformatted 18:unformatted 19:unformatted 20:unformatted 21:unformatted 22:unformatted 23:unformatted 24:unformatted 25:unformatted 26:unformatted 27:unformatted 28:unformatted 29:unformatted 30:unformatted 31:unformatted 32:unformatted 33:unformatted 34:unformatted 35:unformatted 36:unformatted 37:unformatted 38:unformatted 39:unformatted 40:unformatted 41:unformatted 42:unformatted 43:unformatted 44:unformatted 45:unformatted 46:unformatted 47:unformatted 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 129 maxblk 129 这说明只在第一个L1里面随机，那为什么L2下挂了2个L1，我插入了10条却没有一条随机到第二个L1块呢？答案是高水位，这是vage大师已经论证过的了，偶在这里仅为见证一下~~，好了，还记得L3里的高水位信息么？ Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 101 #blocks: 12928 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x014000c0 ext#: 0 blk#: 64 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 60 mapblk 0x00000000 offset: 0 Highwater:: 0x014000c0是哪个块呢？ SQL&gt; select dbms_utility.data_block_address_file(to_number('014000c0', 'xxxxxxxx')) file#, 2 dbms_utility.data_block_address_block(to_number('014000c0', 'xxxxxxxx')) block# 3 from dual; FILE# BLOCK#---------- ---------- 5 192 这是第二个L1管理的第一个块，可见数据的插入只在高水位之下进行（直接路径插入除外），此时的状态如下： 那么L1里面只会有64个块么？高水位永远都会指向L1的最后一个块么？我们继续剖析！首先给LP表多分配一些区 SQL&gt; alter table lp allocate extent(size 100m);Table altered.SQL&gt; select SEGMENT_NAME,EXTENT_ID,FILE_ID,BLOCK_ID, BLOCKS from dba_extents where segment_name='LP';SEGMENT_NAME EXTENT_ID FILE_ID BLOCK_ID BLOCKS------------------------------ ---------- ---------- ---------- ----------LP 0 5 128 128LP 1 5 256 128LP 2 5 384 128LP 3 5 512 128LP 4 5 640 128LP 5 5 768 128LP 6 5 896 128LP 7 5 1024 128LP 8 5 1152 128LP 9 5 1280 128LP 10 5 1408 128LP 11 5 1536 128LP 12 5 1664 128LP 13 5 1792 128LP 14 5 1920 128LP 15 5 2048 128LP 16 5 2176 128LP 17 5 2304 128LP 18 5 2432 128LP 19 5 2560 128LP 20 5 2688 128LP 21 5 2816 128LP 22 5 2944 128LP 23 5 3072 128LP 24 5 3200 128LP 25 5 3328 128LP 26 5 3456 128LP 27 5 3584 128LP 28 5 3712 128LP 29 5 3840 128LP 30 5 3968 128LP 31 5 4096 128LP 32 5 4224 128LP 33 5 4352 128LP 34 5 4480 128LP 35 5 4608 128LP 36 5 4736 128LP 37 5 4864 128LP 38 5 4992 128LP 39 5 5120 128LP 40 5 5248 128LP 41 5 5376 128LP 42 5 5504 128LP 43 5 5632 128LP 44 5 5760 128LP 45 5 5888 128LP 46 5 6016 128LP 47 5 6144 128LP 48 5 6272 128LP 49 5 6400 128LP 50 5 6528 128LP 51 5 6656 128LP 52 5 6784 128LP 53 5 6912 128LP 54 5 7040 128LP 55 5 7168 128LP 56 5 7296 128LP 57 5 7424 128LP 58 5 7552 128LP 59 5 7680 128LP 60 5 7808 128LP 61 5 7936 128LP 62 5 8064 128LP 63 5 8192 128LP 64 5 8320 128LP 65 5 8448 128LP 66 5 8576 128LP 67 5 8704 128LP 68 5 8832 128LP 69 5 8960 128LP 70 5 9088 128LP 71 5 9216 128LP 72 5 9344 128LP 73 5 9472 128LP 74 5 9600 128LP 75 5 9728 128LP 76 5 9856 128LP 77 5 9984 128LP 78 5 10112 128LP 79 5 10240 128LP 80 5 10368 128LP 81 5 10496 128LP 82 5 10624 128LP 83 5 10752 128LP 84 5 10880 128LP 85 5 11008 128LP 86 5 11136 128LP 87 5 11264 128LP 88 5 11392 128LP 89 5 11520 128LP 90 5 11648 128LP 91 5 11776 128LP 92 5 11904 128LP 93 5 12032 128LP 94 5 12160 128LP 95 5 12288 128LP 96 5 12416 128LP 97 5 12544 128LP 98 5 12672 128LP 99 5 12800 128LP 100 5 12928 128101 rows selected. 我分配了100个区，加上原来的一共101个，现在我们看看L3段头里面的内容 Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 101 #blocks: 12928 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x014000c0 ext#: 0 blk#: 64 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 60 mapblk 0x00000000 offset: 0 Extent Map ----------------------------------------------------------------- 0x01400080 length: 128 0x01400100 length: 128 0x01400180 length: 128 0x01400200 length: 128 0x01400280 length: 128 0x01400300 length: 128 0x01400380 length: 128 0x01400400 length: 128 0x01400480 length: 128 0x01400500 length: 128 0x01400580 length: 128 0x01400600 length: 128 0x01400680 length: 128 0x01400700 length: 128 0x01400780 length: 128 0x01400800 length: 128 0x01400880 length: 128 0x01400900 length: 128 0x01400980 length: 128 0x01400a00 length: 128 0x01400a80 length: 128 0x01400b00 length: 128 0x01400b80 length: 128 0x01400c00 length: 128 0x01400c80 length: 128 0x01400d00 length: 128 0x01400d80 length: 128 0x01400e00 length: 128 0x01400e80 length: 128 0x01400f00 length: 128 0x01400f80 length: 128 0x01401000 length: 128 0x01401080 length: 128 0x01401100 length: 128 0x01401180 length: 128 0x01401200 length: 128 0x01401280 length: 128 0x01401300 length: 128 0x01401380 length: 128 0x01401400 length: 128 0x01401480 length: 128 0x01401500 length: 128 0x01401580 length: 128 0x01401600 length: 128 0x01401680 length: 128 0x01401700 length: 128 0x01401780 length: 128 0x01401800 length: 128 0x01401880 length: 128 0x01401900 length: 128 0x01401980 length: 128 0x01401a00 length: 128 0x01401a80 length: 128 0x01401b00 length: 128 0x01401b80 length: 128 0x01401c00 length: 128 0x01401c80 length: 128 0x01401d00 length: 128 0x01401d80 length: 128 0x01401e00 length: 128 0x01401e80 length: 128 0x01401f00 length: 128 0x01401f80 length: 128 0x01402000 length: 128 0x01402080 length: 128 0x01402100 length: 128 0x01402180 length: 128 0x01402200 length: 128 0x01402280 length: 128 0x01402300 length: 128 0x01402380 length: 128 0x01402400 length: 128 0x01402480 length: 128 0x01402500 length: 128 0x01402580 length: 128 0x01402600 length: 128 0x01402680 length: 128 0x01402700 length: 128 0x01402780 length: 128 0x01402800 length: 128 0x01402880 length: 128 0x01402900 length: 128 0x01402980 length: 128 0x01402a00 length: 128 0x01402a80 length: 128 0x01402b00 length: 128 0x01402b80 length: 128 0x01402c00 length: 128 0x01402c80 length: 128 0x01402d00 length: 128 0x01402d80 length: 128 0x01402e00 length: 128 0x01402e80 length: 128 0x01402f00 length: 128 0x01402f80 length: 128 0x01403000 length: 128 0x01403080 length: 128 0x01403100 length: 128 0x01403180 length: 128 0x01403200 length: 128 0x01403280 length: 128 Auxillary Map -------------------------------------------------------- Extent 0 : L1 dba: 0x01400080 Data dba: 0x01400084 Extent 1 : L1 dba: 0x01400100 Data dba: 0x01400102 Extent 2 : L1 dba: 0x01400180 Data dba: 0x01400182 Extent 3 : L1 dba: 0x01400200 Data dba: 0x01400202 Extent 4 : L1 dba: 0x01400280 Data dba: 0x01400282 Extent 5 : L1 dba: 0x01400300 Data dba: 0x01400302 Extent 6 : L1 dba: 0x01400380 Data dba: 0x01400382 Extent 7 : L1 dba: 0x01400400 Data dba: 0x01400402 Extent 8 : L1 dba: 0x01400480 Data dba: 0x01400482 Extent 9 : L1 dba: 0x01400500 Data dba: 0x01400502 Extent 10 : L1 dba: 0x01400580 Data dba: 0x01400582 Extent 11 : L1 dba: 0x01400600 Data dba: 0x01400602 Extent 12 : L1 dba: 0x01400680 Data dba: 0x01400682 Extent 13 : L1 dba: 0x01400700 Data dba: 0x01400702 Extent 14 : L1 dba: 0x01400780 Data dba: 0x01400782 Extent 15 : L1 dba: 0x01400800 Data dba: 0x01400802 Extent 16 : L1 dba: 0x01400880 Data dba: 0x01400882 Extent 17 : L1 dba: 0x01400900 Data dba: 0x01400902 Extent 18 : L1 dba: 0x01400980 Data dba: 0x01400982 Extent 19 : L1 dba: 0x01400a00 Data dba: 0x01400a02 Extent 20 : L1 dba: 0x01400a80 Data dba: 0x01400a82 Extent 21 : L1 dba: 0x01400b00 Data dba: 0x01400b02 Extent 22 : L1 dba: 0x01400b80 Data dba: 0x01400b82 Extent 23 : L1 dba: 0x01400c00 Data dba: 0x01400c02 Extent 24 : L1 dba: 0x01400c80 Data dba: 0x01400c82 Extent 25 : L1 dba: 0x01400d00 Data dba: 0x01400d02 Extent 26 : L1 dba: 0x01400d80 Data dba: 0x01400d82 Extent 27 : L1 dba: 0x01400e00 Data dba: 0x01400e02 Extent 28 : L1 dba: 0x01400e80 Data dba: 0x01400e82 Extent 29 : L1 dba: 0x01400f00 Data dba: 0x01400f02 Extent 30 : L1 dba: 0x01400f80 Data dba: 0x01400f82 Extent 31 : L1 dba: 0x01401000 Data dba: 0x01401002 Extent 32 : L1 dba: 0x01401080 Data dba: 0x01401082 Extent 33 : L1 dba: 0x01401100 Data dba: 0x01401102 Extent 34 : L1 dba: 0x01401180 Data dba: 0x01401182 Extent 35 : L1 dba: 0x01401200 Data dba: 0x01401202 Extent 36 : L1 dba: 0x01401280 Data dba: 0x01401282 Extent 37 : L1 dba: 0x01401300 Data dba: 0x01401302 Extent 38 : L1 dba: 0x01401380 Data dba: 0x01401382 Extent 39 : L1 dba: 0x01401400 Data dba: 0x01401402 Extent 40 : L1 dba: 0x01401480 Data dba: 0x01401482 Extent 41 : L1 dba: 0x01401500 Data dba: 0x01401502 Extent 42 : L1 dba: 0x01401580 Data dba: 0x01401582 Extent 43 : L1 dba: 0x01401600 Data dba: 0x01401602 Extent 44 : L1 dba: 0x01401680 Data dba: 0x01401682 Extent 45 : L1 dba: 0x01401700 Data dba: 0x01401702 Extent 46 : L1 dba: 0x01401780 Data dba: 0x01401782 Extent 47 : L1 dba: 0x01401800 Data dba: 0x01401802 Extent 48 : L1 dba: 0x01401880 Data dba: 0x01401882 Extent 49 : L1 dba: 0x01401900 Data dba: 0x01401902 Extent 50 : L1 dba: 0x01401980 Data dba: 0x01401982 Extent 51 : L1 dba: 0x01401a00 Data dba: 0x01401a02 Extent 52 : L1 dba: 0x01401a80 Data dba: 0x01401a82 Extent 53 : L1 dba: 0x01401b00 Data dba: 0x01401b02 Extent 54 : L1 dba: 0x01401b80 Data dba: 0x01401b82 Extent 55 : L1 dba: 0x01401c00 Data dba: 0x01401c02 Extent 56 : L1 dba: 0x01401c80 Data dba: 0x01401c82 Extent 57 : L1 dba: 0x01401d00 Data dba: 0x01401d02 Extent 58 : L1 dba: 0x01401d80 Data dba: 0x01401d82 Extent 59 : L1 dba: 0x01401e00 Data dba: 0x01401e02 Extent 60 : L1 dba: 0x01401e80 Data dba: 0x01401e82 Extent 61 : L1 dba: 0x01401f00 Data dba: 0x01401f02 Extent 62 : L1 dba: 0x01401f80 Data dba: 0x01401f82 Extent 63 : L1 dba: 0x01402000 Data dba: 0x01402001 Extent 64 : L1 dba: 0x01402000 Data dba: 0x01402080 Extent 65 : L1 dba: 0x01402100 Data dba: 0x01402101 Extent 66 : L1 dba: 0x01402100 Data dba: 0x01402180 Extent 67 : L1 dba: 0x01402200 Data dba: 0x01402201 Extent 68 : L1 dba: 0x01402200 Data dba: 0x01402280 Extent 69 : L1 dba: 0x01402300 Data dba: 0x01402301 Extent 70 : L1 dba: 0x01402300 Data dba: 0x01402380 Extent 71 : L1 dba: 0x01402400 Data dba: 0x01402401 Extent 72 : L1 dba: 0x01402400 Data dba: 0x01402480 Extent 73 : L1 dba: 0x01402500 Data dba: 0x01402501 Extent 74 : L1 dba: 0x01402500 Data dba: 0x01402580 Extent 75 : L1 dba: 0x01402600 Data dba: 0x01402601 Extent 76 : L1 dba: 0x01402600 Data dba: 0x01402680 Extent 77 : L1 dba: 0x01402700 Data dba: 0x01402701 Extent 78 : L1 dba: 0x01402700 Data dba: 0x01402780 Extent 79 : L1 dba: 0x01402800 Data dba: 0x01402801 Extent 80 : L1 dba: 0x01402800 Data dba: 0x01402880 Extent 81 : L1 dba: 0x01402900 Data dba: 0x01402901 Extent 82 : L1 dba: 0x01402900 Data dba: 0x01402980 Extent 83 : L1 dba: 0x01402a00 Data dba: 0x01402a01 Extent 84 : L1 dba: 0x01402a00 Data dba: 0x01402a80 Extent 85 : L1 dba: 0x01402b00 Data dba: 0x01402b01 Extent 86 : L1 dba: 0x01402b00 Data dba: 0x01402b80 Extent 87 : L1 dba: 0x01402c00 Data dba: 0x01402c01 Extent 88 : L1 dba: 0x01402c00 Data dba: 0x01402c80 Extent 89 : L1 dba: 0x01402d00 Data dba: 0x01402d01 Extent 90 : L1 dba: 0x01402d00 Data dba: 0x01402d80 Extent 91 : L1 dba: 0x01402e00 Data dba: 0x01402e01 Extent 92 : L1 dba: 0x01402e00 Data dba: 0x01402e80 Extent 93 : L1 dba: 0x01402f00 Data dba: 0x01402f01 Extent 94 : L1 dba: 0x01402f00 Data dba: 0x01402f80 Extent 95 : L1 dba: 0x01403000 Data dba: 0x01403001 Extent 96 : L1 dba: 0x01403000 Data dba: 0x01403080 Extent 97 : L1 dba: 0x01403100 Data dba: 0x01403101 Extent 98 : L1 dba: 0x01403100 Data dba: 0x01403180 Extent 99 : L1 dba: 0x01403200 Data dba: 0x01403201 Extent 100 : L1 dba: 0x01403200 Data dba: 0x01403280 -------------------------------------------------------- Second Level Bitmap block DBAs -------------------------------------------------------- DBA 1: 0x01400082End dump data blocks tsn: 8 file#: 5 minblk 131 maxblk 131 这里我们主要看Auxillary Map，里面记录了每个区所属的L1，不难发现从第64个区开始，64、65两个区的L1相同，这说明什么，说明L1下面挂了整整两个区的数据块，验证一下，将0x01402000块dump出来之后的内容： 01402000 十进制 》20979712 SQL&gt; select dbms_utility.data_block_address_file(20979712) Rfile#,dbms_utility.data_block_address_block(20979712) "Block#" from dual; RFILE# Block#---------- ---------- 5 8192 DBA Ranges : -------------------------------------------------------- 0x01402000 Length: 128 Offset: 0 0x01402080 Length: 128 Offset: 128 0:Metadata 1:unformatted 2:unformatted 3:unformatted 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:unformatted 17:unformatted 18:unformatted 19:unformatted 20:unformatted 21:unformatted 22:unformatted 23:unformatted 24:unformatted 25:unformatted 26:unformatted 27:unformatted 28:unformatted 29:unformatted 30:unformatted 31:unformatted 32:unformatted 33:unformatted 34:unformatted 35:unformatted 36:unformatted 37:unformatted 38:unformatted 39:unformatted 40:unformatted 41:unformatted 42:unformatted 43:unformatted 44:unformatted 45:unformatted 46:unformatted 47:unformatted 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted 64:unformatted 65:unformatted 66:unformatted 67:unformatted 68:unformatted 69:unformatted 70:unformatted 71:unformatted 72:unformatted 73:unformatted 74:unformatted 75:unformatted 76:unformatted 77:unformatted 78:unformatted 79:unformatted 80:unformatted 81:unformatted 82:unformatted 83:unformatted 84:unformatted 85:unformatted 86:unformatted 87:unformatted 88:unformatted 89:unformatted 90:unformatted 91:unformatted 92:unformatted 93:unformatted 94:unformatted 95:unformatted 96:unformatted 97:unformatted 98:unformatted 99:unformatted 100:unformatted 101:unformatted 102:unformatted 103:unformatted 104:unformatted 105:unformatted 106:unformatted 107:unformatted 108:unformatted 109:unformatted 110:unformatted 111:unformatted 112:unformatted 113:unformatted 114:unformatted 115:unformatted 116:unformatted 117:unformatted 118:unformatted 119:unformatted 120:unformatted 121:unformatted 122:unformatted 123:unformatted 124:unformatted 125:unformatted 126:unformatted 127:unformatted 128:unformatted 129:unformatted 130:unformatted 131:unformatted 132:unformatted 133:unformatted 134:unformatted 135:unformatted 136:unformatted 137:unformatted 138:unformatted 139:unformatted 140:unformatted 141:unformatted 142:unformatted 143:unformatted 144:unformatted 145:unformatted 146:unformatted 147:unformatted 148:unformatted 149:unformatted 150:unformatted 151:unformatted 152:unformatted 153:unformatted 154:unformatted 155:unformatted 156:unformatted 157:unformatted 158:unformatted 159:unformatted 160:unformatted 161:unformatted 162:unformatted 163:unformatted 164:unformatted 165:unformatted 166:unformatted 167:unformatted 168:unformatted 169:unformatted 170:unformatted 171:unformatted 172:unformatted 173:unformatted 174:unformatted 175:unformatted 176:unformatted 177:unformatted 178:unformatted 179:unformatted 180:unformatted 181:unformatted 182:unformatted 183:unformatted 184:unformatted 185:unformatted 186:unformatted 187:unformatted 188:unformatted 189:unformatted 190:unformatted 191:unformatted 192:unformatted 193:unformatted 194:unformatted 195:unformatted 196:unformatted 197:unformatted 198:unformatted 199:unformatted 200:unformatted 201:unformatted 202:unformatted 203:unformatted 204:unformatted 205:unformatted 206:unformatted 207:unformatted 208:unformatted 209:unformatted 210:unformatted 211:unformatted 212:unformatted 213:unformatted 214:unformatted 215:unformatted 216:unformatted 217:unformatted 218:unformatted 219:unformatted 220:unformatted 221:unformatted 222:unformatted 223:unformatted 224:unformatted 225:unformatted 226:unformatted 227:unformatted 228:unformatted 229:unformatted 230:unformatted 231:unformatted 232:unformatted 233:unformatted 234:unformatted 235:unformatted 236:unformatted 237:unformatted 238:unformatted 239:unformatted 240:unformatted 241:unformatted 242:unformatted 243:unformatted 244:unformatted 245:unformatted 246:unformatted 247:unformatted 248:unformatted 249:unformatted 250:unformatted 251:unformatted 252:unformatted 253:unformatted 254:unformatted 255:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 8192 maxblk 8192 256个块，2M 2个区，可见L1中块的数量会随着段大小的改变而做调整的，可以增大到1024个甚至更多，我在这里不去再做验证，将重点放在高水位上，根据我们之前观察到的现象，高水位在第二个L1的地一个块，也可说第一个L1的末端，那么现在的L1里有256个块，高水位是不是也会推进到这个L1的末端呢？很容易进行验证，将数据插满到这个L1的前几个块再去观察段头高水位的变化就行了，那么插多少条呢？再来计算一下，当前的L1是8192号块，前面一共63个区，每个区里面两个L1，加上第一个区里面的一个L2和L3，我们需要插满8192-63*2-2=8064 declarei number;beginfor i in 1..8064 loopinsert into lp values(i,'a','a','a','a');end loop;end;/ 观察62号区的第二个L1，第一个L1的地址是0x01401f80，那么第二个就是01401f81，5号文件8065号块，dump出来的结果 DBA Ranges : -------------------------------------------------------- 0x01401fc0 Length: 64 Offset: 0 0:FULL 1:FULL 2:FULL 3:FULL 4:FULL 5:FULL 6:FULL 7:FULL 8:FULL 9:FULL 10:FULL 11:FULL 12:FULL 13:FULL 14:FULL 15:FULL 16:FULL 17:FULL 18:FULL 19:FULL 20:FULL 21:FULL 22:FULL 23:FULL 24:FULL 25:FULL 26:FULL 27:FULL 28:FULL 29:FULL 30:FULL 31:FULL 32:FULL 33:FULL 34:FULL 35:FULL 36:FULL 37:FULL 38:FULL 39:FULL 40:FULL 41:FULL 42:FULL 43:FULL 44:FULL 45:FULL 46:FULL 47:FULL 48:FULL 49:FULL 50:FULL 51:FULL 52:FULL 53:FULL 54:FULL 55:FULL 56:FULL 57:FULL 58:FULL 59:FULL 60:FULL 61:FULL 62:FULL 63:FULL --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 8065 maxblk 8065 居然全满了？再看8192号L1呢 DBA Ranges : -------------------------------------------------------- 0x01402000 Length: 128 Offset: 0 0x01402080 Length: 128 Offset: 128 0:Metadata 1:FULL 2:FULL 3:FULL 4:FULL 5:FULL 6:FULL 7:FULL 8:FULL 9:FULL 10:FULL 11:FULL 12:FULL 13:FULL 14:FULL 15:FULL 16:FULL 17:FULL 18:FULL 19:FULL 20:FULL 21:FULL 22:FULL 23:FULL 24:FULL 25:FULL 26:FULL 27:FULL 28:FULL 29:FULL 30:FULL 31:FULL 32:FULL 33:FULL 34:FULL 35:FULL 36:FULL 37:FULL 38:FULL 39:FULL 40:FULL 41:FULL 42:FULL 43:FULL 44:FULL 45:FULL 46:FULL 47:FULL 48:FULL 49:FULL 50:FULL 51:FULL 52:FULL 53:FULL 54:FULL 55:FULL 56:FULL 57:FULL 58:FULL 59:FULL 60:FULL 61:FULL 62:FULL 63:FULL 64:FULL 65:FULL 66:FULL 67:FULL 68:FULL 69:FULL 70:FULL 71:FULL 72:FULL 73:FULL 74:FULL 75:FULL 76:FULL 77:FULL 78:FULL 79:FULL 80:FULL 81:FULL 82:FULL 83:FULL 84:FULL 85:FULL 86:FULL 87:FULL 88:FULL 89:FULL 90:FULL 91:FULL 92:FULL 93:FULL 94:FULL 95:FULL 96:FULL 97:FULL 98:FULL 99:FULL 100:FULL 101:FULL 102:FULL 103:FULL 104:FULL 105:FULL 106:FULL 107:FULL 108:FULL 109:FULL 110:FULL 111:FULL 112:FULL 113:FULL 114:FULL 115:FULL 116:FULL 117:FULL 118:FULL 119:FULL 120:FULL 121:FULL 122:FULL 123:FULL 124:FULL 125:FULL 126:FULL 127:FULL 128:unformatted 129:unformatted 130:unformatted 131:unformatted 132:unformatted 133:unformatted 134:unformatted 135:unformatted 136:unformatted 137:unformatted 138:unformatted 139:unformatted 140:unformatted 141:unformatted 142:unformatted 143:unformatted 144:75-100% free 145:75-100% free 146:75-100% free 147:75-100% free 148:75-100% free 149:75-100% free 150:75-100% free 151:75-100% free 152:75-100% free 153:75-100% free 154:75-100% free 155:FULL 156:75-100% free 157:75-100% free 158:75-100% free 159:75-100% free 160:75-100% free 161:75-100% free 162:75-100% free 163:FULL 164:75-100% free 165:75-100% free 166:75-100% free 167:75-100% free 168:75-100% free 169:75-100% free 170:75-100% free 171:75-100% free 172:75-100% free 173:75-100% free 174:75-100% free 175:75-100% free 176:unformatted 177:unformatted 178:unformatted 179:unformatted 180:unformatted 181:unformatted 182:unformatted 183:unformatted 184:unformatted 185:unformatted 186:unformatted 187:unformatted 188:unformatted 189:unformatted 190:unformatted 191:unformatted 192:unformatted 193:unformatted 194:unformatted 195:unformatted 196:unformatted 197:unformatted 198:unformatted 199:unformatted 200:unformatted 201:unformatted 202:unformatted 203:unformatted 204:unformatted 205:unformatted 206:unformatted 207:unformatted 208:unformatted 209:unformatted 210:unformatted 211:unformatted 212:unformatted 213:unformatted 214:unformatted 215:unformatted 216:unformatted 217:unformatted 218:unformatted 219:unformatted 220:unformatted 221:unformatted 222:unformatted 223:unformatted 224:unformatted 225:unformatted 226:unformatted 227:unformatted 228:unformatted 229:unformatted 230:unformatted 231:unformatted 232:unformatted 233:unformatted 234:unformatted 235:unformatted 236:unformatted 237:unformatted 238:unformatted 239:unformatted 240:unformatted 241:unformatted 242:unformatted 243:unformatted 244:unformatted 245:unformatted 246:unformatted 247:unformatted 248:unformatted 249:unformatted 250:unformatted 251:unformatted 252:unformatted 253:unformatted 254:unformatted 255:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 8192 maxblk 8192 完蛋了，计算错误，L1下面的第二个区也已经被格式化了，看段头信息 Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 101 #blocks: 12928 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x01402100 ext#: 64 blk#: 128 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 8191 mapblk 0x00000000 offset: 64 果然高水位指到了第66个区的L1块地址，这会影响我们的判断，到底哪里出问题了呢？观察8192号块内容是后128个块里被插入了2条，前128个块全满，也就是说我多插了130个块，后来猛然醒悟，我使用DBA来计算的，忘记减去128个块的文件头了，这么一算结果相查差还是不大的，太马虎了，要不是因为马虎哥也能上清华北大了；然后该怎么办呢？重新来过？不用！既然这个L1推过头了，索性把它堆满，然后我们去观察下一个L1，这下就好计算了； declarei number;beginfor i in 1..126 loopinsert into lp values(i,'a','a','a','a');end loop;end;/ 观察8192号块 DBA Ranges : -------------------------------------------------------- 0x01402000 Length: 128 Offset: 0 0x01402080 Length: 128 Offset: 128 0:Metadata 1:FULL 2:FULL 3:FULL 4:FULL 5:FULL 6:FULL 7:FULL 8:FULL 9:FULL 10:FULL 11:FULL 12:FULL 13:FULL 14:FULL 15:FULL 16:FULL 17:FULL 18:FULL 19:FULL 20:FULL 21:FULL 22:FULL 23:FULL 24:FULL 25:FULL 26:FULL 27:FULL 28:FULL 29:FULL 30:FULL 31:FULL 32:FULL 33:FULL 34:FULL 35:FULL 36:FULL 37:FULL 38:FULL 39:FULL 40:FULL 41:FULL 42:FULL 43:FULL 44:FULL 45:FULL 46:FULL 47:FULL 48:FULL 49:FULL 50:FULL 51:FULL 52:FULL 53:FULL 54:FULL 55:FULL 56:FULL 57:FULL 58:FULL 59:FULL 60:FULL 61:FULL 62:FULL 63:FULL 64:FULL 65:FULL 66:FULL 67:FULL 68:FULL 69:FULL 70:FULL 71:FULL 72:FULL 73:FULL 74:FULL 75:FULL 76:FULL 77:FULL 78:FULL 79:FULL 80:FULL 81:FULL 82:FULL 83:FULL 84:FULL 85:FULL 86:FULL 87:FULL 88:FULL 89:FULL 90:FULL 91:FULL 92:FULL 93:FULL 94:FULL 95:FULL 96:FULL 97:FULL 98:FULL 99:FULL 100:FULL 101:FULL 102:FULL 103:FULL 104:FULL 105:FULL 106:FULL 107:FULL 108:FULL 109:FULL 110:FULL 111:FULL 112:FULL 113:FULL 114:FULL 115:FULL 116:FULL 117:FULL 118:FULL 119:FULL 120:FULL 121:FULL 122:FULL 123:FULL 124:FULL 125:FULL 126:FULL 127:FULL 128:FULL 129:FULL 130:FULL 131:FULL 132:FULL 133:FULL 134:FULL 135:FULL 136:FULL 137:FULL 138:FULL 139:FULL 140:FULL 141:FULL 142:FULL 143:FULL 144:FULL 145:FULL 146:FULL 147:FULL 148:FULL 149:FULL 150:FULL 151:FULL 152:FULL 153:FULL 154:FULL 155:FULL 156:FULL 157:FULL 158:FULL 159:FULL 160:FULL 161:FULL 162:FULL 163:FULL 164:FULL 165:FULL 166:FULL 167:FULL 168:FULL 169:FULL 170:FULL 171:FULL 172:FULL 173:FULL 174:FULL 175:FULL 176:FULL 177:FULL 178:FULL 179:FULL 180:FULL 181:FULL 182:FULL 183:FULL 184:FULL 185:FULL 186:FULL 187:FULL 188:FULL 189:FULL 190:FULL 191:FULL 192:FULL 193:FULL 194:FULL 195:FULL 196:FULL 197:FULL 198:FULL 199:FULL 200:FULL 201:FULL 202:FULL 203:FULL 204:FULL 205:FULL 206:FULL 207:FULL 208:FULL 209:FULL 210:FULL 211:FULL 212:FULL 213:FULL 214:FULL 215:FULL 216:FULL 217:FULL 218:FULL 219:FULL 220:FULL 221:FULL 222:FULL 223:FULL 224:FULL 225:FULL 226:FULL 227:FULL 228:FULL 229:FULL 230:FULL 231:FULL 232:FULL 233:FULL 234:FULL 235:FULL 236:FULL 237:FULL 238:FULL 239:FULL 240:FULL 241:FULL 242:FULL 243:FULL 244:FULL 245:FULL 246:FULL 247:FULL 248:FULL 249:FULL 250:FULL 251:FULL 252:FULL 253:FULL 254:FULL 255:FULL --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 8192 maxblk 8192 已经全满了，这个时候我们再去看一下段头的高水位 Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 101 #blocks: 12928 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x01402100 ext#: 64 blk#: 128 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 8191 mapblk 0x00000000 offset: 64 没有动，看来oracle也是事不到眼前不知道着急啊，来看一看下一个L1 SQL&gt; select dbms_utility.data_block_address_file(to_number('01402100', 'xxxxxxxx')) file#, 2 dbms_utility.data_block_address_block(to_number('01402100', 'xxxxxxxx')) block# 3 from dual; FILE# BLOCK#---------- ---------- 5 8448 这个L1是5号文件8448号块，dump出来 DBA Ranges : -------------------------------------------------------- 0x01402100 Length: 128 Offset: 0 0x01402180 Length: 128 Offset: 128 0:Metadata 1:unformatted 2:unformatted 3:unformatted 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:unformatted 17:unformatted 18:unformatted 19:unformatted 20:unformatted 21:unformatted 22:unformatted 23:unformatted 24:unformatted 25:unformatted 26:unformatted 27:unformatted 28:unformatted 29:unformatted 30:unformatted 31:unformatted 32:unformatted 33:unformatted 34:unformatted 35:unformatted 36:unformatted 37:unformatted 38:unformatted 39:unformatted 40:unformatted 41:unformatted 42:unformatted 43:unformatted 44:unformatted 45:unformatted 46:unformatted 47:unformatted 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted 64:unformatted 65:unformatted 66:unformatted 67:unformatted 68:unformatted 69:unformatted 70:unformatted 71:unformatted 72:unformatted 73:unformatted 74:unformatted 75:unformatted 76:unformatted 77:unformatted 78:unformatted 79:unformatted 80:unformatted 81:unformatted 82:unformatted 83:unformatted 84:unformatted 85:unformatted 86:unformatted 87:unformatted 88:unformatted 89:unformatted 90:unformatted 91:unformatted 92:unformatted 93:unformatted 94:unformatted 95:unformatted 96:unformatted 97:unformatted 98:unformatted 99:unformatted 100:unformatted 101:unformatted 102:unformatted 103:unformatted 104:unformatted 105:unformatted 106:unformatted 107:unformatted 108:unformatted 109:unformatted 110:unformatted 111:unformatted 112:unformatted 113:unformatted 114:unformatted 115:unformatted 116:unformatted 117:unformatted 118:unformatted 119:unformatted 120:unformatted 121:unformatted 122:unformatted 123:unformatted 124:unformatted 125:unformatted 126:unformatted 127:unformatted 128:unformatted 129:unformatted 130:unformatted 131:unformatted 132:unformatted 133:unformatted 134:unformatted 135:unformatted 136:unformatted 137:unformatted 138:unformatted 139:unformatted 140:unformatted 141:unformatted 142:unformatted 143:unformatted 144:unformatted 145:unformatted 146:unformatted 147:unformatted 148:unformatted 149:unformatted 150:unformatted 151:unformatted 152:unformatted 153:unformatted 154:unformatted 155:unformatted 156:unformatted 157:unformatted 158:unformatted 159:unformatted 160:unformatted 161:unformatted 162:unformatted 163:unformatted 164:unformatted 165:unformatted 166:unformatted 167:unformatted 168:unformatted 169:unformatted 170:unformatted 171:unformatted 172:unformatted 173:unformatted 174:unformatted 175:unformatted 176:unformatted 177:unformatted 178:unformatted 179:unformatted 180:unformatted 181:unformatted 182:unformatted 183:unformatted 184:unformatted 185:unformatted 186:unformatted 187:unformatted 188:unformatted 189:unformatted 190:unformatted 191:unformatted 192:unformatted 193:unformatted 194:unformatted 195:unformatted 196:unformatted 197:unformatted 198:unformatted 199:unformatted 200:unformatted 201:unformatted 202:unformatted 203:unformatted 204:unformatted 205:unformatted 206:unformatted 207:unformatted 208:unformatted 209:unformatted 210:unformatted 211:unformatted 212:unformatted 213:unformatted 214:unformatted 215:unformatted 216:unformatted 217:unformatted 218:unformatted 219:unformatted 220:unformatted 221:unformatted 222:unformatted 223:unformatted 224:unformatted 225:unformatted 226:unformatted 227:unformatted 228:unformatted 229:unformatted 230:unformatted 231:unformatted 232:unformatted 233:unformatted 234:unformatted 235:unformatted 236:unformatted 237:unformatted 238:unformatted 239:unformatted 240:unformatted 241:unformatted 242:unformatted 243:unformatted 244:unformatted 245:unformatted 246:unformatted 247:unformatted 248:unformatted 249:unformatted 250:unformatted 251:unformatted 252:unformatted 253:unformatted 254:unformatted 255:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 8448 maxblk 8448 256个块，除了第一个是L1元数据之外，没有一个格式化的，这就达到了我们的目的，我现在要插入一条数据，迫使高水位推动，猜一下高水位会在哪？在L1管理的最后一个块后面么？看插入一行数据之后的8448号块 DBA Ranges : -------------------------------------------------------- 0x01402100 Length: 128 Offset: 0 0x01402180 Length: 128 Offset: 128 0:Metadata 1:unformatted 2:unformatted 3:unformatted 4:unformatted 5:unformatted 6:unformatted 7:unformatted 8:unformatted 9:unformatted 10:unformatted 11:unformatted 12:unformatted 13:unformatted 14:unformatted 15:unformatted 16:75-100% free 17:75-100% free 18:75-100% free 19:75-100% free 20:75-100% free 21:75-100% free 22:75-100% free 23:75-100% free 24:75-100% free 25:75-100% free 26:75-100% free 27:75-100% free 28:FULL 29:75-100% free 30:75-100% free 31:75-100% free 32:unformatted 33:unformatted 34:unformatted 35:unformatted 36:unformatted 37:unformatted 38:unformatted 39:unformatted 40:unformatted 41:unformatted 42:unformatted 43:unformatted 44:unformatted 45:unformatted 46:unformatted 47:unformatted 48:unformatted 49:unformatted 50:unformatted 51:unformatted 52:unformatted 53:unformatted 54:unformatted 55:unformatted 56:unformatted 57:unformatted 58:unformatted 59:unformatted 60:unformatted 61:unformatted 62:unformatted 63:unformatted 64:unformatted 65:unformatted 66:unformatted 67:unformatted 68:unformatted 69:unformatted 70:unformatted 71:unformatted 72:unformatted 73:unformatted 74:unformatted 75:unformatted 76:unformatted 77:unformatted 78:unformatted 79:unformatted 80:unformatted 81:unformatted 82:unformatted 83:unformatted 84:unformatted 85:unformatted 86:unformatted 87:unformatted 88:unformatted 89:unformatted 90:unformatted 91:unformatted 92:unformatted 93:unformatted 94:unformatted 95:unformatted 96:unformatted 97:unformatted 98:unformatted 99:unformatted 100:unformatted 101:unformatted 102:unformatted 103:unformatted 104:unformatted 105:unformatted 106:unformatted 107:unformatted 108:unformatted 109:unformatted 110:unformatted 111:unformatted 112:unformatted 113:unformatted 114:unformatted 115:unformatted 116:unformatted 117:unformatted 118:unformatted 119:unformatted 120:unformatted 121:unformatted 122:unformatted 123:unformatted 124:unformatted 125:unformatted 126:unformatted 127:unformatted 128:unformatted 129:unformatted 130:unformatted 131:unformatted 132:unformatted 133:unformatted 134:unformatted 135:unformatted 136:unformatted 137:unformatted 138:unformatted 139:unformatted 140:unformatted 141:unformatted 142:unformatted 143:unformatted 144:unformatted 145:unformatted 146:unformatted 147:unformatted 148:unformatted 149:unformatted 150:unformatted 151:unformatted 152:unformatted 153:unformatted 154:unformatted 155:unformatted 156:unformatted 157:unformatted 158:unformatted 159:unformatted 160:unformatted 161:unformatted 162:unformatted 163:unformatted 164:unformatted 165:unformatted 166:unformatted 167:unformatted 168:unformatted 169:unformatted 170:unformatted 171:unformatted 172:unformatted 173:unformatted 174:unformatted 175:unformatted 176:unformatted 177:unformatted 178:unformatted 179:unformatted 180:unformatted 181:unformatted 182:unformatted 183:unformatted 184:unformatted 185:unformatted 186:unformatted 187:unformatted 188:unformatted 189:unformatted 190:unformatted 191:unformatted 192:unformatted 193:unformatted 194:unformatted 195:unformatted 196:unformatted 197:unformatted 198:unformatted 199:unformatted 200:unformatted 201:unformatted 202:unformatted 203:unformatted 204:unformatted 205:unformatted 206:unformatted 207:unformatted 208:unformatted 209:unformatted 210:unformatted 211:unformatted 212:unformatted 213:unformatted 214:unformatted 215:unformatted 216:unformatted 217:unformatted 218:unformatted 219:unformatted 220:unformatted 221:unformatted 222:unformatted 223:unformatted 224:unformatted 225:unformatted 226:unformatted 227:unformatted 228:unformatted 229:unformatted 230:unformatted 231:unformatted 232:unformatted 233:unformatted 234:unformatted 235:unformatted 236:unformatted 237:unformatted 238:unformatted 239:unformatted 240:unformatted 241:unformatted 242:unformatted 243:unformatted 244:unformatted 245:unformatted 246:unformatted 247:unformatted 248:unformatted 249:unformatted 250:unformatted 251:unformatted 252:unformatted 253:unformatted 254:unformatted 255:unformatted --------------------------------------------------------End dump data blocks tsn: 8 file#: 5 minblk 8448 maxblk 8448 有一个块已经满了，揭晓答案的时候来了，dump出段头 Extent Control Header ----------------------------------------------------------------- Extent Header:: spare1: 0 spare2: 0 #extents: 101 #blocks: 12928 last map 0x00000000 #maps: 0 offset: 2716 Highwater:: 0x01402180 ext#: 65 blk#: 128 ext size: 128 #blocks in seg. hdr&apos;s freelists: 0 #blocks below: 8318 mapblk 0x00000000 offset: 65 高水位是0x01402180，这个地址在哪呢？0x01402180比0x01402100多了十六进制80个块，就是十进制的128个块，仅仅是推动了一个区的大小，并不是一个L1的大小，这说明常规路径下插入高水位的推动是以L1和区中小的那个单位来推动的，就是L1小就推动L1里面所有块的大小，区小就推动一个区的大小，可见所谓的高并发并非像宣传的那样，还是受高水位的限制的，这个时候的区块大概像下面这个样子： 开几个session做下插入试试 SQL&gt; select dbms_rowid.ROWID_RELATIVE_FNO(rowid),dbms_rowid.ROWID_BLOCK_NUMBER(rowid) from lp where trim(des1)='b'; 5 8474 5 8482 5 8484 5 8488 5 8489 5 8490 5 8491 5 8492 5 8493 5 8494 5 8495 5 8496 5 8498 5 8500 5 8504 5 8506 5 8512 5 8514 5 8520 5 852220 rows selected. 全部是在高水位之下这个实验有一点值得思考，就是PCTFREE如何设置，在插入删除频繁的段，PCTFREE的值应该要远离三个百分比线，就是25%/50%/75%，避免频繁插入删除的时候块状态频繁改变，由full变为非full，如此就会修改L1块的内容，有可能造成buffer busy waits。而大家熟知的直接路径下的插入是直接在高水位之上插入并且绕过cache buffer的，这种情况下的高水位是如何推动的呢？我们再慢慢分析.]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RMAN异机异目录完全恢复]]></title>
    <url>%2F2015%2F09%2F23%2Foracle%2Fbackup-restore%2FRMAN-different-server-directory-full-restore%2F</url>
    <content type="text"><![CDATA[开始 先说一下为什么要写这个异机完全恢复的blog，作为一个年轻的DBA，相信大多数都是备份长做而恢复不常做，我会经常担心我的生产库的服务器挂了怎么办，我的备份完好，但我们又没有容灾，我能否保证我的数据不丢失呢，所以就要rman利用备份重建，而如果此时我能找到完好无损的在线日志，我是不是可以完全恢复了呢，理论上大家都说可以，确从未在网上见到过完全恢复的事例（完全其实很简单，只是网上阐述了太多的不完全恢复，会让我觉得set until time等等是必备的其中一步），甚至oracle的官方网文档上也使用了“SET UNTIL SCN 123456;” 的案例，有鉴于此，我做了这个实验，并记录下来，跟大家分享，不见得这篇原创有多高深的技术和见解O(∩_∩)O 环境： 源库： os：redhat 6.3 x64 db: 11gr2 11.2.0.4 存储方式：ASM 目标库： os：redhat 6.5 x64 db: 11gr2 11.2.0.4 存储方式：文件系统 1. 首先，源库进行rman备份--手动0级全库备份run &#123; CONFIGURE RETENTION POLICY TO RECOVERY WINDOW OF 7 DAYS; CONFIGURE BACKUP OPTIMIZATION ON; CONFIGURE CONTROLFILE AUTOBACKUP ON; CONFIGURE DEVICE TYPE DISK PARALLELISM 4 BACKUP TYPE TO BACKUPSET; CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO '+DATA/backup/ctl_atuo_%F'; ALLOCATE CHANNEL c1 TYPE DISK; ALLOCATE CHANNEL c2 TYPE DISK; CROSSCHECK ARCHIVELOG ALL; BACKUP INCREMENTAL LEVEL 0 DATABASE FORMAT '+DATA/backup/db_%U' TAG 'db_rman'; SQL 'ALTER SYSTEM ARCHIVE LOG CURRENT'; BACKUP ARCHIVELOG ALL FORMAT '+DATA/backup/arc_%U' TAG 'ARC_rman' DELETE INPUT; DELETE NOPROMPT OBSOLETE; RELEASE CHANNEL c1; RELEASE CHANNEL c2;&#125; 观察备份的文件，此处是ASM分别用asmcmd和rman查看ASMCMD&gt; lsarc_0cqhdnqq_1_1arc_0dqhdnqq_1_1ctl_atuo_c-2496627597-20150917-00ctl_atuo_c-2496627597-20150917-01db_09qhdno6_1_1db_0aqhdno6_1_1ASMCMD&gt; pwd+Data/backupASMCMD&gt;RMAN&gt; list backup summary;List of Backups===============Key TY LV S Device Type Completion Time #Pieces #Copies Compressed Tag------- -- -- - ----------- --------------- ------- ------- ---------- ---9 B 0 A DISK 17-SEP-15 1 1 NO DB_RMAN10 B 0 A DISK 17-SEP-15 1 1 NO DB_RMAN11 B F A DISK 17-SEP-15 1 1 NO TAG20150917T22165012 B A A DISK 17-SEP-15 1 1 NO ARC_RMAN13 B A A DISK 17-SEP-15 1 1 NO ARC_RMAN14 B F A DISK 17-SEP-15 1 1 NO TAG20150917T221703 为了试验restore之后recover应用归档日志的情况，我在0级备份之后再生成一些归档日志，脚本如下：declare i integer;begin for i in 1..3000000 loop insert into t values(i,'aaaaaaaaaaaaaaaaaaaaa'); end loop;end; 向测试表T中插入200万行数据，看归档的日志：ASMCMD&gt; ls1_22_854775184.dbf1_23_854775184.dbf1_24_854775184.dbf1_25_854775184.dbf1_26_854775184.dbf1_27_854775184.dbf1_28_854775184.dbf1_29_854775184.dbf1_30_854775184.dbf1_31_854775184.dbf1_32_854775184.dbf1_33_854775184.dbf1_34_854775184.dbf1_35_854775184.dbf1_36_854775184.dbf1_37_854775184.dbf1_38_854775184.dbf1_39_854775184.dbf 查看T表的行数SQL&gt; select count(1) from t; COUNT(1)---------- 3000000 2. 转移备份现在要把rman备份，备份之后的归档，源库关闭之后的在线redo文件拷贝到备库，这里稍微麻烦一点，涉及到从asm中拷贝文件，我这里使用2中方法，rman的backup as cpoy以及asmcmd的cp命令，如下所示： rman copy备份集 --这里是copy 0级备份backup as copy backupset 9 format '/u01/backupset/db2.rman';backup as copy backupset 10 format '/u01/backupset/db2.rman';backup as copy backupset 11 format '/u01/backupset/ctl1.rman';backup as copy backupset 12 format '/u01/backupset/arc1.rman';backup as copy backupset 13 format '/u01/backupset/arc2.rman';backup as copy backupset 14 format '/u01/backupset/ctl2.rman'; asmcmd转移归档 --生成的归档日志ASMCMD&gt; ls1_22_854775184.dbf1_23_854775184.dbf1_24_854775184.dbf1_25_854775184.dbf1_26_854775184.dbf1_27_854775184.dbf1_28_854775184.dbf1_29_854775184.dbf1_30_854775184.dbf1_31_854775184.dbf1_32_854775184.dbf1_33_854775184.dbf1_34_854775184.dbf1_35_854775184.dbf1_36_854775184.dbf1_37_854775184.dbf1_38_854775184.dbf1_39_854775184.dbf--copy走，无法使用通配符是一件很痛苦的事情ASMCMD&gt; cp 1_23_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_23_854775184.dbf -&gt; /u02/backupset/1_23_854775184.dbfASMCMD&gt; cp 1_24_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_24_854775184.dbf -&gt; /u02/backupset/1_24_854775184.dbfASMCMD&gt; cp 1_25_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_25_854775184.dbf -&gt; /u02/backupset/1_25_854775184.dbfASMCMD&gt; cp 1_26_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_26_854775184.dbf -&gt; /u02/backupset/1_26_854775184.dbfASMCMD&gt; cp 1_27_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_27_854775184.dbf -&gt; /u02/backupset/1_27_854775184.dbfASMCMD&gt; cp 1_28_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_28_854775184.dbf -&gt; /u02/backupset/1_28_854775184.dbfASMCMD&gt; cp 1_29_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_29_854775184.dbf -&gt; /u02/backupset/1_29_854775184.dbfASMCMD&gt; cp 1_3* /u02/backupsetcopying +Data/archive_log/1_30_854775184.dbf -&gt; /u02/backupset/1_30_854775184.dbfASMCMD&gt; cp 1_31_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_31_854775184.dbf -&gt; /u02/backupset/1_31_854775184.dbfASMCMD&gt; cp 1_32_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_32_854775184.dbf -&gt; /u02/backupset/1_32_854775184.dbfASMCMD&gt; cp 1_33_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_33_854775184.dbf -&gt; /u02/backupset/1_33_854775184.dbfASMCMD&gt; cp 1_34_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_34_854775184.dbf -&gt; /u02/backupset/1_34_854775184.dbfASMCMD&gt; cp 1_35_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_35_854775184.dbf -&gt; /u02/backupset/1_35_854775184.dbfASMCMD&gt; cp 1_36_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_36_854775184.dbf -&gt; /u02/backupset/1_36_854775184.dbfASMCMD&gt; cp 1_37_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_37_854775184.dbf -&gt; /u02/backupset/1_37_854775184.dbfASMCMD&gt; cp 1_38_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_38_854775184.dbf -&gt; /u02/backupset/1_38_854775184.dbfASMCMD&gt; cp 1_39_854775184.dbf /u02/backupsetcopying +Data/archive_log/1_39_854775184.dbf -&gt; /u02/backupset/1_39_854775184.dbf 查看当前的redo状态,记住当前redo的seq号SQL&gt; select group#,SEQUENCE# ,MEMBERS,ARCHIVED,STATUS from v$log; GROUP# SEQUENCE# MEMBERS ARC STATUS---------- ---------- ---------- --- ---------------- 1 40 2 NO CURRENT 2 38 2 YES INACTIVE 3 39 2 YES INACTIVE 查看redo文件 SQL&gt; select GROUP#,STATUS,MEMBER from v$logfile; GROUP# STATUS MEMBER---------- ------- -------------------------------------------------------------------------------- 3 +DATA/min/onlinelog/group_3.266.854775193 3 +DATA/min/onlinelog/group_3.267.854775195 2 +DATA/min/onlinelog/group_2.264.854775189 2 +DATA/min/onlinelog/group_2.265.854775191 1 +DATA/min/onlinelog/group_1.262.854775185 1 +DATA/min/onlinelog/group_1.263.854775187 使用asmcmd拷贝并改名，这个时候我已经关闭了源库 ASMCMD&gt; cd onlinelogASMCMD&gt;ASMCMD&gt; lsgroup_1.262.854775185group_1.263.854775187group_2.264.854775189group_2.265.854775191group_3.266.854775193group_3.267.854775195ASMCMD&gt; cp group_1.262.854775185 /u02/backupset/redo1a.logcopying +Data/min/onlinelog/group_1.262.854775185 -&gt; /u02/backupset/redo1a.logASMCMD&gt; cp group_1.263.854775187 /u02/backupset/redo1b.logcopying +Data/min/onlinelog/group_1.263.854775187 -&gt; /u02/backupset/redo1b.logASMCMD&gt; cp group_2.264.854775189 /u02/backupset/redo2a.logcopying +Data/min/onlinelog/group_2.264.854775189 -&gt; /u02/backupset/redo2a.logASMCMD&gt; cp group_2.265.854775191 /u02/backupset/redo2b.logcopying +Data/min/onlinelog/group_2.265.854775191 -&gt; /u02/backupset/redo2b.logASMCMD&gt; cp group_3.266.854775193 /u02/backupset/redo3a.logcopying +Data/min/onlinelog/group_3.266.854775193 -&gt; /u02/backupset/redo3a.logASMCMD&gt; cp group_3.267.854775195 /u02/backupset/redo3b.logcopying +Data/min/onlinelog/group_3.267.854775195 -&gt; /u02/backupset/redo3b.log 3. 目标机器恢复这一步之前已经在目标主机安装好oracle软件，安装过程不再赘述，直接记录恢复过程这里直接从备份中恢复pfile（比较懒，不想手动准备），无参数文件，rman会启动一个傻瓜实例，供我们恢复参数文件。 ###从备份中恢复参数文件 RMAN&gt; startup nomountstartup failed: ORA-01078: failure in processing system parametersLRM-00109: could not open parameter file '/home/oracle/app/oracle/product/11.2.0/dbhome_1/dbs/initmin.ora'starting Oracle instance without parameter file for retrieval of spfileOracle instance startedTotal System Global Area 1068937216 bytesFixed Size 2260088 bytesVariable Size 281019272 bytesDatabase Buffers 780140544 bytesRedo Buffers 5517312 bytesRMAN&gt; restore spfile to pfile '/home/oracle/app/oracle/product/11.2.0/dbhome_1/dbs/initmin.ora' from '/u01/rmanbackup/ctl2.rman';Starting restore at 18-SEP-15using target database control file instead of recovery catalogallocated channel: ORA_DISK_1channel ORA_DISK_1: SID=171 device type=DISKchannel ORA_DISK_1: restoring spfile from AUTOBACKUP /u01/rmanbackup/ctl2.rmanchannel ORA_DISK_1: SPFILE restore from AUTOBACKUP completeFinished restore at 18-SEP-15RMAN&gt; shutdown abortOracle instance shut down 创建目录，修改参数文件[oracle@rman_newhost u01]$ mkdir -p /u01/app/oracle/admin/min/adump[oracle@rman_newhost u01]$ mkdir -p /u01/app/oracle/fast_recovery_area[oracle@rman_newhost u01]$ mkdir -p /u01/app/oracle/archived_log[oracle@rman_newhost u01]$ mkdir -p /u01/app/oracle/oradata/min*.audit_file_dest='/u01/app/oracle/admin/min/adump'*.audit_trail='db'*.compatible='11.2.0.4.0'*.control_files='/u01/app/oracle/fast_recovery_area/control01.ctl','/u01/app/oracle/oradata/min/control02.ctl'*.db_block_size=8192*.db_domain=''*.db_name='min'*.db_recovery_file_dest='/u01/app/oracle/fast_recovery_area'*.db_recovery_file_dest_size=4385144832*.diagnostic_dest='/u01/app/oracle'*.dispatchers='(PROTOCOL=TCP) (SERVICE=minXDB)'*.log_archive_dest_1='location=/u01/app/oracle/archived_log'*.log_checkpoints_to_alert=TRUE*.memory_target=1394606080*.open_cursors=300*.processes=1500*.remote_login_passwordfile='EXCLUSIVE'*.sessions=1655*.undo_tablespace='UNDOTBS1' 启动到nomount状态，恢复控制文件RMAN&gt; startup nomountconnected to target database (not started)Oracle instance startedTotal System Global Area 1402982400 bytesFixed Size 2253184 bytesVariable Size 1275072128 bytesDatabase Buffers 117440512 bytesRedo Buffers 8216576 bytesRMAN&gt; restore controlfile from '/u01/rmanbackup/ctl2.rman';Starting restore at 18-SEP-15allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=1146 device type=DISKchannel ORA_DISK_1: restoring control filechannel ORA_DISK_1: restore complete, elapsed time: 00:00:01output file name=/u01/app/oracle/fast_recovery_area/control01.ctloutput file name=/u01/app/oracle/oradata/min/control02.ctlFinished restore at 18-SEP-15RMAN&gt; alter database mount;database mountedreleased channel: ORA_DISK_1 将redo文件和归档日志移动到对应目录下[oracle@rman_newhost rmanbackup]$ mv redo* /u01/app/oracle/oradata/min[oracle@rman_newhost rmanbackup]$ ll /u01/app/oracle/oradata/min总用量 316744-rw-r-----. 1 oracle oinstall 9748480 9月 18 00:34 control02.ctl-rw-r--r--. 1 oracle oinstall 52429312 9月 17 23:00 redo1a.log-rw-r--r--. 1 oracle oinstall 52429312 9月 17 23:01 redo1b.log-rw-r--r--. 1 oracle oinstall 52429312 9月 17 23:01 redo2a.log-rw-r--r--. 1 oracle oinstall 52429312 9月 17 23:01 redo2b.log-rw-r--r--. 1 oracle oinstall 52429312 9月 17 23:02 redo3a.log-rw-r--r--. 1 oracle oinstall 52429312 9月 17 23:02 redo3b.log[oracle@rman_newhost rmanbackup]$ mv 1_* /u01/app/oracle/archived_log[oracle@rman_newhost rmanbackup]$ ll /u01/app/oracle/archived_log总用量 809056-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:48 1_22_854775184.dbf-rw-r--r--. 1 oracle oinstall 39179776 9月 17 22:49 1_23_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:49 1_24_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:50 1_25_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:50 1_26_854775184.dbf-rw-r--r--. 1 oracle oinstall 48581120 9月 17 22:50 1_27_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:51 1_28_854775184.dbf-rw-r--r--. 1 oracle oinstall 42950144 9月 17 22:51 1_29_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:51 1_30_854775184.dbf-rw-r--r--. 1 oracle oinstall 50134016 9月 17 22:53 1_31_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:53 1_32_854775184.dbf-rw-r--r--. 1 oracle oinstall 46714368 9月 17 22:53 1_33_854775184.dbf-rw-r--r--. 1 oracle oinstall 44308480 9月 17 22:54 1_34_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:54 1_35_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:54 1_36_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:54 1_37_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:55 1_38_854775184.dbf-rw-r--r--. 1 oracle oinstall 46381568 9月 17 22:55 1_39_854775184.dbf 注册备份集下面一步的操作是删掉控制文件中对备份的记录信息，因为这是源库备份恢复过来的，我们要删掉老的备份信息，将备份重新注册，不删也没关系，crosscheck以后你会发现，原来的备份状态都是expired的 利用crosscheck删除控制文件中的备份记录 RMAN&gt; list backup summary;List of Backups===============Key TY LV S Device Type Completion Time #Pieces #Copies Compressed Tag------- -- -- - ----------- --------------- ------- ------- ---------- ---9 B 0 A DISK 17-SEP-15 1 1 NO DB_RMAN10 B 0 A DISK 17-SEP-15 1 1 NO DB_RMAN11 B F A DISK 17-SEP-15 1 1 NO TAG20150917T22165012 B A A DISK 17-SEP-15 1 1 NO ARC_RMAN13 B A A DISK 17-SEP-15 1 1 NO ARC_RMANRMAN&gt; crosscheck backup;Starting implicit crosscheck backup at 18-SEP-15allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=1146 device type=DISKallocated channel: ORA_DISK_2channel ORA_DISK_2: SID=10 device type=DISKallocated channel: ORA_DISK_3channel ORA_DISK_3: SID=1147 device type=DISKallocated channel: ORA_DISK_4channel ORA_DISK_4: SID=11 device type=DISKCrosschecked 5 objectsFinished implicit crosscheck backup at 18-SEP-15Starting implicit crosscheck copy at 18-SEP-15using channel ORA_DISK_1using channel ORA_DISK_2using channel ORA_DISK_3using channel ORA_DISK_4Finished implicit crosscheck copy at 18-SEP-15searching for all files in the recovery areacataloging files...no files catalogedusing channel ORA_DISK_1using channel ORA_DISK_2using channel ORA_DISK_3using channel ORA_DISK_4crosschecked backup piece: found to be 'EXPIRED'backup piece handle=+DATA/backup/db_0aqhdno6_1_1 RECID=9 STAMP=890691334crosschecked backup piece: found to be 'EXPIRED'backup piece handle=+DATA/backup/db_09qhdno6_1_1 RECID=10 STAMP=890691334crosschecked backup piece: found to be 'EXPIRED'backup piece handle=+DATA/backup/ctl_atuo_c-2496627597-20150917-00 RECID=11 STAMP=890691411crosschecked backup piece: found to be 'EXPIRED'backup piece handle=+DATA/backup/arc_0dqhdnqq_1_1 RECID=12 STAMP=890691418crosschecked backup piece: found to be 'EXPIRED'backup piece handle=+DATA/backup/arc_0cqhdnqq_1_1 RECID=13 STAMP=890691418Crosschecked 5 objectsRMAN&gt; list backup;List of Backup Sets===================BS Key Type LV Size Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------9 Incr 0 433.65M DISK 00:01:10 17-SEP-15 BP Key: 9 Status: EXPIRED Compressed: NO Tag: DB_RMAN Piece Name: +DATA/backup/db_0aqhdno6_1_1 List of Datafiles in backup set 9 File LV Type Ckp SCN Ckp Time Name ---- -- ---- ---------- --------- ---- 2 0 Incr 1138043 17-SEP-15 +DATA/min/datafile/sysaux.257.854775097 3 0 Incr 1138043 17-SEP-15 +DATA/min/datafile/undotbs1.258.854775097BS Key Type LV Size Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10 Incr 0 638.84M DISK 00:01:10 17-SEP-15 BP Key: 10 Status: EXPIRED Compressed: NO Tag: DB_RMAN Piece Name: +DATA/backup/db_09qhdno6_1_1 List of Datafiles in backup set 10 File LV Type Ckp SCN Ckp Time Name ---- -- ---- ---------- --------- ---- 1 0 Incr 1138042 17-SEP-15 +DATA/min/datafile/system.256.854775095 4 0 Incr 1138042 17-SEP-15 +DATA/min/datafile/users.259.854775097BS Key Type LV Size Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------11 Full 9.36M DISK 00:00:01 17-SEP-15 BP Key: 11 Status: EXPIRED Compressed: NO Tag: TAG20150917T221650 Piece Name: +DATA/backup/ctl_atuo_c-2496627597-20150917-00 SPFILE Included: Modification time: 17-SEP-15 SPFILE db_unique_name: MIN Control File Included: Ckp SCN: 1138347 Ckp time: 17-SEP-15BS Key Size Device Type Elapsed Time Completion Time------- ---------- ----------- ------------ ---------------12 2.00K DISK 00:00:00 17-SEP-15 BP Key: 12 Status: EXPIRED Compressed: NO Tag: ARC_RMAN Piece Name: +DATA/backup/arc_0dqhdnqq_1_1 List of Archived Logs in backup set 12 Thrd Seq Low SCN Low Time Next SCN Next Time ---- ------- ---------- --------- ---------- --------- 1 21 1138364 17-SEP-15 1138372 17-SEP-15BS Key Size Device Type Elapsed Time Completion Time------- ---------- ----------- ------------ ---------------13 30.99M DISK 00:00:02 17-SEP-15 BP Key: 13 Status: EXPIRED Compressed: NO Tag: ARC_RMAN Piece Name: +DATA/backup/arc_0cqhdnqq_1_1 List of Archived Logs in backup set 13 Thrd Seq Low SCN Low Time Next SCN Next Time ---- ------- ---------- --------- ---------- --------- 1 20 1127220 17-SEP-15 1138364 17-SEP-15RMAN&gt; list archivelog all;specification does not match any archived log in the repositoryRMAN&gt; report obsolete;RMAN retention policy will be applied to the commandRMAN retention policy is set to recovery window of 7 daysno obsolete backups foundRMAN&gt; list expired backup;List of Backup Sets===================BS Key Type LV Size Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------9 Incr 0 433.65M DISK 00:01:10 17-SEP-15 BP Key: 9 Status: EXPIRED Compressed: NO Tag: DB_RMAN Piece Name: +DATA/backup/db_0aqhdno6_1_1 List of Datafiles in backup set 9 File LV Type Ckp SCN Ckp Time Name ---- -- ---- ---------- --------- ---- 2 0 Incr 1138043 17-SEP-15 +DATA/min/datafile/sysaux.257.854775097 3 0 Incr 1138043 17-SEP-15 +DATA/min/datafile/undotbs1.258.854775097BS Key Type LV Size Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------10 Incr 0 638.84M DISK 00:01:10 17-SEP-15 BP Key: 10 Status: EXPIRED Compressed: NO Tag: DB_RMAN Piece Name: +DATA/backup/db_09qhdno6_1_1 List of Datafiles in backup set 10 File LV Type Ckp SCN Ckp Time Name ---- -- ---- ---------- --------- ---- 1 0 Incr 1138042 17-SEP-15 +DATA/min/datafile/system.256.854775095 4 0 Incr 1138042 17-SEP-15 +DATA/min/datafile/users.259.854775097BS Key Type LV Size Device Type Elapsed Time Completion Time------- ---- -- ---------- ----------- ------------ ---------------11 Full 9.36M DISK 00:00:01 17-SEP-15 BP Key: 11 Status: EXPIRED Compressed: NO Tag: TAG20150917T221650 Piece Name: +DATA/backup/ctl_atuo_c-2496627597-20150917-00 SPFILE Included: Modification time: 17-SEP-15 SPFILE db_unique_name: MIN Control File Included: Ckp SCN: 1138347 Ckp time: 17-SEP-15BS Key Size Device Type Elapsed Time Completion Time------- ---------- ----------- ------------ ---------------12 2.00K DISK 00:00:00 17-SEP-15 BP Key: 12 Status: EXPIRED Compressed: NO Tag: ARC_RMAN Piece Name: +DATA/backup/arc_0dqhdnqq_1_1 List of Archived Logs in backup set 12 Thrd Seq Low SCN Low Time Next SCN Next Time ---- ------- ---------- --------- ---------- --------- 1 21 1138364 17-SEP-15 1138372 17-SEP-15BS Key Size Device Type Elapsed Time Completion Time------- ---------- ----------- ------------ ---------------13 30.99M DISK 00:00:02 17-SEP-15 BP Key: 13 Status: EXPIRED Compressed: NO Tag: ARC_RMAN Piece Name: +DATA/backup/arc_0cqhdnqq_1_1 List of Archived Logs in backup set 13 Thrd Seq Low SCN Low Time Next SCN Next Time ---- ------- ---------- --------- ---------- --------- 1 20 1127220 17-SEP-15 1138364 17-SEP-15RMAN&gt; delete noprompt expired backup;using channel ORA_DISK_1using channel ORA_DISK_2using channel ORA_DISK_3using channel ORA_DISK_4List of Backup PiecesBP Key BS Key Pc# Cp# Status Device Type Piece Name------- ------- --- --- ----------- ----------- ----------9 9 1 1 EXPIRED DISK +DATA/backup/db_0aqhdno6_1_110 10 1 1 EXPIRED DISK +DATA/backup/db_09qhdno6_1_111 11 1 1 EXPIRED DISK +DATA/backup/ctl_atuo_c-2496627597-20150917-0012 12 1 1 EXPIRED DISK +DATA/backup/arc_0dqhdnqq_1_113 13 1 1 EXPIRED DISK +DATA/backup/arc_0cqhdnqq_1_1deleted backup piecebackup piece handle=+DATA/backup/db_0aqhdno6_1_1 RECID=9 STAMP=890691334deleted backup piecebackup piece handle=+DATA/backup/db_09qhdno6_1_1 RECID=10 STAMP=890691334deleted backup piecebackup piece handle=+DATA/backup/ctl_atuo_c-2496627597-20150917-00 RECID=11 STAMP=890691411deleted backup piecebackup piece handle=+DATA/backup/arc_0dqhdnqq_1_1 RECID=12 STAMP=890691418deleted backup piecebackup piece handle=+DATA/backup/arc_0cqhdnqq_1_1 RECID=13 STAMP=890691418Deleted 5 EXPIRED objectsRMAN&gt; list backup;specification does not match any backup in the repository 重新注册备份，并观察控制文件中的备份信息，和数据库结构的信息 RMAN&gt; catalog start with '/u01/rmanbackup';searching for all files that match the pattern /u01/rmanbackupList of Files Unknown to the Database=====================================File Name: /u01/rmanbackup/arc1.rmanFile Name: /u01/rmanbackup/db1.rmanFile Name: /u01/rmanbackup/ctl2.rmanFile Name: /u01/rmanbackup/ctl1.rmanFile Name: /u01/rmanbackup/db2.rmanFile Name: /u01/rmanbackup/arc2.rmanDo you really want to catalog the above files (enter YES or NO)? yescataloging files...cataloging doneList of Cataloged Files=======================File Name: /u01/rmanbackup/arc1.rmanFile Name: /u01/rmanbackup/db1.rmanFile Name: /u01/rmanbackup/ctl2.rmanFile Name: /u01/rmanbackup/ctl1.rmanFile Name: /u01/rmanbackup/db2.rmanFile Name: /u01/rmanbackup/arc2.rmanRMAN&gt; list backup summary;List of Backups===============Key TY LV S Device Type Completion Time #Pieces #Copies Compressed Tag------- -- -- - ----------- --------------- ------- ------- ---------- ---14 B A A DISK 17-SEP-15 1 1 NO ARC_RMAN15 B 0 A DISK 17-SEP-15 1 1 NO DB_RMAN16 B 0 A DISK 17-SEP-15 1 1 NO DB_RMAN17 B A A DISK 17-SEP-15 1 1 NO ARC_RMAN--数据文件、临时文件的记录还是源库的信息，一会儿恢复的时候要setnewnameRMAN&gt; report schema;RMAN-06139: WARNING: control file is not current for REPORT SCHEMAReport of database schema for database with db_unique_name MINList of Permanent Datafiles===========================File Size(MB) Tablespace RB segs Datafile Name---- -------- -------------------- ------- ------------------------1 0 SYSTEM *** +DATA/min/datafile/system.256.8547750952 0 SYSAUX *** +DATA/min/datafile/sysaux.257.8547750973 0 UNDOTBS1 *** +DATA/min/datafile/undotbs1.258.8547750974 0 USERS *** +DATA/min/datafile/users.259.854775097List of Temporary Files=======================File Size(MB) Tablespace Maxsize(MB) Tempfile Name---- -------- -------------------- ----------- --------------------1 20 TEMP 32767 +DATA/min/tempfile/temp.268.854775211--你会发现这是老的控制文件，是我们0级备份里的，其中关于redo的状态记录，当前redo还停留在序列号22SQL&gt; select GROUP#,SEQUENCE# ,STATUS,ARCHIVED from v$log; GROUP# SEQUENCE# STATUS ARC---------- ---------- ---------------- --- 1 22 CURRENT NO 3 21 ACTIVE YES 2 20 ACTIVE YESSQL&gt; desc v$logfile; Name Null? Type ----------------------------------------- -------- ---------------------------- GROUP# NUMBER STATUS VARCHAR2(7) TYPE VARCHAR2(7) MEMBER VARCHAR2(513) IS_RECOVERY_DEST_FILE VARCHAR2(3)--redo的记录还是源库的信息，一会儿恢复的时候要setnewnameSQL&gt; col member for a80SQL&gt; set line 200SQL&gt; select GROUP#,STATUS,MEMBER from v$logfile; GROUP# STATUS MEMBER---------- ------- -------------------------------------------------------------------------------- 3 +DATA/min/onlinelog/group_3.266.854775193 3 +DATA/min/onlinelog/group_3.267.854775195 2 +DATA/min/onlinelog/group_2.264.854775189 2 +DATA/min/onlinelog/group_2.265.854775191 1 +DATA/min/onlinelog/group_1.262.854775185 1 +DATA/min/onlinelog/group_1.263.8547751876 rows selected. 还原数据库RMAN&gt; RUN2&gt; &#123;3&gt; ALLOCATE CHANNEL c1 DEVICE TYPE DISK;4&gt; ALLOCATE CHANNEL c2 DEVICE TYPE DISK;5&gt; set archivelog destination to "/u01/app/oracle/archived_log";6&gt; set newname for datafile 1 to "/u01/app/oracle/oradata/min/system01.dbf";7&gt; set newname for datafile 2 to "/u01/app/oracle/oradata/min/sysaux01.dbf";8&gt; set newname for datafile 3 to "/u01/app/oracle/oradata/min/undotbs01.dbf";9&gt; set newname for datafile 4 to "/u01/app/oracle/oradata/min/users01.dbf";10&gt; set newname for tempfile 1 to "/u01/app/oracle/oradata/min/temp01.dbf";11&gt; SQL "ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_1.262.854775185'' to ''/u01/app/oracle/oradata/min/redo1a.log'' ";12&gt; SQL "ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_1.263.854775187'' to ''/u01/app/oracle/oradata/min/redo1b.log'' ";13&gt; SQL "ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_2.264.854775189'' to ''/u01/app/oracle/oradata/min/redo2a.log'' ";14&gt; SQL "ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_2.265.854775191'' to ''/u01/app/oracle/oradata/min/redo2b.log'' ";15&gt; SQL "ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_3.266.854775193'' to ''/u01/app/oracle/oradata/min/redo3a.log'' ";16&gt; SQL "ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_3.267.854775195'' to ''/u01/app/oracle/oradata/min/redo3b.log'' ";17&gt; RESTORE DATABASE;18&gt; SWITCH DATAFILE ALL;19&gt; switch tempfile all;20&gt; &#125;released channel: ORA_DISK_1released channel: ORA_DISK_2released channel: ORA_DISK_3released channel: ORA_DISK_4allocated channel: c1channel c1: SID=1146 device type=DISKallocated channel: c2channel c2: SID=11 device type=DISKexecuting command: SET ARCHIVELOG DESTINATIONexecuting command: SET NEWNAMEexecuting command: SET NEWNAMEexecuting command: SET NEWNAMEexecuting command: SET NEWNAMEexecuting command: SET NEWNAMEsql statement: ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_1.262.854775185'' to ''/u01/app/oracle/oradata/min/redo1a.log''sql statement: ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_1.263.854775187'' to ''/u01/app/oracle/oradata/min/redo1b.log''sql statement: ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_2.264.854775189'' to ''/u01/app/oracle/oradata/min/redo2a.log''sql statement: ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_2.265.854775191'' to ''/u01/app/oracle/oradata/min/redo2b.log''sql statement: ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_3.266.854775193'' to ''/u01/app/oracle/oradata/min/redo3a.log''sql statement: ALTER DATABASE RENAME FILE ''+DATA/min/onlinelog/group_3.267.854775195'' to ''/u01/app/oracle/oradata/min/redo3b.log''Starting restore at 18-SEP-15skipping datafile 2; already restored to file /u01/app/oracle/oradata/min/sysaux01.dbfchannel c1: starting datafile backup set restorechannel c1: specifying datafile(s) to restore from backup setchannel c1: restoring datafile 00001 to /u01/app/oracle/oradata/min/system01.dbfchannel c1: restoring datafile 00004 to /u01/app/oracle/oradata/min/users01.dbfchannel c1: reading from backup piece /u01/rmanbackup/db2.rmanchannel c2: starting datafile backup set restorechannel c2: specifying datafile(s) to restore from backup setchannel c2: restoring datafile 00003 to /u01/app/oracle/oradata/min/undotbs01.dbfchannel c2: reading from backup piece /u01/rmanbackup/db1.rmanchannel c2: piece handle=/u01/rmanbackup/db1.rman tag=DB_RMANchannel c2: restored backup piece 1channel c2: restore complete, elapsed time: 00:00:08channel c1: piece handle=/u01/rmanbackup/db2.rman tag=DB_RMANchannel c1: restored backup piece 1channel c1: restore complete, elapsed time: 00:00:36Finished restore at 18-SEP-15datafile 1 switched to datafile copyinput datafile copy RECID=5 STAMP=890701322 file name=/u01/app/oracle/oradata/min/system01.dbfdatafile 2 switched to datafile copyinput datafile copy RECID=6 STAMP=890701322 file name=/u01/app/oracle/oradata/min/sysaux01.dbfdatafile 3 switched to datafile copyinput datafile copy RECID=7 STAMP=890701322 file name=/u01/app/oracle/oradata/min/undotbs01.dbfdatafile 4 switched to datafile copyinput datafile copy RECID=8 STAMP=890701322 file name=/u01/app/oracle/oradata/min/users01.dbfrenamed tempfile 1 to /u01/app/oracle/oradata/min/temp01.dbf in control filereleased channel: c1released channel: c2RMAN&gt; restore完毕，我们再来看一下控制文件中的信息 RMAN&gt; report schema;RMAN-06139: WARNING: control file is not current for REPORT SCHEMAReport of database schema for database with db_unique_name MINList of Permanent Datafiles===========================File Size(MB) Tablespace RB segs Datafile Name---- -------- -------------------- ------- ------------------------1 750 SYSTEM *** /u01/app/oracle/oradata/min/system01.dbf2 560 SYSAUX *** /u01/app/oracle/oradata/min/sysaux01.dbf3 100 UNDOTBS1 *** /u01/app/oracle/oradata/min/undotbs01.dbf4 5 USERS *** /u01/app/oracle/oradata/min/users01.dbfList of Temporary Files=======================File Size(MB) Tablespace Maxsize(MB) Tempfile Name---- -------- -------------------- ----------- --------------------1 20 TEMP 32767 /u01/app/oracle/oradata/min/temp01.dbf 完全恢复数据库RMAN&gt; recover database;Starting recover at 18-SEP-15allocated channel: ORA_DISK_1channel ORA_DISK_1: SID=1146 device type=DISKallocated channel: ORA_DISK_2channel ORA_DISK_2: SID=11 device type=DISKallocated channel: ORA_DISK_3channel ORA_DISK_3: SID=1137 device type=DISKallocated channel: ORA_DISK_4channel ORA_DISK_4: SID=10 device type=DISKstarting media recoveryarchived log for thread 1 with sequence 38 is already on disk as file /u01/app/oracle/oradata/min/redo2a.logarchived log for thread 1 with sequence 39 is already on disk as file /u01/app/oracle/oradata/min/redo3a.logarchived log for thread 1 with sequence 40 is already on disk as file /u01/app/oracle/oradata/min/redo1a.logchannel ORA_DISK_1: starting archived log restore to default destinationchannel ORA_DISK_1: restoring archived logarchived log thread=1 sequence=20channel ORA_DISK_1: reading from backup piece /u01/rmanbackup/arc2.rmanchannel ORA_DISK_2: starting archived log restore to default destinationchannel ORA_DISK_2: restoring archived logarchived log thread=1 sequence=21channel ORA_DISK_2: reading from backup piece /u01/rmanbackup/arc1.rmanchannel ORA_DISK_2: piece handle=/u01/rmanbackup/arc1.rman tag=ARC_RMANchannel ORA_DISK_2: restored backup piece 1channel ORA_DISK_2: restore complete, elapsed time: 00:00:01channel ORA_DISK_1: piece handle=/u01/rmanbackup/arc2.rman tag=ARC_RMANchannel ORA_DISK_1: restored backup piece 1channel ORA_DISK_1: restore complete, elapsed time: 00:00:03archived log file name=/u01/app/oracle/archived_log/1_20_854775184.dbf thread=1 sequence=20archived log file name=/u01/app/oracle/archived_log/1_21_854775184.dbf thread=1 sequence=21archived log file name=/u01/app/oracle/archived_log/1_22_854775184.dbf thread=1 sequence=22archived log file name=/u01/app/oracle/archived_log/1_23_854775184.dbf thread=1 sequence=23archived log file name=/u01/app/oracle/archived_log/1_24_854775184.dbf thread=1 sequence=24archived log file name=/u01/app/oracle/archived_log/1_25_854775184.dbf thread=1 sequence=25archived log file name=/u01/app/oracle/archived_log/1_26_854775184.dbf thread=1 sequence=26archived log file name=/u01/app/oracle/archived_log/1_27_854775184.dbf thread=1 sequence=27archived log file name=/u01/app/oracle/archived_log/1_28_854775184.dbf thread=1 sequence=28archived log file name=/u01/app/oracle/archived_log/1_29_854775184.dbf thread=1 sequence=29archived log file name=/u01/app/oracle/archived_log/1_30_854775184.dbf thread=1 sequence=30archived log file name=/u01/app/oracle/archived_log/1_31_854775184.dbf thread=1 sequence=31archived log file name=/u01/app/oracle/archived_log/1_32_854775184.dbf thread=1 sequence=32archived log file name=/u01/app/oracle/archived_log/1_33_854775184.dbf thread=1 sequence=33archived log file name=/u01/app/oracle/archived_log/1_34_854775184.dbf thread=1 sequence=34archived log file name=/u01/app/oracle/archived_log/1_35_854775184.dbf thread=1 sequence=35archived log file name=/u01/app/oracle/archived_log/1_36_854775184.dbf thread=1 sequence=36archived log file name=/u01/app/oracle/archived_log/1_37_854775184.dbf thread=1 sequence=37archived log file name=/u01/app/oracle/oradata/min/redo2a.log thread=1 sequence=38archived log file name=/u01/app/oracle/oradata/min/redo3a.log thread=1 sequence=39archived log file name=/u01/app/oracle/oradata/min/redo1a.log thread=1 sequence=40media recovery complete, elapsed time: 00:00:43Finished recover at 18-SEP-15RMAN&gt; 从恢复的日志可以看出，oracle会绕过38、39号的归档直接利用在线日志做恢复，oracle的聪明之处可见一斑！试着正常方式打开数据库，会发现报错： RMAN&gt; alter database open;RMAN-00571: ===========================================================RMAN-00569: =============== ERROR MESSAGE STACK FOLLOWS ===============RMAN-00571: ===========================================================RMAN-03002: failure of alter db command at 09/18/2015 01:04:41ORA-01589: must use RESETLOGS or NORESETLOGS option for database open--看一下此时控制文件中的日志序列号，会发现没有前推，必须用resetlogs打开数据库SQL&gt; select group#,status,sequence# from v$log; GROUP# STATUS SEQUENCE#---------- ---------------- ---------- 1 CURRENT 22 3 ACTIVE 21 2 ACTIVE 20RMAN&gt; alter database open resetlogs;database opened 使用resetlog的原因是recover命令只能修复控制文件中数据物理结构信息，而无法修改控制文件中的当前重做日志的序列号的信息，recover命令结束后，控制文件中的当前日志序列号还是陈旧的，若按常规方式打开数据库，将报错，为了抹去控制文件这个固执的念头，oracle采用重设日志的功能，日志序列号从1开始。此处虽然使用了resetlogs，但是因为“recover database”命令执行成功，所有提交的事务不会丢失，resetlogs仅仅是为了照顾还原的控制文件，与不完全恢复的resetlogs是不同的，至此恢复结束。 SQL&gt; conn test/testERROR:ORA-28002: the password will expire within 6 daysConnected.SQL&gt; select count(1) from t; COUNT(1)---------- 3000000]]></content>
      <categories>
        <category>oracle backup</category>
      </categories>
      <tags>
        <tag>oracle backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux+oracle兼容列表]]></title>
    <url>%2F2014%2F07%2F22%2Foracle%2Farchitecture%2Flinux%2Boracle-compatibility-list%2F</url>
    <content type="text"><![CDATA[linux+oracle兼容列表]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
</search>
