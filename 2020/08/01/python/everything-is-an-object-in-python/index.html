<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"liupzmin.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="变量的迷惑如果你有其它类C语言的使用经历(c,java,c++,Go等)，那么一提到变量，我们会将变量想象成一个box，它代表了计算机中的一块内存，是一个可以存放值的容器：  如上图所示，声明初始化一个a&#x3D;1，就相当于在内存中开辟了一块空间用于存放值1，使用变量名a就可以改变内存中的值a&#x3D;2。 当把a赋给一个新的变量b的时候，会在内存中为b重新开辟一块空间，并把a的一个副本存入其中。也就是说变量与">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析 python 一切皆对象">
<meta property="og:url" content="http://liupzmin.com/2020/08/01/python/everything-is-an-object-in-python/index.html">
<meta property="og:site_name" content="兔子先生">
<meta property="og:description" content="变量的迷惑如果你有其它类C语言的使用经历(c,java,c++,Go等)，那么一提到变量，我们会将变量想象成一个box，它代表了计算机中的一块内存，是一个可以存放值的容器：  如上图所示，声明初始化一个a&#x3D;1，就相当于在内存中开辟了一块空间用于存放值1，使用变量名a就可以改变内存中的值a&#x3D;2。 当把a赋给一个新的变量b的时候，会在内存中为b重新开辟一块空间，并把a的一个副本存入其中。也就是说变量与">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.liupzmin.com/cbox.jpg">
<meta property="og:image" content="http://qiniu.liupzmin.com/python-label.jpg">
<meta property="og:image" content="http://qiniu.liupzmin.com/copy-list.jpg">
<meta property="og:image" content="http://qiniu.liupzmin.com/copy-with-list.jpg">
<meta property="og:image" content="http://qiniu.liupzmin.com/deep-copy.jpg">
<meta property="og:image" content="http://qiniu.liupzmin.com/dum-t_doom-dee.png">
<meta property="og:image" content="http://qiniu.liupzmin.com/dum-skills-references.png">
<meta property="article:published_time" content="2020-08-01T05:29:02.000Z">
<meta property="article:modified_time" content="2025-02-07T01:32:12.643Z">
<meta property="article:author" content="巴流">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.liupzmin.com/cbox.jpg">


<link rel="canonical" href="http://liupzmin.com/2020/08/01/python/everything-is-an-object-in-python/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://liupzmin.com/2020/08/01/python/everything-is-an-object-in-python/","path":"2020/08/01/python/everything-is-an-object-in-python/","title":"浅析 python 一切皆对象"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>浅析 python 一切皆对象 | 兔子先生</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="兔子先生" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">兔子先生</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探寻计算机的历史与哲学密码</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">60</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">63</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%B7%E6%83%91"><span class="nav-number">1.</span> <span class="nav-text">变量的迷惑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">一切皆对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">函数调用，传值还是传引用?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">4.</span> <span class="nav-text">浅拷贝与深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D-shallow-copy"><span class="nav-number">4.1.</span> <span class="nav-text">浅拷贝(shallow copy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-deep-copy"><span class="nav-number">4.2.</span> <span class="nav-text">深拷贝(deep copy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E8%AE%BA%E5%85%83%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">再论元组</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="巴流"
      src="/images/gzh.jpg">
  <p class="site-author-name" itemprop="name">巴流</p>
  <div class="site-description" itemprop="description">左手人文 | 右手科技</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liupzmin"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdXB6bWluQGdtYWlsLmNvbQ==" title="E-Mail → mailto:liupzmin@gmail.com"><i class="envelope fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liupzmin.com/2020/08/01/python/everything-is-an-object-in-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gzh.jpg">
      <meta itemprop="name" content="巴流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兔子先生">
      <meta itemprop="description" content="左手人文 | 右手科技">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="浅析 python 一切皆对象 | 兔子先生">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浅析 python 一切皆对象<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWluL2xpdXB6bWluLmdpdGh1Yi5pby9lZGl0L2hleG9fcmVzb3VyY2Uvc291cmNlL19wb3N0cy9weXRob24vZXZlcnl0aGluZy1pcy1hbi1vYmplY3QtaW4tcHl0aG9uLm1k" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-01 13:29:02" itemprop="dateCreated datePublished" datetime="2020-08-01T13:29:02+08:00">2020-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 09:32:12" itemprop="dateModified" datetime="2025-02-07T09:32:12+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/%E9%87%8D%E5%AD%A6python/" itemprop="url" rel="index"><span itemprop="name">重学python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="变量的迷惑"><a href="#变量的迷惑" class="headerlink" title="变量的迷惑"></a>变量的迷惑</h2><p>如果你有其它类C语言的使用经历(<code>c</code>,<code>java</code>,<code>c++</code>,<code>Go</code>等)，那么一提到变量，我们会将变量想象成一个<code>box</code>，它代表了计算机中的一块内存，是一个可以存放值的容器：</p>
<p><img data-src="http://qiniu.liupzmin.com/cbox.jpg" alt="box"></p>
<p>如上图所示，声明初始化一个<code>a=1</code>，就相当于在内存中开辟了一块空间用于存放值<code>1</code>，使用变量名<code>a</code>就可以改变内存中的值<code>a=2</code>。 当把<code>a</code>赋给一个新的变量<code>b</code>的时候，会在内存中为<code>b</code>重新开辟一块空间，并把<code>a</code>的一个副本存入其中。也就是说变量与变量之间完全独立，抱有这种认识的人大多会对 python 中的变量产生很大的误解，不信我们试看下面的代码片段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(<span class="number">9527</span>, <span class="number">9527</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232581997552</span>, <span class="number">140232581997552</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>上面的代码段初始化了一个变量<code>a</code>并将其赋值为 9527，之后又把<code>a</code>赋给了变量<code>b</code>，打印他们的值都为 9527，到现在 python 中的变量表现和其它语言没什么不同（表面上看起来）。但我们接着打印了这两个变量的地址，你会惊奇的发现，<strong>他们竟然相同</strong>。使用<code>is</code>来判断，<code>b</code>就是<code>a</code>，也就是说此时在内存中只有一块空间来存放<code>9527</code>这个值。现在我们试着改变一下<code>a</code>的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(<span class="number">1024</span>, <span class="number">9527</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232581997456</span>, <span class="number">140232581997552</span>)</span><br></pre></td></tr></table></figure>

<p>我们赋予<code>a</code>一个新的值<code>1024</code>，然后打印了他们的值，python 的表现仍然跟我们<code>“预期”</code>的一样：<em>a的值改变了，b的值没有。</em>，但是在我们打印了他们的内存地址之后，一切看起来并没那么简单。</p>
<p><code>a</code>和<code>b</code>的地址最初都是<code>140232581997552</code>，当<code>a</code>重新赋值之后，<code>b</code>的地址没有改变，而<code>a</code>的地址却变成了<code>140232581997456</code>。也就是说，python的解释器重新开辟了一块内存给了<code>a</code>，这完全颠覆了我们印象中基于<code>box和store</code>对变量的理解。虽然目前看起来还算工作正常，但是我准备再对示例代码做一些改动：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232582690624</span>, <span class="number">140232582690624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这一次我们使用了<code>list</code>，一切看起来和刚才一样，<code>a</code>和<code>b</code>指向同一块内存，现在我们试着改变<code>list</code>中的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br></pre></td></tr></table></figure>

<p>你认为上段代码的输出会是什么？ <code>b</code>中元素的值也会改变么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a,b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] [<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>没错，这就是 python 让你惊讶的地方之一，这一次的表现不仅和你的<code>预期</code>不同，甚至和它上一次的表现也不相同。</p>
<p>第一次我们使用的是<code>number</code>，它在 python 中是一个<code>不可变对象</code>，python 中的变量其实是内存对象的一个标签，赋值仅仅是一个绑定的动作，画一个形象的图来表示：</p>
<p><img data-src="http://qiniu.liupzmin.com/python-label.jpg" alt="label"></p>
<p>当我们使用<code>list</code>时表现又不同，这是因为<code>list</code>在 python 中是一个<code>可变对象</code>。在 python 中一切皆对象，这种特殊的数据模型是造成我们误解的根本原因，接下来我们重点讨论一下 python 中的对象。</p>
<h2 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h2><blockquote>
<p>Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer”, code is also represented by objects.)<br>Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The ‘is’ operator compares the identity of two objects; the id() function returns an integer representing its identity.</p>
</blockquote>
<p>以上是 python 官网文档中的描述，翻译一下：<strong>Python中对象是所有数据的抽象。所有Python程序中的值都由对象或者对象之间的关系表示。Python中每个对象有一个唯一标识identity，一个对象的标识在对象被创建后不再改变。可以认为对象的identity是对象在内存中的地址，其值可以由内置函数id()求得。is操作符可以比较两个对象的identity是否相同，即两个对象是否是同一个。</strong></p>
<p>对于 python 中的变量赋值操作，有两种类比说法。一个是 <strong>“boxes vs. label”</strong> ，另一个是<strong>“names and bindings”</strong> 。我们采用<code>“names and bindings”</code> 这种说法，在 python 里一切都是对象，如interger、string、list、dict、set、function等。当我们赋值给一个变量的时候，我们仅仅把变量当成一个名字（name）：</p>
<p><code>&lt;name&gt; = &lt;object&gt;</code></p>
<p><strong>我们实际上是将一个对象和一个名称绑定，需要注意的是一个对象可以被多个名称绑定</strong>，这是最司空见惯的情况，也是最容易引起歧义的地方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(<span class="number">9527</span>, <span class="number">9527</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232581997552</span>, <span class="number">140232581997552</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;bohu&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;bohu&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="number">140090288720896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="number">140090288720896</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这段代码就展示了一个对象被多个名称绑定的情况，<code>number 9527</code>和字符串<code>bohu</code>是一个数值对象和一个字符串对象，并分别被两个变量绑定。</p>
<p>现在我们使用<code>list</code>来代替<code>number</code>和<code>string</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="number">140090289536200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="number">140090288737736</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，我们看到<code>a</code>和<code>b</code>指向了不同的内存空间，python 的表现之所以有所不同是因为<code>string</code>和<code>number</code>是<code>immutable</code>对象，而<code>list</code>是<code>mutable</code>的对象，关于python中对象的<code>mutability</code>见下表：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>immutable</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>Y</td>
</tr>
<tr>
<td>int</td>
<td>Y</td>
</tr>
<tr>
<td>float</td>
<td>Y</td>
</tr>
<tr>
<td>list</td>
<td>N</td>
</tr>
<tr>
<td>tuple</td>
<td>Y</td>
</tr>
<tr>
<td>str</td>
<td>Y</td>
</tr>
<tr>
<td>set</td>
<td>N</td>
</tr>
<tr>
<td>frozenset</td>
<td>Y</td>
</tr>
<tr>
<td>dict</td>
<td>N</td>
</tr>
</tbody></table>
<p>可见除了<code>list</code>，<code>set</code>，<code>dict</code>之外其余都是<code>不可变</code>的，一个<code>immutable</code>的对象被创建之后是不可以改变的。如果你试图通过与之绑定的变量去修改这个对象时，python会创建一个新的实例对象并与原来的变量绑定，之前的对象则伺机被回收。相反，一个<code>mutable</code>的对象是可以被原地改变的，比如之前的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232582690624</span>, <span class="number">140232582690624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a,b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] [<span class="number">1</span>, <span class="number">9527</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a),<span class="built_in">id</span>(b)</span><br><span class="line">(<span class="number">140232582690624</span>, <span class="number">140232582690624</span>)</span><br></pre></td></tr></table></figure>

<p>除非重新赋值，否则<code>a</code>和<code>b</code>绑定的对象的内存地址是不会改变的。当你使用<code>b = a</code>时，你并没有成功的<code>copy</code>一个<code>list</code>，你只是把两个<code>name</code>绑定到了同一个<code>list</code>对象之上。因此，正确的理解 python 的对象模型会帮助你正确的调试你的程序。</p>
<p>要理解 python 中的变量，我们就不能把变量当成一个盛放<code>值</code>的盒子，我们要把 python 中的变量当做贴在盒子上的<code>标签</code>。我们可以在同一个盒子上贴多个标签，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;super hero powers&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;super hero powers&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>当我们执行<code>a = &quot;super hero powers&quot;</code>时，我们说：<code>创建了等号右边的对象，并且把名称 a 绑定到这个对象上</code>。当我们执行<code>a = b</code>时，我们说：<code>把 a 绑定到 b 绑定的对象上</code>。</p>
<p>由此可见，在python中：</p>
<ul>
<li>变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。</li>
<li>可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。</li>
<li>对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+&#x3D; 等等）更新不可变对象的值时，会返回一个新的对象。</li>
<li>变量可以被删除，但是对象无法被删除。</li>
</ul>
<h2 id="函数调用，传值还是传引用"><a href="#函数调用，传值还是传引用" class="headerlink" title="函数调用，传值还是传引用?"></a>函数调用，传值还是传引用?</h2><p>先来看官方的一段描述：</p>
<blockquote>
<p>Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per se.</p>
</blockquote>
<p>参数的传递是通过赋值进行传递（<code>passed by assignment</code>）。也就是说，参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func1</span>(<span class="params">b</span>):</span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">my_func1(a)</span><br><span class="line">a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里的参数传递，使变量 a 和 b 同时指向了 1 这个对象。但当我们执行到 b &#x3D; 2 时，系统会重新创建一个值为 2 的新对象，并让 b 指向它；而 a 仍然指向 1 这个对象。所以，a 的值不变，仍然为 1。</p>
<p>那么对于上述例子的情况，是不是就没有办法改变 a 的值了呢？答案当然是否定的，我们只需稍作改变，让函数返回新变量，赋给 a。这样，a 就指向了一个新的值为 2 的对象，a 的值也因此变为 2。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func2</span>(<span class="params">b</span>):</span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a = my_func2(a)</span><br><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>当你想获取改变后的值的时候，最好的选择就是返回一个元组来包含多个结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line"><span class="meta">... </span>    a = <span class="string">&#x27;new-value&#x27;</span>        <span class="comment"># a and b are local names</span></span><br><span class="line"><span class="meta">... </span>    b = b + <span class="number">1</span>              <span class="comment"># assigned to new objects</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a, b            <span class="comment"># return new values</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="string">&#x27;old-value&#x27;</span>, <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(x, y)</span><br><span class="line">(<span class="string">&#x27;new-value&#x27;</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>当传入的参数是一个<code>mutable</code>的对象时，改变对象的值，就会影响所有指向它的变量，因此，我们可以利用这一点达到传引用的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a</span>):</span><br><span class="line"><span class="meta">... </span>    a[<span class="number">0</span>] = <span class="string">&#x27;new-value&#x27;</span>     <span class="comment"># &#x27;a&#x27; references a mutable list</span></span><br><span class="line"><span class="meta">... </span>    a[<span class="number">1</span>] = a[<span class="number">1</span>] + <span class="number">1</span>        <span class="comment"># changes a shared object</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="string">&#x27;old-value&#x27;</span>, <span class="number">99</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(args)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args</span><br><span class="line">[<span class="string">&#x27;new-value&#x27;</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>但我们要注意的是，<code>改变变量和重新赋值的区别</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">l2</span>):</span><br><span class="line">  l2 = l2 + [<span class="number">4</span>]</span><br><span class="line">  <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_func(l1)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>为什么 l1 仍然是[1, 2, 3]，而不是[1, 2, 3, 4]呢？</p>
<p>要注意，这里 l2 &#x3D; l2 + [4]，表示创建了一个“末尾加入元素 4“的新列表，并让 l2 指向这个新的对象。这个过程与 l1 无关，因此 l1 的值不变。当然，同样的，如果要改变 l1 的值，我们就得让上述函数返回一个新列表，再赋予 l1 即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">l2</span>):</span><br><span class="line">  l2 = l2 + [<span class="number">4</span>]</span><br><span class="line">  <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l1 = my_func(l1)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>当我们说深拷贝和浅拷贝时，一般都是针对于集合类型来讲的，如 python 中的<code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code>等。其它语言中的<code>struct</code>类型也会涉及到深浅拷贝之说，通常是指这些集合类型或者结构体中有其它集合的引用。</p>
<h3 id="浅拷贝-shallow-copy"><a href="#浅拷贝-shallow-copy" class="headerlink" title="浅拷贝(shallow copy)"></a>浅拷贝(shallow copy)</h3><p> <strong>浅拷贝会创建新对象，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用</strong>。注意，其内容非原对象本身的引用，而是原对象内第一层对象的引用。浅拷贝有三种形式:</p>
<ul>
<li>类型构造器</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = <span class="built_in">list</span>(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1),<span class="built_in">id</span>(l2)</span><br><span class="line">(<span class="number">140232580721664</span>, <span class="number">140232580722496</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1),<span class="built_in">id</span>(s2)</span><br><span class="line">(<span class="number">140232582029088</span>, <span class="number">140232580748448</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这里，l2 就是 l1 的浅拷贝，s2 是 s1 的浅拷贝。当然，对于可变的序列，我们还可以通过切片操作符&#39;:&#39;完成浅拷贝。</p>
<ul>
<li>切片操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3 = l1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l3</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>copy 模块中的 copy 函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = copy.copy(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1),<span class="built_in">id</span>(l2)</span><br><span class="line">(<span class="number">140232580721408</span>, <span class="number">140232580721664</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>因为浅拷贝只是创建一个新对象，集合中的元素内容仍然是原对象中子对象的引用，我们用以上三种方式中的任意一种来观察一下（因为他们都是浅拷贝，结果都是相同的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = copy.copy(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1),<span class="built_in">id</span>(l2)</span><br><span class="line">(<span class="number">140232580721408</span>, <span class="number">140232580721664</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l1[<span class="number">2</span>]),<span class="built_in">id</span>(l2[<span class="number">2</span>])</span><br><span class="line">(<span class="number">140232598059200</span>, <span class="number">140232598059200</span>)</span><br></pre></td></tr></table></figure>

<p>这里<code>l1</code>和<code>l2</code>是两个不同的对象，而<code>l1[2]</code>和<code>l2[2]</code>是两个变量名称，通过<code>id()</code>可以看到他们两个绑定到了相同的对象之上：</p>
<p><img data-src="http://qiniu.liupzmin.com/copy-list.jpg" alt="不带可变对象的拷贝"></p>
<p>这是没有可变对象的情况下的拷贝，当有可变对象时，也就是说当对象元素中有<code>list</code>、<code>set</code>、<code>dict</code>等集合对象时，浅拷贝只是做一个引用绑定，并不会创建新的可变对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = copy.copy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = copy.deepcopy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582406832</span>, <span class="number">140232582406832</span>, <span class="number">140232582406832</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>])</span><br><span class="line">(<span class="number">140232580722432</span>, <span class="number">140232580722432</span>, <span class="number">140232580722624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>][<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582979824</span>, <span class="number">140232582979824</span>, <span class="number">140232582979824</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码片段增加了深拷贝的例子，关于深拷贝我们一会儿再说，这里只看<code>s1</code>和<code>s2</code>，其中<code>s1</code>是包含列表的列表，经过浅拷贝之后我们发现：<code>s1[3]</code>和<code>s2[3]</code>指向同样的对象。可以说明浅拷贝只是对子列表做了变量绑定，并没有创建新的对象。那么你在修改<code>s1</code>的同时，必然会影响到<code>s2</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&quot;行藏在我&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>用一张图来描述一下此时的内存图景：</p>
<p><img data-src="http://qiniu.liupzmin.com/copy-with-list.jpg" alt="带可变对象的拷贝"></p>
<h3 id="深拷贝-deep-copy"><a href="#深拷贝-deep-copy" class="headerlink" title="深拷贝(deep copy)"></a>深拷贝(deep copy)</h3><p>深拷贝只有一种形式，copy 模块中的 deepcopy() 函数。深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。</p>
<p>通过上面的浅拷贝示例可知，浅拷贝不会为可变的子对象构建新的对象，这样就会带来修改了新数据之后旧数据也会被修改的副作用。有时候为了避免这种副作用，我们会使用深拷贝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = copy.copy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = copy.deepcopy(s1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582406832</span>, <span class="number">140232582406832</span>, <span class="number">140232582406832</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>])</span><br><span class="line">(<span class="number">140232580722432</span>, <span class="number">140232580722432</span>, <span class="number">140232580722624</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(s1[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s2[<span class="number">3</span>][<span class="number">0</span>]),<span class="built_in">id</span>(s3[<span class="number">3</span>][<span class="number">0</span>])</span><br><span class="line">(<span class="number">140232582979824</span>, <span class="number">140232582979824</span>, <span class="number">140232582979824</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&quot;行藏在我&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;行藏在我&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>还是上一节浅拷贝的例子，我们重点来看<code>s3</code>，<code>s3</code>是用深拷贝构建出来的，观察<code>可变子对象</code>的id可以发现它是一个新的对象，拥有全新的内存地址，但是<code>其中的不可变对象</code>仍然共享了原来的对象。</p>
<p>我们通过<code>s1[3][0] = &quot;行藏在我&quot;</code>改变了子列表中的内容之后，深拷贝构造出来的<code>s3</code>并未受到影响，因为<code>s1[3][0]</code>改变的是<code>s1[3]</code>指向的对象本身，而<code>s3[3]</code>指向的是另一个不同的对象，此时的内存图景为：</p>
<p><img data-src="http://qiniu.liupzmin.com/deep-copy.jpg" alt="带可变对象的深拷贝"></p>
<p>关于元组copy时的注意事项：</p>
<ul>
<li>元组只包含非容器类型时（如数字、字符串、和其他&#39;原子&#39;类型的对象），无论是浅拷贝还是深拷贝返回的都是原元组对象的引用。</li>
<li>元组包含可变对象时（如<code>list</code>、<code>set</code>、<code>dict</code>等），浅拷贝依然返回引用，深拷贝则会创建一个新的对象和子对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 = <span class="built_in">tuple</span>(tup1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tup1),<span class="built_in">id</span>(tup2)</span><br><span class="line">(<span class="number">140232580721216</span>, <span class="number">140232580721216</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 = copy.copy(tup1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4 = copy.deepcopy(tup1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tup3)</span><br><span class="line"><span class="number">140232580721216</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tup4)</span><br><span class="line"><span class="number">140232580721216</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4 <span class="keyword">is</span> tup1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 <span class="keyword">is</span> tup1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 <span class="keyword">is</span> tup1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist2 = copy.copy(tupwithlist1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist3 = copy.deepcopy(tupwithlist1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tupwithlist1),<span class="built_in">id</span>(tupwithlist2),<span class="built_in">id</span>(tupwithlist3)</span><br><span class="line">(<span class="number">140232580724112</span>, <span class="number">140232580724112</span>, <span class="number">140232580724672</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(tupwithlist1[<span class="number">3</span>]),<span class="built_in">id</span>(tupwithlist2[<span class="number">3</span>]),<span class="built_in">id</span>(tupwithlist3[<span class="number">3</span>])</span><br><span class="line">(<span class="number">140232580722304</span>, <span class="number">140232580722304</span>, <span class="number">140232580743680</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist1[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">9527</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist1</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">9527</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist2</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">9527</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tupwithlist3</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<h2 id="再论元组"><a href="#再论元组" class="headerlink" title="再论元组"></a>再论元组</h2><blockquote>
<p>元组是<code>immutable</code>的，却有潜在的被更改的可能性</p>
</blockquote>
<p>元组本身是不可变的，但是它包含的值却有可能被更改，特别是当元组<code>hold</code>住一个<code>mutable</code>的对象时，例如<code>list</code>。</p>
<p>有了之前把变量名称当做一个对象的标签的论述，我们这里举起例子来就容易多了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dee = (<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum = (<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum == dee</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum <span class="keyword">is</span> dee</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(dum), <span class="built_in">id</span>(dee)</span><br><span class="line">(<span class="number">4313018120</span>, <span class="number">4312991048</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom = dum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom</span><br><span class="line">(<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom == dum</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom <span class="keyword">is</span> dum</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>我们创建了2个tuple对象，<code>dum</code>和<code>t_doom</code>是第一个对象的标签，<code>dee</code>是第二个对象的标签。</p>
<p><img data-src="http://qiniu.liupzmin.com/dum-t_doom-dee.png" alt="dum-t_doom-dee"></p>
<p>现在我们为<code>t_doom</code>增加技能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>skills = t_doom[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>skills.append(<span class="string">&#x27;rap&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t_doom</span><br><span class="line">(<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dum</span><br><span class="line">(<span class="string">&#x27;1861-10-23&#x27;</span>, [<span class="string">&#x27;poetry&#x27;</span>, <span class="string">&#x27;pretend-fight&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><code>dum</code>和<code>t_doom</code>都获得了<code>rap</code>技能，原因是他们绑定的是同一个对象， <code>t_doom[1]</code> 和 <code>skills</code>也绑定到了同一个<code>list</code>对象上面：</p>
<p><img data-src="http://qiniu.liupzmin.com/dum-skills-references.png" alt="dum-skills-references"></p>
<p>那么我们为什么说此时元组仍是不可变的呢？其实不可变值得是元组的物理内容，元组里包含的是什么？是对于各种对象的引用，<code>dum[1]</code>引用的<code>list</code>对象的<code>值</code>改变了，但被引用的对象本身的<code>id</code>并没有变。所以，元组中的可变对象可能会有改动，但是可变对象本身却总保持不变。</p>
<p><strong>参考文章：</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3N3bGgvZXZlcnl0aGluZy1pcy1hbi1vYmplY3QtaW4tcHl0aG9uLWxlYXJuLXRvLXVzZS1mdW5jdGlvbnMtYXMtb2JqZWN0cy1hY2U3ZjMwZTI4M2U=">Everything Is an Object in Python — Learn to Use Functions as Objects<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BsYXJtYWxhZGUvcHl0aG9uLWV2ZXJ5dGhpbmctaXMtYW4tb2JqZWN0LWFuZC1zb21lLW9iamVjdHMtYXJlLW11dGFibGUtNGY1NWViMmI0Njhi">Python: Everything is an Object, and Some Objects are Mutable<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qZWZma251cHAuY29tL2Jsb2cvMjAxMi8xMS8xMy9pcy1weXRob24tY2FsbGJ5dmFsdWUtb3ItY2FsbGJ5cmVmZXJlbmNlLW5laXRoZXIv">Is Python call-by-value or call-by-reference? Neither.<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3JhZGFyLm9yZWlsbHkuY29tLzIwMTQvMTAvcHl0aG9uLXR1cGxlcy1pbW11dGFibGUtYnV0LXBvdGVudGlhbGx5LWNoYW5naW5nLmh0bWw=">Python tuples: immutable but potentially changing<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9yZWZlcmVuY2UvZGF0YW1vZGVsLmh0bWwjb2JqZWN0cy12YWx1ZXMtYW5kLXR5cGVz">Objects, values and types<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaS1wcm9ncmFtbWVyLmluZm8vcHJvZ3JhbW1pbmcvcHl0aG9uLzExNjgzLXByb2dyYW1tZXJzLXB5dGhvbi12YXJpYWJsZXMtb2JqZWN0cy1hbmQtYXR0cmlidXRlcy5odG1s">Programmer&#39;s Python - Variables, Objects and Attributes<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="python%E5%8F%98%E9%87%8F%E8%B7%9FC%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">python变量跟C中变量的区别</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/07/25/c/struct/" rel="prev" title="结构体速记">
                  <i class="fa fa-chevron-left"></i> 结构体速记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/03/design_patterns/strategy/" rel="next" title="策略模式（上）">
                  策略模式（上） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXB6bWlu" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"liupzmin","repo":"liupzmin.github.io","client_id":"77654195445087c01c56","client_secret":"eda09eecd05b86f0ef995d8067ec751abeb753d9","admin_user":"liupzmin","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","ClientID":"ae0756501dfc5de89d35","ClientSecret":"26befb359f7a466031bb96b4b7e0715c41c63fb8","owner":"liupzmin","adminUser":"['liupzmin']","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","createIssueManually":true,"distractionFreeMode":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"0889be999a0801c9a885ef7424348a59"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
